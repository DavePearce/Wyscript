<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_10) on Wed Mar 20 21:46:00 CET 2013 -->
<TITLE>
JCudaDriver (JCuda API Documentation)
</TITLE>

<META NAME="date" CONTENT="2013-03-20">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="JCudaDriver (JCuda API Documentation)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JCudaDriver.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../jcuda/driver/JITOptions.html" title="class in jcuda.driver"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?jcuda/driver/JCudaDriver.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JCudaDriver.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
jcuda.driver</FONT>
<BR>
Class JCudaDriver</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>jcuda.driver.JCudaDriver</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>JCudaDriver</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Java bindings for the NVidia CUDA driver API.<br />
 <br />
 Most comments are extracted from the CUDA online documentation
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_LAUNCH_PARAM_BUFFER_POINTER">CU_LAUNCH_PARAM_BUFFER_POINTER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicator that the next value in the \p extra parameter to
 ::cuLaunchKernel will be a pointer to a buffer containing all kernel
 parameters used for launching kernel \p f.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_LAUNCH_PARAM_BUFFER_SIZE">CU_LAUNCH_PARAM_BUFFER_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicator that the next value in the \p extra parameter to
 ::cuLaunchKernel will be a pointer to a size_t which contains the
 size of the buffer specified with ::CU_LAUNCH_PARAM_BUFFER_POINTER.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_LAUNCH_PARAM_END">CU_LAUNCH_PARAM_END</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;End of array terminator for the \p extra parameter to
 ::cuLaunchKernel</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_MEMHOSTALLOC_DEVICEMAP">CU_MEMHOSTALLOC_DEVICEMAP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set, host memory is mapped into CUDA address space and
 JCudaDriver#cuMemHostGetDevicePointer may be called on the host pointer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_MEMHOSTALLOC_PORTABLE">CU_MEMHOSTALLOC_PORTABLE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set, host memory is portable between CUDA contexts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_MEMHOSTALLOC_WRITECOMBINED">CU_MEMHOSTALLOC_WRITECOMBINED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set, host memory is allocated as write-combined - fast to write,
 faster to DMA, slow to read except via SSE4 streaming load instruction
 (MOVNTDQA).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_MEMHOSTREGISTER_DEVICEMAP">CU_MEMHOSTREGISTER_DEVICEMAP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set, host memory is mapped into CUDA address space and
 ::cuMemHostGetDevicePointer() may be called on the host pointer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_MEMHOSTREGISTER_PORTABLE">CU_MEMHOSTREGISTER_PORTABLE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set, host memory is portable between CUDA contexts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_MEMPEERREGISTER_DEVICEMAP">CU_MEMPEERREGISTER_DEVICEMAP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>This value has been added in CUDA 4.0 RC,
 and removed in CUDA 4.0 RC2</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_PARAM_TR_DEFAULT">CU_PARAM_TR_DEFAULT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For texture references loaded into the module, use default
 texunit from texture reference</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_STREAM_CALLBACK_BLOCKING">CU_STREAM_CALLBACK_BLOCKING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>This flag was only present in CUDA 5.0.25 (release candidate) 
 and may be removed (or added again) in future releases</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_STREAM_CALLBACK_NONBLOCKING">CU_STREAM_CALLBACK_NONBLOCKING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>This flag was only present in CUDA 5.0.25 (release candidate) 
 and may be removed (or added again) in future releases</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_TRSA_OVERRIDE_FORMAT">CU_TRSA_OVERRIDE_FORMAT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Override the texref format with a format inferred from the array</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_TRSF_NORMALIZED_COORDINATES">CU_TRSF_NORMALIZED_COORDINATES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use normalized texture coordinates in the range [0,1) instead of [0,dim)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_TRSF_READ_AS_INTEGER">CU_TRSF_READ_AS_INTEGER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read the texture as integers rather than promoting the values
 to floats in the range [0,1]</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_TRSF_SRGB">CU_TRSF_SRGB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform sRGB->linear conversion during texture read.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CUDA_ARRAY3D_2DARRAY">CUDA_ARRAY3D_2DARRAY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>use CUDA_ARRAY3D_LAYERED</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CUDA_ARRAY3D_CUBEMAP">CUDA_ARRAY3D_CUBEMAP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set, the CUDA array is a collection of six 2D arrays, representing faces of a cube.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CUDA_ARRAY3D_LAYERED">CUDA_ARRAY3D_LAYERED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set, the CUDA array is a collection of layers, where each layer is either a 1D
 or a 2D array and the Depth member of CUDA_ARRAY3D_DESCRIPTOR specifies the number
 of layers, not the depth of a 3D array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CUDA_ARRAY3D_SURFACE_LDST">CUDA_ARRAY3D_SURFACE_LDST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This flag must be set in order to bind a surface reference
 to the CUDA array</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CUDA_ARRAY3D_TEXTURE_GATHER">CUDA_ARRAY3D_TEXTURE_GATHER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This flag must be set in order to perform texture gather operations
 on a CUDA array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CUDA_VERSION">CUDA_VERSION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The CUDA version</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#align(int, int)">align</A></B>(int&nbsp;value,
      int&nbsp;alignment)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>This method was intended for a simpler
 kernel parameter setup in earlier CUDA versions,
 and should not be required any more. It may be
 removed in future releases.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)">cuArray3DCreate</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;pHandle,
                <A HREF="../../jcuda/driver/CUDA_ARRAY3D_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY3D_DESCRIPTOR</A>&nbsp;pAllocateArray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a 3D CUDA array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)">cuArray3DGetDescriptor</A></B>(<A HREF="../../jcuda/driver/CUDA_ARRAY3D_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY3D_DESCRIPTOR</A>&nbsp;pArrayDescriptor,
                       <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a 3D CUDA array descriptor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)">cuArrayCreate</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;pHandle,
              <A HREF="../../jcuda/driver/CUDA_ARRAY_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY_DESCRIPTOR</A>&nbsp;pAllocateArray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a 1D or 2D CUDA array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)">cuArrayDestroy</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroys a CUDA array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)">cuArrayGetDescriptor</A></B>(<A HREF="../../jcuda/driver/CUDA_ARRAY_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY_DESCRIPTOR</A>&nbsp;pArrayDescriptor,
                     <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a 1D or 2D CUDA array descriptor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxAttach(jcuda.driver.CUcontext, int)">cuCtxAttach</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pctx,
            int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increment a context's usage-count.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)">cuCtxCreate</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pctx,
            int&nbsp;flags,
            <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a CUDA context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)">cuCtxDestroy</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;ctx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroy a CUDA context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDetach(jcuda.driver.CUcontext)">cuCtxDetach</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;ctx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decrement a context's usage-count.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDisablePeerAccess(jcuda.driver.CUcontext)">cuCtxDisablePeerAccess</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;peerContext)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disables direct access to memory allocations in a peer context and unregisters any registered allocations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxEnablePeerAccess(jcuda.driver.CUcontext, int)">cuCtxEnablePeerAccess</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;peerContext,
                      int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables direct access to memory allocations in a peer context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])">cuCtxGetApiVersion</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;ctx,
                   int[]&nbsp;version)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the context's API version.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])">cuCtxGetCacheConfig</A></B>(int[]&nbsp;pconfig)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the preferred cache configuration for the current context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCurrent(jcuda.driver.CUcontext)">cuCtxGetCurrent</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pctx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the CUDA context bound to the calling CPU thread.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)">cuCtxGetDevice</A></B>(<A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;device)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the device ID for the current context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetLimit(long[], int)">cuCtxGetLimit</A></B>(long[]&nbsp;pvalue,
              int&nbsp;limit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns resource limits.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetSharedMemConfig(int[])">cuCtxGetSharedMemConfig</A></B>(int[]&nbsp;pConfig)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current shared memory configuration for the current context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)">cuCtxPopCurrent</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pctx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pops the current CUDA context from the current CPU thread.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)">cuCtxPushCurrent</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;ctx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pushes a context on the current CPU thread.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCacheConfig(int)">cuCtxSetCacheConfig</A></B>(int&nbsp;config)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the preferred cache configuration for the current context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCurrent(jcuda.driver.CUcontext)">cuCtxSetCurrent</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;ctx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds the specified CUDA context to the calling CPU thread.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetLimit(int, long)">cuCtxSetLimit</A></B>(int&nbsp;limit,
              long&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set resource limits.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetSharedMemConfig(int)">cuCtxSetSharedMemConfig</A></B>(int&nbsp;config)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the shared memory configuration for the current context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()">cuCtxSynchronize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Block for a context's tasks to complete.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceCanAccessPeer(int[], jcuda.driver.CUdevice, jcuda.driver.CUdevice)">cuDeviceCanAccessPeer</A></B>(int[]&nbsp;canAccessPeer,
                      <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev,
                      <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;peerDev)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queries if a device may directly access a peer device's memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceComputeCapability(int[], int[], jcuda.driver.CUdevice)">cuDeviceComputeCapability</A></B>(int[]&nbsp;major,
                          int[]&nbsp;minor,
                          <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the compute capability of the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGet(jcuda.driver.CUdevice, int)">cuDeviceGet</A></B>(<A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;device,
            int&nbsp;ordinal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a handle to a compute device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)">cuDeviceGetAttribute</A></B>(int[]&nbsp;pi,
                     int&nbsp;attrib,
                     <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns information about the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetByPCIBusId(jcuda.driver.CUdevice, java.lang.String)">cuDeviceGetByPCIBusId</A></B>(<A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev,
                      java.lang.String&nbsp;pciBusId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a handle to a compute device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetCount(int[])">cuDeviceGetCount</A></B>(int[]&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of compute-capable devices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)">cuDeviceGetName</A></B>(byte[]&nbsp;name,
                int&nbsp;len,
                <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an identifer string for the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetPCIBusId(java.lang.String[], int, jcuda.driver.CUdevice)">cuDeviceGetPCIBusId</A></B>(java.lang.String[]&nbsp;pciBusId,
                    int&nbsp;len,
                    <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a PCI Bus Id string for the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetProperties(jcuda.driver.CUdevprop, jcuda.driver.CUdevice)">cuDeviceGetProperties</A></B>(<A HREF="../../jcuda/driver/CUdevprop.html" title="class in jcuda.driver">CUdevprop</A>&nbsp;prop,
                      <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns properties for a selected device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceTotalMem(long[], jcuda.driver.CUdevice)">cuDeviceTotalMem</A></B>(long[]&nbsp;bytes,
                 <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the total amount of memory on the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDriverGetVersion(int[])">cuDriverGetVersion</A></B>(int[]&nbsp;driverVersion)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the CUDA driver version.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventCreate(jcuda.driver.CUevent, int)">cuEventCreate</A></B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;phEvent,
              int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an event.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventDestroy(jcuda.driver.CUevent)">cuEventDestroy</A></B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroys an event.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)">cuEventElapsedTime</A></B>(float[]&nbsp;pMilliseconds,
                   <A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hStart,
                   <A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEnd)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the elapsed time between two events.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventQuery(jcuda.driver.CUevent)">cuEventQuery</A></B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queries an event's status.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)">cuEventRecord</A></B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent,
              <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Records an event.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventSynchronize(jcuda.driver.CUevent)">cuEventSynchronize</A></B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Waits for an event to complete.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)">cuFuncGetAttribute</A></B>(int[]&nbsp;pi,
                   int&nbsp;attrib,
                   <A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns information about a function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)">cuFuncSetBlockShape</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                    int&nbsp;x,
                    int&nbsp;y,
                    int&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the block-dimensions for the function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)">cuFuncSetCacheConfig</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                     int&nbsp;config)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the preferred cache configuration for a device function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedMemConfig(jcuda.driver.CUfunction, int)">cuFuncSetSharedMemConfig</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                         int&nbsp;config)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the shared memory configuration for a device function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)">cuFuncSetSharedSize</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                    int&nbsp;bytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the dynamic shared-memory size for the function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)">cuGLCtxCreate</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pCtx,
              int&nbsp;Flags,
              <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;device)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a CUDA context for interoperability with OpenGL.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLGetDevices(int[], jcuda.driver.CUdevice[], int, int)">cuGLGetDevices</A></B>(int[]&nbsp;pCudaDeviceCount,
               <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>[]&nbsp;pCudaDevices,
               int&nbsp;cudaDeviceCount,
               int&nbsp;CUGLDeviceList_deviceList)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the CUDA devices associated with the current OpenGL context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLInit()">cuGLInit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes OpenGL interoperability.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLMapBufferObject(jcuda.driver.CUdeviceptr, long[], int)">cuGLMapBufferObject</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                    long[]&nbsp;size,
                    int&nbsp;bufferobj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maps an OpenGL buffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLMapBufferObjectAsync(jcuda.driver.CUdeviceptr, long[], int, jcuda.driver.CUstream)">cuGLMapBufferObjectAsync</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                         long[]&nbsp;size,
                         int&nbsp;buffer,
                         <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maps an OpenGL buffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLRegisterBufferObject(int)">cuGLRegisterBufferObject</A></B>(int&nbsp;bufferobj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers an OpenGL buffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLSetBufferObjectMapFlags(int, int)">cuGLSetBufferObjectMapFlags</A></B>(int&nbsp;buffer,
                            int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the map flags for an OpenGL buffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnmapBufferObject(int)">cuGLUnmapBufferObject</A></B>(int&nbsp;bufferobj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unmaps an OpenGL buffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnmapBufferObjectAsync(int, jcuda.driver.CUstream)">cuGLUnmapBufferObjectAsync</A></B>(int&nbsp;buffer,
                           <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unmaps an OpenGL buffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnregisterBufferObject(int)">cuGLUnregisterBufferObject</A></B>(int&nbsp;bufferobj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unregister an OpenGL buffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsGLRegisterBuffer(jcuda.driver.CUgraphicsResource, int, int)">cuGraphicsGLRegisterBuffer</A></B>(<A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;pCudaResource,
                           int&nbsp;buffer,
                           int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers an OpenGL buffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsGLRegisterImage(jcuda.driver.CUgraphicsResource, int, int, int)">cuGraphicsGLRegisterImage</A></B>(<A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;pCudaResource,
                          int&nbsp;image,
                          int&nbsp;target,
                          int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register an OpenGL texture or renderbuffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)">cuGraphicsMapResources</A></B>(int&nbsp;count,
                       <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>[]&nbsp;resources,
                       <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map graphics resources for access by CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsResourceGetMappedMipmappedArray(jcuda.driver.CUmipmappedArray, jcuda.driver.CUgraphicsResource)">cuGraphicsResourceGetMappedMipmappedArray</A></B>(<A HREF="../../jcuda/driver/CUmipmappedArray.html" title="class in jcuda.driver">CUmipmappedArray</A>&nbsp;pMipmappedArray,
                                          <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a mipmapped array through which to access a mapped graphics resource.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsResourceGetMappedPointer(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUgraphicsResource)">cuGraphicsResourceGetMappedPointer</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;pDevPtr,
                                   long[]&nbsp;pSize,
                                   <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a device pointer through which to access a mapped graphics resource.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsResourceSetMapFlags(jcuda.driver.CUgraphicsResource, int)">cuGraphicsResourceSetMapFlags</A></B>(<A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource,
                              int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set usage flags for mapping a graphics resource.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsSubResourceGetMappedArray(jcuda.driver.CUarray, jcuda.driver.CUgraphicsResource, int, int)">cuGraphicsSubResourceGetMappedArray</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;pArray,
                                    <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource,
                                    int&nbsp;arrayIndex,
                                    int&nbsp;mipLevel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get an array through which to access a subresource of a mapped graphics resource.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsUnmapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)">cuGraphicsUnmapResources</A></B>(int&nbsp;count,
                         <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>[]&nbsp;resources,
                         <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unmap graphics resources.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsUnregisterResource(jcuda.driver.CUgraphicsResource)">cuGraphicsUnregisterResource</A></B>(<A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unregisters a graphics resource for access by CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuInit(int)">cuInit</A></B>(int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initialize the CUDA driver API.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcCloseMemHandle(jcuda.driver.CUdeviceptr)">cuIpcCloseMemHandle</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Close memory mapped with cuIpcOpenMemHandle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcGetEventHandle(jcuda.driver.CUipcEventHandle, jcuda.driver.CUevent)">cuIpcGetEventHandle</A></B>(<A HREF="../../jcuda/driver/CUipcEventHandle.html" title="class in jcuda.driver">CUipcEventHandle</A>&nbsp;pHandle,
                    <A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets an interprocess handle for a previously allocated event.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcGetMemHandle(jcuda.driver.CUipcMemHandle, jcuda.driver.CUdeviceptr)">cuIpcGetMemHandle</A></B>(<A HREF="../../jcuda/driver/CUipcMemHandle.html" title="class in jcuda.driver">CUipcMemHandle</A>&nbsp;pHandle,
                  <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets an interprocess memory handle for an existing device memory
 allocation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcOpenEventHandle(jcuda.driver.CUevent, jcuda.driver.CUipcEventHandle)">cuIpcOpenEventHandle</A></B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;phEvent,
                     <A HREF="../../jcuda/driver/CUipcEventHandle.html" title="class in jcuda.driver">CUipcEventHandle</A>&nbsp;handle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Opens an interprocess event handle for use in the current process.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcOpenMemHandle(jcuda.driver.CUdeviceptr, jcuda.driver.CUipcMemHandle, int)">cuIpcOpenMemHandle</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;pdptr,
                   <A HREF="../../jcuda/driver/CUipcMemHandle.html" title="class in jcuda.driver">CUipcMemHandle</A>&nbsp;handle,
                   int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 CUresult cuIpcOpenMemHandle (
      CUdeviceptr* pdptr,
      CUipcMemHandle handle,
      unsigned int  Flags )
 
 <div>
    /brief Opens an interprocess memory
     handle exported from another process and returns a device pointer
     usable in the local
     process.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)">cuLaunch</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Launches a CUDA function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)">cuLaunchGrid</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;f,
             int&nbsp;grid_width,
             int&nbsp;grid_height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Launches a CUDA function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)">cuLaunchGridAsync</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;f,
                  int&nbsp;grid_width,
                  int&nbsp;grid_height,
                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Launches a CUDA function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)">cuLaunchKernel</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;f,
               int&nbsp;gridDimX,
               int&nbsp;gridDimY,
               int&nbsp;gridDimZ,
               int&nbsp;blockDimX,
               int&nbsp;blockDimY,
               int&nbsp;blockDimZ,
               int&nbsp;sharedMemBytes,
               <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream,
               <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;kernelParams,
               <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;extra)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Launches a CUDA function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)">cuMemAlloc</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
           long&nbsp;bytesize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)">cuMemAllocHost</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pointer,
               long&nbsp;bytesize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates page-locked host memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)">cuMemAllocPitch</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                long[]&nbsp;pPitch,
                long&nbsp;WidthInBytes,
                long&nbsp;Height,
                int&nbsp;ElementSizeBytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates pitched device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)">cuMemcpy</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dst,
         <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;src,
         long&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)">cuMemcpy2D</A></B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY2D.html" title="class in jcuda.driver">CUDA_MEMCPY2D</A>&nbsp;pCopy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory for 2D arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)">cuMemcpy2DAsync</A></B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY2D.html" title="class in jcuda.driver">CUDA_MEMCPY2D</A>&nbsp;pCopy,
                <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory for 2D arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)">cuMemcpy2DUnaligned</A></B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY2D.html" title="class in jcuda.driver">CUDA_MEMCPY2D</A>&nbsp;pCopy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory for 2D arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)">cuMemcpy3D</A></B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY3D.html" title="class in jcuda.driver">CUDA_MEMCPY3D</A>&nbsp;pCopy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory for 3D arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)">cuMemcpy3DAsync</A></B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY3D.html" title="class in jcuda.driver">CUDA_MEMCPY3D</A>&nbsp;pCopy,
                <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory for 3D arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DPeer(jcuda.driver.CUDA_MEMCPY3D_PEER)">cuMemcpy3DPeer</A></B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY3D_PEER.html" title="class in jcuda.driver">CUDA_MEMCPY3D_PEER</A>&nbsp;pCopy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory between contexts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DPeerAsync(jcuda.driver.CUDA_MEMCPY3D_PEER, jcuda.driver.CUstream)">cuMemcpy3DPeerAsync</A></B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY3D_PEER.html" title="class in jcuda.driver">CUDA_MEMCPY3D_PEER</A>&nbsp;pCopy,
                    <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory between contexts asynchronously.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)">cuMemcpyAsync</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dst,
              <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;src,
              long&nbsp;ByteCount,
              <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory asynchronously.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)">cuMemcpyAtoA</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;dstArray,
             long&nbsp;dstIndex,
             <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;srcArray,
             long&nbsp;srcIndex,
             long&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Array to Array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)">cuMemcpyAtoD</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
             <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hSrc,
             long&nbsp;SrcIndex,
             long&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Array to Device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)">cuMemcpyAtoH</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dstHost,
             <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;srcArray,
             long&nbsp;srcIndex,
             long&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Array to Host.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)">cuMemcpyAtoHAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dstHost,
                  <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;srcArray,
                  long&nbsp;srcIndex,
                  long&nbsp;ByteCount,
                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Array to Host.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)">cuMemcpyDtoA</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;dstArray,
             long&nbsp;dstIndex,
             <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
             long&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Device to Array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)">cuMemcpyDtoD</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
             <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
             long&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Device to Device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)">cuMemcpyDtoDAsync</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                  <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
                  long&nbsp;ByteCount,
                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Device to Device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)">cuMemcpyDtoH</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dstHost,
             <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
             long&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Device to Host.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)">cuMemcpyDtoHAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dstHost,
                  <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
                  long&nbsp;ByteCount,
                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Device to Host.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)">cuMemcpyHtoA</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;dstArray,
             long&nbsp;dstIndex,
             <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pSrc,
             long&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Host to Array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)">cuMemcpyHtoAAsync</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;dstArray,
                  long&nbsp;dstIndex,
                  <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pSrc,
                  long&nbsp;ByteCount,
                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Host to Array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)">cuMemcpyHtoD</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
             <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;srcHost,
             long&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Host to Device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)">cuMemcpyHtoDAsync</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                  <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;srcHost,
                  long&nbsp;ByteCount,
                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Host to Device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyPeer(jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, long)">cuMemcpyPeer</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
             <A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;dstContext,
             <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
             <A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;srcContext,
             long&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies device memory between two contexts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyPeerAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, long, jcuda.driver.CUstream)">cuMemcpyPeerAsync</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                  <A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;dstContext,
                  <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
                  <A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;srcContext,
                  long&nbsp;ByteCount,
                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies device memory between two contexts asynchronously.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)">cuMemFree</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frees device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)">cuMemFreeHost</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frees page-locked host memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)">cuMemGetAddressRange</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;pbase,
                     long[]&nbsp;psize,
                     <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get information on memory allocations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])">cuMemGetInfo</A></B>(long[]&nbsp;free,
             long[]&nbsp;total)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets free and total memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)">cuMemHostAlloc</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pp,
               long&nbsp;bytes,
               int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates page-locked host memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)">cuMemHostGetDevicePointer</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;ret,
                          <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p,
                          int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Passes back device pointer of mapped pinned memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetFlags(int[], jcuda.Pointer)">cuMemHostGetFlags</A></B>(int[]&nbsp;pFlags,
                  <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Passes back flags that were used for a pinned allocation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostRegister(jcuda.Pointer, long, int)">cuMemHostRegister</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p,
                  long&nbsp;bytesize,
                  int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers an existing host memory range for use by CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostUnregister(jcuda.Pointer)">cuMemHostUnregister</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unregisters a memory range that was registered with cuMemHostRegister.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)">cuMemsetD16</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
            short&nbsp;us,
            long&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)">cuMemsetD16Async</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                 short&nbsp;us,
                 long&nbsp;N,
                 <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)">cuMemsetD2D16</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
              long&nbsp;dstPitch,
              short&nbsp;us,
              long&nbsp;Width,
              long&nbsp;Height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)">cuMemsetD2D16Async</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                   long&nbsp;dstPitch,
                   short&nbsp;us,
                   long&nbsp;Width,
                   long&nbsp;Height,
                   <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)">cuMemsetD2D32</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
              long&nbsp;dstPitch,
              int&nbsp;ui,
              long&nbsp;Width,
              long&nbsp;Height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)">cuMemsetD2D32Async</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                   long&nbsp;dstPitch,
                   int&nbsp;ui,
                   long&nbsp;Width,
                   long&nbsp;Height,
                   <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)">cuMemsetD2D8</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
             long&nbsp;dstPitch,
             byte&nbsp;uc,
             long&nbsp;Width,
             long&nbsp;Height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)">cuMemsetD2D8Async</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                  long&nbsp;dstPitch,
                  byte&nbsp;uc,
                  long&nbsp;Width,
                  long&nbsp;Height,
                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)">cuMemsetD32</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
            int&nbsp;ui,
            long&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)">cuMemsetD32Async</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                 int&nbsp;ui,
                 long&nbsp;N,
                 <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)">cuMemsetD8</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
           byte&nbsp;uc,
           long&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)">cuMemsetD8Async</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                byte&nbsp;uc,
                long&nbsp;N,
                <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMipmappedArrayCreate(jcuda.driver.CUmipmappedArray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, int)">cuMipmappedArrayCreate</A></B>(<A HREF="../../jcuda/driver/CUmipmappedArray.html" title="class in jcuda.driver">CUmipmappedArray</A>&nbsp;pHandle,
                       <A HREF="../../jcuda/driver/CUDA_ARRAY3D_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY3D_DESCRIPTOR</A>&nbsp;pMipmappedArrayDesc,
                       int&nbsp;numMipmapLevels)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a CUDA mipmapped array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMipmappedArrayDestroy(jcuda.driver.CUmipmappedArray)">cuMipmappedArrayDestroy</A></B>(<A HREF="../../jcuda/driver/CUmipmappedArray.html" title="class in jcuda.driver">CUmipmappedArray</A>&nbsp;hMipmappedArray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroys a CUDA mipmapped array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMipmappedArrayGetLevel(jcuda.driver.CUarray, jcuda.driver.CUmipmappedArray, int)">cuMipmappedArrayGetLevel</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;pLevelArray,
                         <A HREF="../../jcuda/driver/CUmipmappedArray.html" title="class in jcuda.driver">CUmipmappedArray</A>&nbsp;hMipmappedArray,
                         int&nbsp;level)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets a mipmap level of a CUDA mipmapped array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)">cuModuleGetFunction</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                    <A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod,
                    java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a function handle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)">cuModuleGetGlobal</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                  long[]&nbsp;bytes,
                  <A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod,
                  java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a global pointer from a module.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetSurfRef(jcuda.driver.CUsurfref, jcuda.driver.CUmodule, java.lang.String)">cuModuleGetSurfRef</A></B>(<A HREF="../../jcuda/driver/CUsurfref.html" title="class in jcuda.driver">CUsurfref</A>&nbsp;pSurfRef,
                   <A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod,
                   java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a handle to a surface reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)">cuModuleGetTexRef</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;pTexRef,
                  <A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod,
                  java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a handle to a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)">cuModuleLoad</A></B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;module,
             java.lang.String&nbsp;fname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Loads a compute module.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadData(jcuda.driver.CUmodule, byte[])">cuModuleLoadData</A></B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;module,
                 byte[]&nbsp;image)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Load a module's data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)">cuModuleLoadDataEx</A></B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;phMod,
                   <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p,
                   int&nbsp;numOptions,
                   int[]&nbsp;options,
                   <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;optionValues)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Load a module's data with options.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadDataJIT(jcuda.driver.CUmodule, jcuda.Pointer, jcuda.driver.JITOptions)">cuModuleLoadDataJIT</A></B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;module,
                    <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pointer,
                    <A HREF="../../jcuda/driver/JITOptions.html" title="class in jcuda.driver">JITOptions</A>&nbsp;jitOptions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A wrapper function for 
 <A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)"><CODE>cuModuleLoadDataEx(CUmodule, Pointer, int, int[], Pointer)</CODE></A>
 which allows passing in the options for the JIT compiler, and obtaining
 the output of the JIT compiler via a <A HREF="../../jcuda/driver/JITOptions.html" title="class in jcuda.driver"><CODE>JITOptions</CODE></A> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])">cuModuleLoadFatBinary</A></B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;module,
                      byte[]&nbsp;fatCubin)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Load a module's data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleUnload(jcuda.driver.CUmodule)">cuModuleUnload</A></B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unloads a module.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)">cuParamSetf</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
            int&nbsp;offset,
            float&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a floating-point parameter to the function's argument list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)">cuParamSeti</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
            int&nbsp;offset,
            int&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds an integer parameter to the function's argument list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)">cuParamSetSize</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
               int&nbsp;numbytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the parameter size for the function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)">cuParamSetTexRef</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                 int&nbsp;texunit,
                 <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a texture-reference to the function's argument list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)">cuParamSetv</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
            int&nbsp;offset,
            <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr,
            int&nbsp;numbytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds arbitrary data to the function's argument list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuPointerGetAttribute(jcuda.Pointer, int, jcuda.driver.CUdeviceptr)">cuPointerGetAttribute</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;data,
                      int&nbsp;attribute,
                      <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;ptr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns information about a pointer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuProfilerInitialize(java.lang.String, java.lang.String, int)">cuProfilerInitialize</A></B>(java.lang.String&nbsp;configFile,
                     java.lang.String&nbsp;outputFile,
                     int&nbsp;outputMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initialize the profiling.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuProfilerStart()">cuProfilerStart</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable profiling.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuProfilerStop()">cuProfilerStop</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disable profiling.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamAddCallback(jcuda.driver.CUstream, jcuda.driver.CUstreamCallback, java.lang.Object, int)">cuStreamAddCallback</A></B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream,
                    <A HREF="../../jcuda/driver/CUstreamCallback.html" title="interface in jcuda.driver">CUstreamCallback</A>&nbsp;callback,
                    java.lang.Object&nbsp;userData,
                    int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a callback to a compute stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamCreate(jcuda.driver.CUstream, int)">cuStreamCreate</A></B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;phStream,
               int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamDestroy(jcuda.driver.CUstream)">cuStreamDestroy</A></B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroys a stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamQuery(jcuda.driver.CUstream)">cuStreamQuery</A></B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine status of a compute stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamSynchronize(jcuda.driver.CUstream)">cuStreamSynchronize</A></B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wait until a stream's tasks are completed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)">cuStreamWaitEvent</A></B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream,
                  <A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent,
                  int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a compute stream wait on an event.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuSurfObjectCreate(jcuda.driver.CUsurfObject, jcuda.driver.CUDA_RESOURCE_DESC)">cuSurfObjectCreate</A></B>(<A HREF="../../jcuda/driver/CUsurfObject.html" title="class in jcuda.driver">CUsurfObject</A>&nbsp;pSurfObject,
                   <A HREF="../../jcuda/driver/CUDA_RESOURCE_DESC.html" title="class in jcuda.driver">CUDA_RESOURCE_DESC</A>&nbsp;pResDesc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a surface object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuSurfObjectDestroy(jcuda.driver.CUsurfObject)">cuSurfObjectDestroy</A></B>(<A HREF="../../jcuda/driver/CUsurfObject.html" title="class in jcuda.driver">CUsurfObject</A>&nbsp;surfObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroys a surface object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuSurfObjectGetResourceDesc(jcuda.driver.CUDA_RESOURCE_DESC, jcuda.driver.CUsurfObject)">cuSurfObjectGetResourceDesc</A></B>(<A HREF="../../jcuda/driver/CUDA_RESOURCE_DESC.html" title="class in jcuda.driver">CUDA_RESOURCE_DESC</A>&nbsp;pResDesc,
                            <A HREF="../../jcuda/driver/CUsurfObject.html" title="class in jcuda.driver">CUsurfObject</A>&nbsp;surfObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a surface object's resource descriptor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuSurfRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUsurfref)">cuSurfRefGetArray</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;phArray,
                  <A HREF="../../jcuda/driver/CUsurfref.html" title="class in jcuda.driver">CUsurfref</A>&nbsp;hSurfRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Passes back the CUDA array bound to a surface reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuSurfRefSetArray(jcuda.driver.CUsurfref, jcuda.driver.CUarray, int)">cuSurfRefSetArray</A></B>(<A HREF="../../jcuda/driver/CUsurfref.html" title="class in jcuda.driver">CUsurfref</A>&nbsp;hSurfRef,
                  <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray,
                  int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the CUDA array for a surface reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexObjectCreate(jcuda.driver.CUtexObject, jcuda.driver.CUDA_RESOURCE_DESC, jcuda.driver.CUDA_TEXTURE_DESC, jcuda.driver.CUDA_RESOURCE_VIEW_DESC)">cuTexObjectCreate</A></B>(<A HREF="../../jcuda/driver/CUtexObject.html" title="class in jcuda.driver">CUtexObject</A>&nbsp;pTexObject,
                  <A HREF="../../jcuda/driver/CUDA_RESOURCE_DESC.html" title="class in jcuda.driver">CUDA_RESOURCE_DESC</A>&nbsp;pResDesc,
                  <A HREF="../../jcuda/driver/CUDA_TEXTURE_DESC.html" title="class in jcuda.driver">CUDA_TEXTURE_DESC</A>&nbsp;pTexDesc,
                  <A HREF="../../jcuda/driver/CUDA_RESOURCE_VIEW_DESC.html" title="class in jcuda.driver">CUDA_RESOURCE_VIEW_DESC</A>&nbsp;pResViewDesc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a texture object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexObjectDestroy(jcuda.driver.CUtexObject)">cuTexObjectDestroy</A></B>(<A HREF="../../jcuda/driver/CUtexObject.html" title="class in jcuda.driver">CUtexObject</A>&nbsp;texObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroys a texture object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexObjectGetResourceDesc(jcuda.driver.CUDA_RESOURCE_DESC, jcuda.driver.CUtexObject)">cuTexObjectGetResourceDesc</A></B>(<A HREF="../../jcuda/driver/CUDA_RESOURCE_DESC.html" title="class in jcuda.driver">CUDA_RESOURCE_DESC</A>&nbsp;pResDesc,
                           <A HREF="../../jcuda/driver/CUtexObject.html" title="class in jcuda.driver">CUtexObject</A>&nbsp;texObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a texture object's resource descriptor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexObjectGetResourceViewDesc(jcuda.driver.CUDA_RESOURCE_VIEW_DESC, jcuda.driver.CUtexObject)">cuTexObjectGetResourceViewDesc</A></B>(<A HREF="../../jcuda/driver/CUDA_RESOURCE_VIEW_DESC.html" title="class in jcuda.driver">CUDA_RESOURCE_VIEW_DESC</A>&nbsp;pResViewDesc,
                               <A HREF="../../jcuda/driver/CUtexObject.html" title="class in jcuda.driver">CUtexObject</A>&nbsp;texObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a texture object's resource view descriptor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexObjectGetTextureDesc(jcuda.driver.CUDA_TEXTURE_DESC, jcuda.driver.CUtexObject)">cuTexObjectGetTextureDesc</A></B>(<A HREF="../../jcuda/driver/CUDA_TEXTURE_DESC.html" title="class in jcuda.driver">CUDA_TEXTURE_DESC</A>&nbsp;pTexDesc,
                          <A HREF="../../jcuda/driver/CUtexObject.html" title="class in jcuda.driver">CUtexObject</A>&nbsp;texObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a texture object's texture descriptor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefCreate(jcuda.driver.CUtexref)">cuTexRefCreate</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;pTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefDestroy(jcuda.driver.CUtexref)">cuTexRefDestroy</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroys a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)">cuTexRefGetAddress</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;pdptr,
                   <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the address associated with a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)">cuTexRefGetAddressMode</A></B>(int[]&nbsp;pam,
                       <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                       int&nbsp;dim)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the addressing mode used by a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)">cuTexRefGetArray</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;phArray,
                 <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the array bound to a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)">cuTexRefGetFilterMode</A></B>(int[]&nbsp;pfm,
                      <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the filter-mode used by a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)">cuTexRefGetFlags</A></B>(int[]&nbsp;pFlags,
                 <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the flags used by a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)">cuTexRefGetFormat</A></B>(int[]&nbsp;pFormat,
                  int[]&nbsp;pNumChannels,
                  <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the format used by a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetMaxAnisotropy(int[], jcuda.driver.CUtexref)">cuTexRefGetMaxAnisotropy</A></B>(int[]&nbsp;pmaxAniso,
                         <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the maximum anistropy for a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetMipmapFilterMode(int[], jcuda.driver.CUtexref)">cuTexRefGetMipmapFilterMode</A></B>(int[]&nbsp;pfm,
                            <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the mipmap filtering mode for a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetMipmapLevelBias(float[], jcuda.driver.CUtexref)">cuTexRefGetMipmapLevelBias</A></B>(float[]&nbsp;pbias,
                           <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the mipmap level bias for a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetMipmapLevelClamp(float[], float[], jcuda.driver.CUtexref)">cuTexRefGetMipmapLevelClamp</A></B>(float[]&nbsp;pminMipmapLevelClamp,
                            float[]&nbsp;pmaxMipmapLevelClamp,
                            <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the min/max mipmap level clamps for a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetMipmappedArray(jcuda.driver.CUmipmappedArray, jcuda.driver.CUtexref)">cuTexRefGetMipmappedArray</A></B>(<A HREF="../../jcuda/driver/CUmipmappedArray.html" title="class in jcuda.driver">CUmipmappedArray</A>&nbsp;phMipmappedArray,
                          <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the mipmapped array bound to a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)">cuTexRefSetAddress</A></B>(long[]&nbsp;ByteOffset,
                   <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                   <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                   long&nbsp;bytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds an address as a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)">cuTexRefSetAddress2D</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                     <A HREF="../../jcuda/driver/CUDA_ARRAY_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY_DESCRIPTOR</A>&nbsp;desc,
                     <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                     long&nbsp;PitchInBytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds an address as a 2D texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)">cuTexRefSetAddressMode</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                       int&nbsp;dim,
                       int&nbsp;am)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the addressing mode for a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)">cuTexRefSetArray</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                 <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray,
                 int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds an array as a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)">cuTexRefSetFilterMode</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                      int&nbsp;fm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the filtering mode for a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)">cuTexRefSetFlags</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                 int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the flags for a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)">cuTexRefSetFormat</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                  int&nbsp;fmt,
                  int&nbsp;NumPackedComponents)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the format for a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetMaxAnisotropy(jcuda.driver.CUtexref, int)">cuTexRefSetMaxAnisotropy</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                         int&nbsp;maxAniso)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the maximum anistropy for a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetMipmapFilterMode(jcuda.driver.CUtexref, int)">cuTexRefSetMipmapFilterMode</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                            int&nbsp;fm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the mipmap filtering mode for a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetMipmapLevelBias(jcuda.driver.CUtexref, float)">cuTexRefSetMipmapLevelBias</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                           float&nbsp;bias)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the mipmap level bias for a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetMipmapLevelClamp(jcuda.driver.CUtexref, float, float)">cuTexRefSetMipmapLevelClamp</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                            float&nbsp;minMipmapLevelClamp,
                            float&nbsp;maxMipmapLevelClamp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the mipmap min/max mipmap level clamps for a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetMipmappedArray(jcuda.driver.CUtexref, jcuda.driver.CUmipmappedArray, int)">cuTexRefSetMipmappedArray</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                          <A HREF="../../jcuda/driver/CUmipmappedArray.html" title="class in jcuda.driver">CUmipmappedArray</A>&nbsp;hMipmappedArray,
                          int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds a mipmapped array to a texture reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#setExceptionsEnabled(boolean)">setExceptionsEnabled</A></B>(boolean&nbsp;enabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables or disables exceptions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#setLogLevel(jcuda.LogLevel)">setLogLevel</A></B>(<A HREF="../../jcuda/LogLevel.html" title="enum in jcuda">LogLevel</A>&nbsp;logLevel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the specified log level for the JCuda driver library.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="CUDA_VERSION"><!-- --></A><H3>
CUDA_VERSION</H3>
<PRE>
public static final int <B>CUDA_VERSION</B></PRE>
<DL>
<DD>The CUDA version
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CUDA_VERSION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_MEMHOSTALLOC_PORTABLE"><!-- --></A><H3>
CU_MEMHOSTALLOC_PORTABLE</H3>
<PRE>
public static final int <B>CU_MEMHOSTALLOC_PORTABLE</B></PRE>
<DL>
<DD>If set, host memory is portable between CUDA contexts.
 Flag for <A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_MEMHOSTALLOC_PORTABLE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_MEMHOSTALLOC_DEVICEMAP"><!-- --></A><H3>
CU_MEMHOSTALLOC_DEVICEMAP</H3>
<PRE>
public static final int <B>CU_MEMHOSTALLOC_DEVICEMAP</B></PRE>
<DL>
<DD>If set, host memory is mapped into CUDA address space and
 JCudaDriver#cuMemHostGetDevicePointer may be called on the host pointer.
 Flag for <A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_MEMHOSTALLOC_DEVICEMAP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_MEMHOSTALLOC_WRITECOMBINED"><!-- --></A><H3>
CU_MEMHOSTALLOC_WRITECOMBINED</H3>
<PRE>
public static final int <B>CU_MEMHOSTALLOC_WRITECOMBINED</B></PRE>
<DL>
<DD>If set, host memory is allocated as write-combined - fast to write,
 faster to DMA, slow to read except via SSE4 streaming load instruction
 (MOVNTDQA).
 Flag for <A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_MEMHOSTALLOC_WRITECOMBINED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_MEMHOSTREGISTER_PORTABLE"><!-- --></A><H3>
CU_MEMHOSTREGISTER_PORTABLE</H3>
<PRE>
public static final int <B>CU_MEMHOSTREGISTER_PORTABLE</B></PRE>
<DL>
<DD>If set, host memory is portable between CUDA contexts.
 Flag for ::cuMemHostRegister()
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_MEMHOSTREGISTER_PORTABLE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_MEMHOSTREGISTER_DEVICEMAP"><!-- --></A><H3>
CU_MEMHOSTREGISTER_DEVICEMAP</H3>
<PRE>
public static final int <B>CU_MEMHOSTREGISTER_DEVICEMAP</B></PRE>
<DL>
<DD>If set, host memory is mapped into CUDA address space and
 ::cuMemHostGetDevicePointer() may be called on the host pointer.
 Flag for ::cuMemHostRegister()
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_MEMHOSTREGISTER_DEVICEMAP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_MEMPEERREGISTER_DEVICEMAP"><!-- --></A><H3>
CU_MEMPEERREGISTER_DEVICEMAP</H3>
<PRE>
public static final int <B>CU_MEMPEERREGISTER_DEVICEMAP</B></PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>This value has been added in CUDA 4.0 RC,
 and removed in CUDA 4.0 RC2</I><DD>If set, peer memory is mapped into CUDA address space and
 ::cuMemPeerGetDevicePointer() may be called on the host pointer.
 Flag for ::cuMemPeerRegister()
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_MEMPEERREGISTER_DEVICEMAP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CUDA_ARRAY3D_LAYERED"><!-- --></A><H3>
CUDA_ARRAY3D_LAYERED</H3>
<PRE>
public static final int <B>CUDA_ARRAY3D_LAYERED</B></PRE>
<DL>
<DD>If set, the CUDA array is a collection of layers, where each layer is either a 1D
 or a 2D array and the Depth member of CUDA_ARRAY3D_DESCRIPTOR specifies the number
 of layers, not the depth of a 3D array.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CUDA_ARRAY3D_LAYERED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CUDA_ARRAY3D_2DARRAY"><!-- --></A><H3>
CUDA_ARRAY3D_2DARRAY</H3>
<PRE>
public static final int <B>CUDA_ARRAY3D_2DARRAY</B></PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use CUDA_ARRAY3D_LAYERED</I><DD>If set, the CUDA array contains an array of 2D slices
 and the Depth member of CUDA_ARRAY3D_DESCRIPTOR specifies
 the number of slices, not the depth of a 3D array.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CUDA_ARRAY3D_2DARRAY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CUDA_ARRAY3D_SURFACE_LDST"><!-- --></A><H3>
CUDA_ARRAY3D_SURFACE_LDST</H3>
<PRE>
public static final int <B>CUDA_ARRAY3D_SURFACE_LDST</B></PRE>
<DL>
<DD>This flag must be set in order to bind a surface reference
 to the CUDA array
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CUDA_ARRAY3D_SURFACE_LDST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CUDA_ARRAY3D_CUBEMAP"><!-- --></A><H3>
CUDA_ARRAY3D_CUBEMAP</H3>
<PRE>
public static final int <B>CUDA_ARRAY3D_CUBEMAP</B></PRE>
<DL>
<DD>If set, the CUDA array is a collection of six 2D arrays, representing faces of a cube. The
 width of such a CUDA array must be equal to its height, and Depth must be six.
 If ::CUDA_ARRAY3D_LAYERED flag is also set, then the CUDA array is a collection of cubemaps
 and Depth must be a multiple of six.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CUDA_ARRAY3D_CUBEMAP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CUDA_ARRAY3D_TEXTURE_GATHER"><!-- --></A><H3>
CUDA_ARRAY3D_TEXTURE_GATHER</H3>
<PRE>
public static final int <B>CUDA_ARRAY3D_TEXTURE_GATHER</B></PRE>
<DL>
<DD>This flag must be set in order to perform texture gather operations
 on a CUDA array.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CUDA_ARRAY3D_TEXTURE_GATHER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_PARAM_TR_DEFAULT"><!-- --></A><H3>
CU_PARAM_TR_DEFAULT</H3>
<PRE>
public static final int <B>CU_PARAM_TR_DEFAULT</B></PRE>
<DL>
<DD>For texture references loaded into the module, use default
 texunit from texture reference
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_PARAM_TR_DEFAULT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_TRSA_OVERRIDE_FORMAT"><!-- --></A><H3>
CU_TRSA_OVERRIDE_FORMAT</H3>
<PRE>
public static final int <B>CU_TRSA_OVERRIDE_FORMAT</B></PRE>
<DL>
<DD>Override the texref format with a format inferred from the array
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_TRSA_OVERRIDE_FORMAT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_TRSF_READ_AS_INTEGER"><!-- --></A><H3>
CU_TRSF_READ_AS_INTEGER</H3>
<PRE>
public static final int <B>CU_TRSF_READ_AS_INTEGER</B></PRE>
<DL>
<DD>Read the texture as integers rather than promoting the values
 to floats in the range [0,1]
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_TRSF_READ_AS_INTEGER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_TRSF_NORMALIZED_COORDINATES"><!-- --></A><H3>
CU_TRSF_NORMALIZED_COORDINATES</H3>
<PRE>
public static final int <B>CU_TRSF_NORMALIZED_COORDINATES</B></PRE>
<DL>
<DD>Use normalized texture coordinates in the range [0,1) instead of [0,dim)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_TRSF_NORMALIZED_COORDINATES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_TRSF_SRGB"><!-- --></A><H3>
CU_TRSF_SRGB</H3>
<PRE>
public static final int <B>CU_TRSF_SRGB</B></PRE>
<DL>
<DD>Perform sRGB->linear conversion during texture read.
 Flag for JCudaDriver#cuTexRefSetFlags()
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_TRSF_SRGB">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_STREAM_CALLBACK_NONBLOCKING"><!-- --></A><H3>
CU_STREAM_CALLBACK_NONBLOCKING</H3>
<PRE>
public static final int <B>CU_STREAM_CALLBACK_NONBLOCKING</B></PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>This flag was only present in CUDA 5.0.25 (release candidate) 
 and may be removed (or added again) in future releases</I><DD>Specifies a stream callback does not block the stream while
 executing.  This is the default behavior.
 Flag for <A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamAddCallback(jcuda.driver.CUstream, jcuda.driver.CUstreamCallback, java.lang.Object, int)"><CODE>cuStreamAddCallback(CUstream, CUstreamCallback, Object, int)</CODE></A>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_STREAM_CALLBACK_NONBLOCKING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_STREAM_CALLBACK_BLOCKING"><!-- --></A><H3>
CU_STREAM_CALLBACK_BLOCKING</H3>
<PRE>
public static final int <B>CU_STREAM_CALLBACK_BLOCKING</B></PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>This flag was only present in CUDA 5.0.25 (release candidate) 
 and may be removed (or added again) in future releases</I><DD>If set, the stream callback blocks the stream until it is
 done executing.
 Flag for <A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamAddCallback(jcuda.driver.CUstream, jcuda.driver.CUstreamCallback, java.lang.Object, int)"><CODE>cuStreamAddCallback(CUstream, CUstreamCallback, Object, int)</CODE></A>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_STREAM_CALLBACK_BLOCKING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_LAUNCH_PARAM_END"><!-- --></A><H3>
CU_LAUNCH_PARAM_END</H3>
<PRE>
public static final <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A> <B>CU_LAUNCH_PARAM_END</B></PRE>
<DL>
<DD>End of array terminator for the \p extra parameter to
 ::cuLaunchKernel
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="CU_LAUNCH_PARAM_BUFFER_POINTER"><!-- --></A><H3>
CU_LAUNCH_PARAM_BUFFER_POINTER</H3>
<PRE>
public static final <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A> <B>CU_LAUNCH_PARAM_BUFFER_POINTER</B></PRE>
<DL>
<DD>Indicator that the next value in the \p extra parameter to
 ::cuLaunchKernel will be a pointer to a buffer containing all kernel
 parameters used for launching kernel \p f.  This buffer needs to
 honor all alignment/padding requirements of the individual parameters.
 If ::CU_LAUNCH_PARAM_BUFFER_SIZE is not also specified in the
 \p extra array, then ::CU_LAUNCH_PARAM_BUFFER_POINTER will have no
 effect.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="CU_LAUNCH_PARAM_BUFFER_SIZE"><!-- --></A><H3>
CU_LAUNCH_PARAM_BUFFER_SIZE</H3>
<PRE>
public static final <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A> <B>CU_LAUNCH_PARAM_BUFFER_SIZE</B></PRE>
<DL>
<DD>Indicator that the next value in the \p extra parameter to
 ::cuLaunchKernel will be a pointer to a size_t which contains the
 size of the buffer specified with ::CU_LAUNCH_PARAM_BUFFER_POINTER.
 It is required that ::CU_LAUNCH_PARAM_BUFFER_POINTER also be specified
 in the \p extra array if the value associated with
 ::CU_LAUNCH_PARAM_BUFFER_SIZE is not zero.
<P>
<DL>
</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="setLogLevel(jcuda.LogLevel)"><!-- --></A><H3>
setLogLevel</H3>
<PRE>
public static void <B>setLogLevel</B>(<A HREF="../../jcuda/LogLevel.html" title="enum in jcuda">LogLevel</A>&nbsp;logLevel)</PRE>
<DL>
<DD>Set the specified log level for the JCuda driver library.<br />
 <br />
 Currently supported log levels:
 <br />
 LOG_QUIET: Never print anything <br />
 LOG_ERROR: Print error messages <br />
 LOG_TRACE: Print a trace of all native function calls <br />
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>logLevel</CODE> - The log level to use.</DL>
</DD>
</DL>
<HR>

<A NAME="setExceptionsEnabled(boolean)"><!-- --></A><H3>
setExceptionsEnabled</H3>
<PRE>
public static void <B>setExceptionsEnabled</B>(boolean&nbsp;enabled)</PRE>
<DL>
<DD>Enables or disables exceptions. By default, the methods of this class
 only return the CUresult error code from the underlying CUDA function.
 If exceptions are enabled, a CudaException with a detailed error
 message will be thrown if a method is about to return a result code
 that is not CUresult.CUDA_SUCCESS
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enabled</CODE> - Whether exceptions are enabled</DL>
</DD>
</DL>
<HR>

<A NAME="align(int, int)"><!-- --></A><H3>
align</H3>
<PRE>
public static int <B>align</B>(int&nbsp;value,
                        int&nbsp;alignment)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>This method was intended for a simpler
 kernel parameter setup in earlier CUDA versions,
 and should not be required any more. It may be
 removed in future releases.</I>
<P>
<DD>Returns the given (address) value, adjusted to have
 the given alignment. This function may be used to
 align the parameters for a kernel call according
 to their alignment requirements.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - The address value<DD><CODE>alignment</CODE> - The desired alignment
<DT><B>Returns:</B><DD>The aligned address value</DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleLoadDataJIT(jcuda.driver.CUmodule, jcuda.Pointer, jcuda.driver.JITOptions)"><!-- --></A><H3>
cuModuleLoadDataJIT</H3>
<PRE>
public static int <B>cuModuleLoadDataJIT</B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;module,
                                      <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pointer,
                                      <A HREF="../../jcuda/driver/JITOptions.html" title="class in jcuda.driver">JITOptions</A>&nbsp;jitOptions)</PRE>
<DL>
<DD>A wrapper function for 
 <A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)"><CODE>cuModuleLoadDataEx(CUmodule, Pointer, int, int[], Pointer)</CODE></A>
 which allows passing in the options for the JIT compiler, and obtaining
 the output of the JIT compiler via a <A HREF="../../jcuda/driver/JITOptions.html" title="class in jcuda.driver"><CODE>JITOptions</CODE></A> object. <br />
 <br />
 <u>Note:</u> This method should be considered as preliminary,
 and might change in future releases.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cuInit(int)"><!-- --></A><H3>
cuInit</H3>
<PRE>
public static int <B>cuInit</B>(int&nbsp;Flags)</PRE>
<DL>
<DD>Initialize the CUDA driver API.
 
 <pre>
 CUresult cuInit (
      unsigned int  Flags )
 </pre>
 <div>
   <p>Initialize the CUDA driver API. 
     Initializes the driver API and must be called before any other function
     from the driver API.
     Currently, the <tt>Flags</tt> parameter
     must be 0. If cuInit() has not been called, any function from the
     driver API will return CUDA_ERROR_NOT_INITIALIZED.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches. 
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>Flags</CODE> - Initialization flag for CUDA.
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_INVALID_DEVICE</DL>
</DD>
</DL>
<HR>

<A NAME="cuDeviceGet(jcuda.driver.CUdevice, int)"><!-- --></A><H3>
cuDeviceGet</H3>
<PRE>
public static int <B>cuDeviceGet</B>(<A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;device,
                              int&nbsp;ordinal)</PRE>
<DL>
<DD>Returns a handle to a compute device.
 
 <pre>
 CUresult cuDeviceGet (
      CUdevice* device,
      int  ordinal )
 </pre>
 <div>
   <p>Returns a handle to a compute device. 
     Returns in <tt>*device</tt> a device handle given an ordinal in the
     range <strong>[0, cuDeviceGetCount()-1]</strong>.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>device</CODE> - Returned device handle<DD><CODE>ordinal</CODE> - Device number to get handle for
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_INVALID_DEVICE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetCount(int[])"><CODE>cuDeviceGetCount(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceTotalMem(long[], jcuda.driver.CUdevice)"><CODE>cuDeviceTotalMem(long[], jcuda.driver.CUdevice)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuDeviceGetCount(int[])"><!-- --></A><H3>
cuDeviceGetCount</H3>
<PRE>
public static int <B>cuDeviceGetCount</B>(int[]&nbsp;count)</PRE>
<DL>
<DD>Returns the number of compute-capable devices.
 
 <pre>
 CUresult cuDeviceGetCount (
      int* count )
 </pre>
 <div>
   <p>Returns the number of compute-capable
     devices.  Returns in <tt>*count</tt> the number of devices with
     compute capability greater than or equal to 1.0 that are available for
     execution. If there is
     no such device, cuDeviceGetCount()
     returns 0.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - Returned number of compute-capable devices
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGet(jcuda.driver.CUdevice, int)"><CODE>cuDeviceGet(jcuda.driver.CUdevice, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceTotalMem(long[], jcuda.driver.CUdevice)"><CODE>cuDeviceTotalMem(long[], jcuda.driver.CUdevice)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)"><!-- --></A><H3>
cuDeviceGetName</H3>
<PRE>
public static int <B>cuDeviceGetName</B>(byte[]&nbsp;name,
                                  int&nbsp;len,
                                  <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</PRE>
<DL>
<DD>Returns an identifer string for the device.
 
 <pre>
 CUresult cuDeviceGetName (
      char* name,
      int  len,
      CUdevice dev )
 </pre>
 <div>
   <p>Returns an identifer string for the
     device.  Returns an ASCII string identifying the device <tt>dev</tt>
     in the NULL-terminated string pointed to by <tt>name</tt>. <tt>len</tt> specifies the maximum length of the string that may be
     returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - Returned identifier string for the device<DD><CODE>len</CODE> - Maximum length of string to store in name<DD><CODE>dev</CODE> - Device to get identifier string for
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_INVALID_DEVICE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetCount(int[])"><CODE>cuDeviceGetCount(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGet(jcuda.driver.CUdevice, int)"><CODE>cuDeviceGet(jcuda.driver.CUdevice, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceTotalMem(long[], jcuda.driver.CUdevice)"><CODE>cuDeviceTotalMem(long[], jcuda.driver.CUdevice)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuDeviceComputeCapability(int[], int[], jcuda.driver.CUdevice)"><!-- --></A><H3>
cuDeviceComputeCapability</H3>
<PRE>
public static int <B>cuDeviceComputeCapability</B>(int[]&nbsp;major,
                                            int[]&nbsp;minor,
                                            <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</PRE>
<DL>
<DD>Returns the compute capability of the device.
 
 <pre>
 CUresult cuDeviceComputeCapability (
      int* major,
      int* minor,
      CUdevice dev )
 </pre>
 <div>
   <p>Returns the compute capability of the
     device.  
     DeprecatedThis function was deprecated
     as of CUDA 5.0 and its functionality superceded by
     cuDeviceGetAttribute().
   </p>
   <p>Returns in <tt>*major</tt> and <tt>*minor</tt> the major and minor revision numbers that define the
     compute capability of the device <tt>dev</tt>.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>major</CODE> - Major revision number<DD><CODE>minor</CODE> - Minor revision number<DD><CODE>dev</CODE> - Device handle
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_INVALID_DEVICE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetCount(int[])"><CODE>cuDeviceGetCount(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGet(jcuda.driver.CUdevice, int)"><CODE>cuDeviceGet(jcuda.driver.CUdevice, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceTotalMem(long[], jcuda.driver.CUdevice)"><CODE>cuDeviceTotalMem(long[], jcuda.driver.CUdevice)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuDeviceTotalMem(long[], jcuda.driver.CUdevice)"><!-- --></A><H3>
cuDeviceTotalMem</H3>
<PRE>
public static int <B>cuDeviceTotalMem</B>(long[]&nbsp;bytes,
                                   <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</PRE>
<DL>
<DD>Returns the total amount of memory on the device.
 
 <pre>
 CUresult cuDeviceTotalMem (
      size_t* bytes,
      CUdevice dev )
 </pre>
 <div>
   <p>Returns the total amount of memory on
     the device.  Returns in <tt>*bytes</tt> the total amount of memory
     available on the device <tt>dev</tt> in bytes.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bytes</CODE> - Returned memory available on device in bytes<DD><CODE>dev</CODE> - Device handle
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_INVALID_DEVICE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetCount(int[])"><CODE>cuDeviceGetCount(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGet(jcuda.driver.CUdevice, int)"><CODE>cuDeviceGet(jcuda.driver.CUdevice, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuDeviceGetProperties(jcuda.driver.CUdevprop, jcuda.driver.CUdevice)"><!-- --></A><H3>
cuDeviceGetProperties</H3>
<PRE>
public static int <B>cuDeviceGetProperties</B>(<A HREF="../../jcuda/driver/CUdevprop.html" title="class in jcuda.driver">CUdevprop</A>&nbsp;prop,
                                        <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</PRE>
<DL>
<DD>Returns properties for a selected device.
 
 <pre>
 CUresult cuDeviceGetProperties (
      CUdevprop* prop,
      CUdevice dev )
 </pre>
 <div>
   <p>Returns properties for a selected device.
     DeprecatedThis function was deprecated
     as of CUDA 5.0 and replaced by cuDeviceGetAttribute().
   </p>
   <p>Returns in <tt>*prop</tt> the properties
     of device <tt>dev</tt>. The CUdevprop structure is defined as:
   </p>
   <pre>     typedef struct CUdevprop_st {
      int maxThreadsPerBlock;
      int maxThreadsDim[3];
      int maxGridSize[3];
      int sharedMemPerBlock;
      int totalConstantMemory;
      int SIMDWidth;
      int memPitch;
      int regsPerBlock;
      int clockRate;
      int textureAlign
   } CUdevprop;</pre>
   where:</p>
   <ul>
     <li>
       <p>maxThreadsPerBlock is the
         maximum number of threads per block;
       </p>
     </li>
     <li>
       <p>maxThreadsDim[3] is the maximum
         sizes of each dimension of a block;
       </p>
     </li>
     <li>
       <p>maxGridSize[3] is the maximum
         sizes of each dimension of a grid;
       </p>
     </li>
     <li>
       <p>sharedMemPerBlock is the total
         amount of shared memory available per block in bytes;
       </p>
     </li>
     <li>
       <p>totalConstantMemory is the
         total amount of constant memory available on the device in bytes;
       </p>
     </li>
     <li>
       <p>SIMDWidth is the warp
         size;
       </p>
     </li>
     <li>
       <p>memPitch is the maximum pitch
         allowed by the memory copy functions that involve memory regions
         allocated through cuMemAllocPitch();
       </p>
     </li>
     <li>
       <p>regsPerBlock is the total
         number of registers available per block;
       </p>
     </li>
     <li>
       <p>clockRate is the clock frequency
         in kilohertz;
       </p>
     </li>
     <li>
       <p>textureAlign is the alignment
         requirement; texture base addresses that are aligned to textureAlign
         bytes do not need an offset
         applied to texture fetches.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>prop</CODE> - Returned properties of device<DD><CODE>dev</CODE> - Device to get properties for
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_INVALID_DEVICE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetCount(int[])"><CODE>cuDeviceGetCount(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGet(jcuda.driver.CUdevice, int)"><CODE>cuDeviceGet(jcuda.driver.CUdevice, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceTotalMem(long[], jcuda.driver.CUdevice)"><CODE>cuDeviceTotalMem(long[], jcuda.driver.CUdevice)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)"><!-- --></A><H3>
cuDeviceGetAttribute</H3>
<PRE>
public static int <B>cuDeviceGetAttribute</B>(int[]&nbsp;pi,
                                       int&nbsp;attrib,
                                       <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</PRE>
<DL>
<DD>Returns information about the device.
 
 <pre>
 CUresult cuDeviceGetAttribute (
      int* pi,
      CUdevice_attribute attrib,
      CUdevice dev )
 </pre>
 <div>
   <p>Returns information about the device. 
     Returns in <tt>*pi</tt> the integer value of the attribute <tt>attrib</tt> on device <tt>dev</tt>. The supported attributes are:
   <ul>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK: Maximum number of threads
         per block;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X:
         Maximum x-dimension of a block;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y:
         Maximum y-dimension of a block;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z:
         Maximum z-dimension of a block;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X:
         Maximum x-dimension of a grid;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y:
         Maximum y-dimension of a grid;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z:
         Maximum z-dimension of a grid;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK: Maximum amount of
         shared memory available to a thread block in bytes; this amount is
         shared by all thread blocks simultaneously
         resident on a multiprocessor;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY: Memory available on device
         for __constant__ variables in a CUDA C kernel in bytes;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_WARP_SIZE:
         Warp size in threads;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAX_PITCH:
         Maximum pitch in bytes allowed by the memory copy functions that
         involve memory regions allocated through cuMemAllocPitch();
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH: Maximum 1D texture
         width;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH: Maximum width for
         a 1D texture bound to linear memory;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH: Maximum
         mipmapped 1D texture width;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH: Maximum 2D texture
         width;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT: Maximum 2D texture
         height;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH: Maximum width for
         a 2D texture bound to linear memory;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT: Maximum height
         for a 2D texture bound to linear memory;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH: Maximum pitch in
         bytes for a 2D texture bound to linear memory;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH: Maximum
         mipmapped 2D texture width;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT: Maximum
         mipmapped 2D texture height;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH: Maximum 3D texture
         width;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT: Maximum 3D texture
         height;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH: Maximum 3D texture
         depth;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE: Alternate
         maximum 3D texture width, 0 if no alternate maximum 3D texture size is
         supported;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE: Alternate
         maximum 3D texture height, 0 if no alternate maximum 3D texture size
         is supported;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE: Alternate
         maximum 3D texture depth, 0 if no alternate maximum 3D texture size is
         supported;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH: Maximum cubemap
         texture width or height;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH: Maximum 1D
         layered texture width;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS: Maximum layers
         in a 1D layered texture;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH: Maximum 2D
         layered texture width;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT: Maximum 2D
         layered texture height;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS: Maximum layers
         in a 2D layered texture;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH: Maximum
         cubemap layered texture width or height;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS: Maximum
         layers in a cubemap layered texture;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH: Maximum 1D surface
         width;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH: Maximum 2D surface
         width;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT: Maximum 2D surface
         height;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH: Maximum 3D surface
         width;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT: Maximum 3D surface
         height;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH: Maximum 3D surface
         depth;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH: Maximum 1D
         layered surface width;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS: Maximum layers
         in a 1D layered surface;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH: Maximum 2D
         layered surface width;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT: Maximum 2D
         layered surface height;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS: Maximum layers
         in a 2D layered surface;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH: Maximum cubemap
         surface width;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH: Maximum
         cubemap layered surface width;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS: Maximum
         layers in a cubemap layered surface;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK: Maximum number of 32-bit
         registers available to a thread block; this number is shared by all
         thread blocks simultaneously
         resident on a multiprocessor;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_CLOCK_RATE:
         Peak clock frequency in kilohertz;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT:
         Alignment requirement; texture base addresses aligned to textureAlign
         bytes do not need an offset applied to texture fetches;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT: Pitch alignment
         requirement for 2D texture references bound to pitched memory;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_GPU_OVERLAP:
         1 if the device can concurrently copy memory between host and device
         while executing a kernel, or 0 if not;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT: Number of multiprocessors
         on the device;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT:
         1 if there is a run time limit for kernels executed on the device, or
         0 if not;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_INTEGRATED:
         1 if the device is integrated with the memory subsystem, or 0 if not;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY:
         1 if the device can map host memory into the CUDA address space, or 0
         if not;
       </p>
     </li>
     <li>
       <div>
         CU_DEVICE_ATTRIBUTE_COMPUTE_MODE:
         Compute mode that device is currently in. Available modes are as
         follows:
         <ul>
           <li>
             <p>CU_COMPUTEMODE_DEFAULT:
               Default mode - Device is not restricted and can have multiple CUDA
               contexts present at a single time.
             </p>
           </li>
           <li>
             <p>CU_COMPUTEMODE_EXCLUSIVE:
               Compute-exclusive mode - Device can have only one CUDA context present
               on it at a time.
             </p>
           </li>
           <li>
             <p>CU_COMPUTEMODE_PROHIBITED:
               Compute-prohibited mode - Device is prohibited from creating new CUDA
               contexts.
             </p>
           </li>
           <li>
             <p>CU_COMPUTEMODE_EXCLUSIVE_PROCESS: Compute-exclusive-process mode -
               Device can have only one context used by a single process at a time.
             </p>
           </li>
         </ul>
       </div>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS:
         1 if the device supports executing multiple kernels within the same
         context simultaneously, or 0 if not. It is not guaranteed
         that multiple kernels will be
         resident on the device concurrently so this feature should not be
         relied upon for correctness;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_ECC_ENABLED:
         1 if error correction is enabled on the device, 0 if error correction
         is disabled or not supported by the device;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_PCI_BUS_ID:
         PCI bus identifier of the device;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID:
         PCI device (also known as slot) identifier of the device;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_TCC_DRIVER:
         1 if the device is using a TCC driver. TCC is only available on Tesla
         hardware running Windows Vista or later;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE:
         Peak memory clock frequency in kilohertz;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH: Global memory bus width
         in bits;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE:
         Size of L2 cache in bytes. 0 if the device doesn't have L2 cache;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR: Maximum resident
         threads per multiprocessor;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING:
         1 if the device shares a unified address space with the host, or 0 if
         not;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR: Major compute capability
         version number;
       </p>
     </li>
     <li>
       <p>CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR: Minor compute capability
         version number;
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pi</CODE> - Returned device attribute value<DD><CODE>attrib</CODE> - Device attribute to query<DD><CODE>dev</CODE> - Device handle
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_INVALID_DEVICE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetCount(int[])"><CODE>cuDeviceGetCount(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGet(jcuda.driver.CUdevice, int)"><CODE>cuDeviceGet(jcuda.driver.CUdevice, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceTotalMem(long[], jcuda.driver.CUdevice)"><CODE>cuDeviceTotalMem(long[], jcuda.driver.CUdevice)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuDriverGetVersion(int[])"><!-- --></A><H3>
cuDriverGetVersion</H3>
<PRE>
public static int <B>cuDriverGetVersion</B>(int[]&nbsp;driverVersion)</PRE>
<DL>
<DD>Returns the CUDA driver version.
 
 <pre>
 CUresult cuDriverGetVersion (
      int* driverVersion )
 </pre>
 <div>
   <p>Returns the CUDA driver version.  Returns
     in <tt>*driverVersion</tt> the version number of the installed CUDA
     driver. This function automatically returns CUDA_ERROR_INVALID_VALUE
     if the <tt>driverVersion</tt> argument is NULL.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches. 
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>driverVersion</CODE> - Returns the CUDA driver version
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_VALUE</DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><!-- --></A><H3>
cuCtxCreate</H3>
<PRE>
public static int <B>cuCtxCreate</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pctx,
                              int&nbsp;flags,
                              <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</PRE>
<DL>
<DD>Create a CUDA context.
 
 <pre>
 CUresult cuCtxCreate (
      CUcontext* pctx,
      unsigned int  flags,
      CUdevice dev )
 </pre>
 <div>
   <p>Create a CUDA context.  Creates a new
     CUDA context and associates it with the calling thread. The <tt>flags</tt> parameter is described below. The context is created with
     a usage count of 1 and the caller of cuCtxCreate() must call
     cuCtxDestroy() or when done using the context. If a context is already
     current to the thread, it is supplanted by the newly created context
     and may be restored by a subsequent call
     to cuCtxPopCurrent().
   </p>
   <p>The three LSBs of the <tt>flags</tt>
     parameter can be used to control how the OS thread, which owns the CUDA
     context at the time of an API call, interacts with
     the OS scheduler when waiting for results
     from the GPU. Only one of the scheduling flags can be set when creating
     a context.
   </p>
   <ul>
     <li>
       <p>CU_CTX_SCHED_AUTO: The default
         value if the <tt>flags</tt> parameter is zero, uses a heuristic based
         on the number of active CUDA contexts in the process C and the number
         of logical
         processors in the system P. If
         C &gt; P, then CUDA will yield to other OS threads when waiting for
         the GPU, otherwise CUDA will
         not yield while waiting for
         results and actively spin on the processor.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CU_CTX_SCHED_SPIN: Instruct
         CUDA to actively spin when waiting for results from the GPU. This can
         decrease latency when waiting for the GPU,
         but may lower the performance
         of CPU threads if they are performing work in parallel with the CUDA
         thread.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CU_CTX_SCHED_YIELD: Instruct
         CUDA to yield its thread when waiting for results from the GPU. This
         can increase latency when waiting for the
         GPU, but can increase the
         performance of CPU threads performing work in parallel with the GPU.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CU_CTX_SCHED_BLOCKING_SYNC:
         Instruct CUDA to block the CPU thread on a synchronization primitive
         when waiting for the GPU to finish work.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CU_CTX_BLOCKING_SYNC: Instruct
         CUDA to block the CPU thread on a synchronization primitive when
         waiting for the GPU to finish work. 
       </p>
       <p><strong>Deprecated:</strong>
         This flag was deprecated as of CUDA 4.0 and was replaced with
         CU_CTX_SCHED_BLOCKING_SYNC.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CU_CTX_MAP_HOST: Instruct CUDA
         to support mapped pinned allocations. This flag must be set in order
         to allocate pinned host memory that is
         accessible to the GPU.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CU_CTX_LMEM_RESIZE_TO_MAX:
         Instruct CUDA to not reduce local memory after resizing local memory
         for a kernel. This can prevent thrashing by local memory
         allocations when launching many
         kernels with high local memory usage at the cost of potentially
         increased memory usage.
       </p>
     </li>
   </ul>
   </p>
   <p>Context creation will fail with
     CUDA_ERROR_UNKNOWN if the compute mode of the device is
     CU_COMPUTEMODE_PROHIBITED. Similarly, context creation will also fail
     with CUDA_ERROR_UNKNOWN if the compute mode for the device is set to
     CU_COMPUTEMODE_EXCLUSIVE and there is already an active context on the
     device. The function cuDeviceGetAttribute() can be used with
     CU_DEVICE_ATTRIBUTE_COMPUTE_MODE to determine the compute mode of the
     device. The nvidia-smi tool can be used to set the compute mode for
     devices. Documentation
     for nvidia-smi can be obtained by passing
     a -h option to it.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pctx</CODE> - Returned context handle of the new context<DD><CODE>flags</CODE> - Context creation flags<DD><CODE>dev</CODE> - Device to create context on
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_DEVICE,
 CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_OUT_OF_MEMORY, CUDA_ERROR_UNKNOWN<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])"><CODE>cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])"><CODE>cuCtxGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)"><CODE>cuCtxGetDevice(jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetLimit(long[], int)"><CODE>cuCtxGetLimit(long[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPushCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCacheConfig(int)"><CODE>cuCtxSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetLimit(int, long)"><CODE>cuCtxSetLimit(int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()"><CODE>cuCtxSynchronize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxDestroy(jcuda.driver.CUcontext)"><!-- --></A><H3>
cuCtxDestroy</H3>
<PRE>
public static int <B>cuCtxDestroy</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;ctx)</PRE>
<DL>
<DD>Destroy a CUDA context.
 
 <pre>
 CUresult cuCtxDestroy (
      CUcontext ctx )
 </pre>
 <div>
   <p>Destroy a CUDA context.  Destroys the
     CUDA context specified by <tt>ctx</tt>. The context <tt>ctx</tt> will
     be destroyed regardless of how many threads it is current to. It is
     the responsibility of the calling function to ensure
     that no API call issues using <tt>ctx</tt> while cuCtxDestroy() is executing.
   </p>
   <p>If <tt>ctx</tt> is current to the
     calling thread then <tt>ctx</tt> will also be popped from the current
     thread's context stack (as though cuCtxPopCurrent() were called). If
     <tt>ctx</tt> is current to other threads, then <tt>ctx</tt> will
     remain current to those threads, and attempting to access <tt>ctx</tt>
     from those threads will result in the error
     CUDA_ERROR_CONTEXT_IS_DESTROYED.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ctx</CODE> - Context to destroy
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])"><CODE>cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])"><CODE>cuCtxGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)"><CODE>cuCtxGetDevice(jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetLimit(long[], int)"><CODE>cuCtxGetLimit(long[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPushCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCacheConfig(int)"><CODE>cuCtxSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetLimit(int, long)"><CODE>cuCtxSetLimit(int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()"><CODE>cuCtxSynchronize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxAttach(jcuda.driver.CUcontext, int)"><!-- --></A><H3>
cuCtxAttach</H3>
<PRE>
public static int <B>cuCtxAttach</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pctx,
                              int&nbsp;flags)</PRE>
<DL>
<DD>Increment a context's usage-count.
 
 <pre>
 CUresult cuCtxAttach (
      CUcontext* pctx,
      unsigned int  flags )
 </pre>
 <div>
   <p>Increment a context's usage-count.  
     DeprecatedNote that this function is
     deprecated and should not be used.
   </p>
   <p>Increments the usage count of the
     context and passes back a context handle in <tt>*pctx</tt> that must
     be passed to cuCtxDetach() when the application is done with the
     context. cuCtxAttach() fails if there is no context current to the
     thread.
   </p>
   <p>Currently, the <tt>flags</tt> parameter
     must be 0.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pctx</CODE> - Returned context handle of the current context<DD><CODE>flags</CODE> - Context attach flags (must be 0)
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDetach(jcuda.driver.CUcontext)"><CODE>cuCtxDetach(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])"><CODE>cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])"><CODE>cuCtxGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)"><CODE>cuCtxGetDevice(jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetLimit(long[], int)"><CODE>cuCtxGetLimit(long[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPushCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCacheConfig(int)"><CODE>cuCtxSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetLimit(int, long)"><CODE>cuCtxSetLimit(int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()"><CODE>cuCtxSynchronize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxDetach(jcuda.driver.CUcontext)"><!-- --></A><H3>
cuCtxDetach</H3>
<PRE>
public static int <B>cuCtxDetach</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;ctx)</PRE>
<DL>
<DD>Decrement a context's usage-count.
 
 <pre>
 CUresult cuCtxDetach (
      CUcontext ctx )
 </pre>
 <div>
   <p>Decrement a context's usage-count.  
     DeprecatedNote that this function is
     deprecated and should not be used.
   </p>
   <p>Decrements the usage count of the
     context <tt>ctx</tt>, and destroys the context if the usage count goes
     to 0. The context must be a handle that was passed back by cuCtxCreate()
     or cuCtxAttach(), and must be current to the calling thread.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ctx</CODE> - Context to destroy
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])"><CODE>cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])"><CODE>cuCtxGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)"><CODE>cuCtxGetDevice(jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetLimit(long[], int)"><CODE>cuCtxGetLimit(long[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPushCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCacheConfig(int)"><CODE>cuCtxSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetLimit(int, long)"><CODE>cuCtxSetLimit(int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()"><CODE>cuCtxSynchronize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxPushCurrent(jcuda.driver.CUcontext)"><!-- --></A><H3>
cuCtxPushCurrent</H3>
<PRE>
public static int <B>cuCtxPushCurrent</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;ctx)</PRE>
<DL>
<DD>Pushes a context on the current CPU thread.
 
 <pre>
 CUresult cuCtxPushCurrent (
      CUcontext ctx )
 </pre>
 <div>
   <p>Pushes a context on the current CPU
     thread.  Pushes the given context <tt>ctx</tt> onto the CPU thread's
     stack of current contexts. The specified context becomes the CPU
     thread's current context, so all CUDA
     functions that operate on the current
     context are affected.
   </p>
   <p>The previous current context may be made
     current again by calling cuCtxDestroy() or cuCtxPopCurrent().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ctx</CODE> - Context to push
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])"><CODE>cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])"><CODE>cuCtxGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)"><CODE>cuCtxGetDevice(jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetLimit(long[], int)"><CODE>cuCtxGetLimit(long[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCacheConfig(int)"><CODE>cuCtxSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetLimit(int, long)"><CODE>cuCtxSetLimit(int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()"><CODE>cuCtxSynchronize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxPopCurrent(jcuda.driver.CUcontext)"><!-- --></A><H3>
cuCtxPopCurrent</H3>
<PRE>
public static int <B>cuCtxPopCurrent</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pctx)</PRE>
<DL>
<DD>Pops the current CUDA context from the current CPU thread.
 
 <pre>
 CUresult cuCtxPopCurrent (
      CUcontext* pctx )
 </pre>
 <div>
   <p>Pops the current CUDA context from the
     current CPU thread.  Pops the current CUDA context from the CPU thread
     and passes back
     the old context handle in <tt>*pctx</tt>.
     That context may then be made current to a different CPU thread by
     calling cuCtxPushCurrent().
   </p>
   <p>If a context was current to the CPU
     thread before cuCtxCreate() or cuCtxPushCurrent() was called, this
     function makes that context current to the CPU thread again.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pctx</CODE> - Returned new context handle
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])"><CODE>cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])"><CODE>cuCtxGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)"><CODE>cuCtxGetDevice(jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetLimit(long[], int)"><CODE>cuCtxGetLimit(long[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPushCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCacheConfig(int)"><CODE>cuCtxSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetLimit(int, long)"><CODE>cuCtxSetLimit(int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()"><CODE>cuCtxSynchronize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxSetCurrent(jcuda.driver.CUcontext)"><!-- --></A><H3>
cuCtxSetCurrent</H3>
<PRE>
public static int <B>cuCtxSetCurrent</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;ctx)</PRE>
<DL>
<DD>Binds the specified CUDA context to the calling CPU thread.
 
 <pre>
 CUresult cuCtxSetCurrent (
      CUcontext ctx )
 </pre>
 <div>
   <p>Binds the specified CUDA context to the
     calling CPU thread.  Binds the specified CUDA context to the calling
     CPU thread. If
     <tt>ctx</tt> is NULL then the CUDA
     context previously bound to the calling CPU thread is unbound and
     CUDA_SUCCESS is returned.
   </p>
   <p>If there exists a CUDA context stack on
     the calling CPU thread, this will replace the top of that stack with
     <tt>ctx</tt>. If <tt>ctx</tt> is NULL then this will be equivalent
     to popping the top of the calling CPU thread's CUDA context stack (or
     a no-op if the
     calling CPU thread's CUDA context stack
     is empty).
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ctx</CODE> - Context to bind to the calling CPU thread
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxGetCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxGetCurrent(jcuda.driver.CUcontext)"><!-- --></A><H3>
cuCtxGetCurrent</H3>
<PRE>
public static int <B>cuCtxGetCurrent</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pctx)</PRE>
<DL>
<DD>Returns the CUDA context bound to the calling CPU thread.
 
 <pre>
 CUresult cuCtxGetCurrent (
      CUcontext* pctx )
 </pre>
 <div>
   <p>Returns the CUDA context bound to the
     calling CPU thread.  Returns in <tt>*pctx</tt> the CUDA context bound
     to the calling CPU thread. If no context is bound to the calling CPU
     thread then <tt>*pctx</tt> is set to NULL and CUDA_SUCCESS is
     returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pctx</CODE> - Returned context handle
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED,
 CUDA_ERROR_NOT_INITIALIZED,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxSetCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxGetDevice(jcuda.driver.CUdevice)"><!-- --></A><H3>
cuCtxGetDevice</H3>
<PRE>
public static int <B>cuCtxGetDevice</B>(<A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;device)</PRE>
<DL>
<DD>Returns the device ID for the current context.
 
 <pre>
 CUresult cuCtxGetDevice (
      CUdevice* device )
 </pre>
 <div>
   <p>Returns the device ID for the current
     context.  Returns in <tt>*device</tt> the ordinal of the current
     context's device.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>device</CODE> - Returned device ID for the current context
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])"><CODE>cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])"><CODE>cuCtxGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetLimit(long[], int)"><CODE>cuCtxGetLimit(long[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPushCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCacheConfig(int)"><CODE>cuCtxSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetLimit(int, long)"><CODE>cuCtxSetLimit(int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()"><CODE>cuCtxSynchronize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxSynchronize()"><!-- --></A><H3>
cuCtxSynchronize</H3>
<PRE>
public static int <B>cuCtxSynchronize</B>()</PRE>
<DL>
<DD>Block for a context's tasks to complete.
 
 <pre>
 CUresult cuCtxSynchronize (
      void )
 </pre>
 <div>
   <p>Block for a context's tasks to complete.
     Blocks until the device has completed all preceding requested tasks.
     cuCtxSynchronize() returns an error if one of the preceding tasks
     failed. If the context was created with the CU_CTX_SCHED_BLOCKING_SYNC
     flag, the CPU thread will block until the GPU context has finished its
     work.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])"><CODE>cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])"><CODE>cuCtxGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)"><CODE>cuCtxGetDevice(jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetLimit(long[], int)"><CODE>cuCtxGetLimit(long[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<CODE>JCudaDriver#cuCtxPushCurrentcuCtxSetCacheConfig</CODE>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetLimit(int, long)"><CODE>cuCtxSetLimit(int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)"><!-- --></A><H3>
cuModuleLoad</H3>
<PRE>
public static int <B>cuModuleLoad</B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;module,
                               java.lang.String&nbsp;fname)</PRE>
<DL>
<DD>Loads a compute module.
 
 <pre>
 CUresult cuModuleLoad (
      CUmodule* module,
      const char* fname )
 </pre>
 <div>
   <p>Loads a compute module.  Takes a filename
     <tt>fname</tt> and loads the corresponding module <tt>module</tt>
     into the current context. The CUDA driver API does not attempt to
     lazily allocate the resources needed by a module; if the
     memory for functions and data (constant
     and global) needed by the module cannot be allocated, cuModuleLoad()
     fails. The file should be a cubin file as output by <strong>nvcc</strong>, or a PTX file either as output by <strong>nvcc</strong>
     or handwritten, or a fatbin file as output by <strong>nvcc</strong>
     from toolchain 4.0 or later.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>module</CODE> - Returned module<DD><CODE>fname</CODE> - Filename of module to load
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_NOT_FOUND,
 CUDA_ERROR_OUT_OF_MEMORY, CUDA_ERROR_FILE_NOT_FOUND,
 CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND,
 CUDA_ERROR_SHARED_OBJECT_INIT_FAILED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadData(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadData(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)"><CODE>cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleUnload(jcuda.driver.CUmodule)"><CODE>cuModuleUnload(jcuda.driver.CUmodule)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleLoadData(jcuda.driver.CUmodule, byte[])"><!-- --></A><H3>
cuModuleLoadData</H3>
<PRE>
public static int <B>cuModuleLoadData</B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;module,
                                   byte[]&nbsp;image)</PRE>
<DL>
<DD>Load a module's data.
 
 <pre>
 CUresult cuModuleLoadData (
      CUmodule* module,
      const void* image )
 </pre>
 <div>
   <p>Load a module's data.  Takes a pointer
     <tt>image</tt> and loads the corresponding module <tt>module</tt>
     into the current context. The pointer may be obtained by mapping a
     cubin or PTX or fatbin file, passing a cubin or PTX or
     fatbin file as a NULL-terminated text
     string, or incorporating a cubin or fatbin object into the executable
     resources and
     using operating system calls such as
     Windows <tt>FindResource()</tt> to obtain the pointer.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>module</CODE> - Returned module<DD><CODE>image</CODE> - Module data to load
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_OUT_OF_MEMORY, CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND,
 CUDA_ERROR_SHARED_OBJECT_INIT_FAILED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)"><CODE>cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleUnload(jcuda.driver.CUmodule)"><CODE>cuModuleUnload(jcuda.driver.CUmodule)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)"><!-- --></A><H3>
cuModuleLoadDataEx</H3>
<PRE>
public static int <B>cuModuleLoadDataEx</B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;phMod,
                                     <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p,
                                     int&nbsp;numOptions,
                                     int[]&nbsp;options,
                                     <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;optionValues)</PRE>
<DL>
<DD>Load a module's data with options.
 
 <pre>
 CUresult cuModuleLoadDataEx (
      CUmodule* module,
      const void* image,
      unsigned int  numOptions,
      CUjit_option* options,
      void** optionValues )
 </pre>
 <div>
   <p>Load a module's data with options.  Takes
     a pointer <tt>image</tt> and loads the corresponding module <tt>module</tt> into the current context. The pointer may be obtained by
     mapping a cubin or PTX or fatbin file, passing a cubin or PTX or
     fatbin file as a NULL-terminated text
     string, or incorporating a cubin or fatbin object into the executable
     resources and
     using operating system calls such as
     Windows <tt>FindResource()</tt> to obtain the pointer. Options are
     passed as an array via <tt>options</tt> and any corresponding
     parameters are passed in <tt>optionValues</tt>. The number of total
     options is supplied via <tt>numOptions</tt>. Any outputs will be
     returned via <tt>optionValues</tt>. Supported options are (types for
     the option values are specified in parentheses after the option name):
   </p>
   <ul>
     <li>
       <p>CU_JIT_MAX_REGISTERS: (unsigned
         int) input specifies the maximum number of registers per thread;
       </p>
     </li>
     <li>
       <p>CU_JIT_THREADS_PER_BLOCK:
         (unsigned int) input specifies number of threads per block to target
         compilation for; output returns the number of threads
         the compiler actually targeted;
       </p>
     </li>
     <li>
       <p>CU_JIT_WALL_TIME: (float)
         output returns the float value of wall clock time, in milliseconds,
         spent compiling the PTX code;
       </p>
     </li>
     <li>
       <p>CU_JIT_INFO_LOG_BUFFER: (char*)
         input is a pointer to a buffer in which to print any informational log
         messages from PTX assembly (the buffer size
         is specified via option
         CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES);
       </p>
     </li>
     <li>
       <p>CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES:
         (unsigned int) input is the size in bytes of the buffer; output is the
         number of bytes filled with messages;
       </p>
     </li>
     <li>
       <p>CU_JIT_ERROR_LOG_BUFFER:
         (char*) input is a pointer to a buffer in which to print any error log
         messages from PTX assembly (the buffer size is specified
         via option
         CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES);
       </p>
     </li>
     <li>
       <p>CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES:
         (unsigned int) input is the size in bytes of the buffer; output is the
         number of bytes filled with messages;
       </p>
     </li>
     <li>
       <p>CU_JIT_OPTIMIZATION_LEVEL:
         (unsigned int) input is the level of optimization to apply to generated
         code (0 - 4), with 4 being the default and highest
         level;
       </p>
     </li>
     <li>
       <p>CU_JIT_TARGET_FROM_CUCONTEXT:
         (No option value) causes compilation target to be determined based on
         current attached context (default);
       </p>
     </li>
     <li>
       <div>
         CU_JIT_TARGET: (unsigned int
         for enumerated type CUjit_target_enum) input is the compilation target
         based on supplied CUjit_target_enum;
         possible values are:
         <ul>
           <li>
             <p>CU_TARGET_COMPUTE_10</p>
           </li>
           <li>
             <p>CU_TARGET_COMPUTE_11</p>
           </li>
           <li>
             <p>CU_TARGET_COMPUTE_12</p>
           </li>
           <li>
             <p>CU_TARGET_COMPUTE_13</p>
           </li>
           <li>
             <p>CU_TARGET_COMPUTE_20</p>
           </li>
         </ul>
       </div>
     </li>
     <li>
       <div>
         CU_JIT_FALLBACK_STRATEGY:
         (unsigned int for enumerated type CUjit_fallback_enum) chooses fallback
         strategy if matching cubin is not found; possible
         values are:
         <ul>
           <li>
             <p>CU_PREFER_PTX</p>
           </li>
           <li>
             <p>CU_PREFER_BINARY</p>
           </li>
         </ul>
       </div>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>module</CODE> - Returned module<DD><CODE>image</CODE> - Module data to load<DD><CODE>numOptions</CODE> - Number of options<DD><CODE>options</CODE> - Options for JIT<DD><CODE>optionValues</CODE> - Option values for JIT
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_OUT_OF_MEMORY, CUDA_ERROR_NO_BINARY_FOR_GPU,
 CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND,
 CUDA_ERROR_SHARED_OBJECT_INIT_FAILED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadData(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadData(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleUnload(jcuda.driver.CUmodule)"><CODE>cuModuleUnload(jcuda.driver.CUmodule)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])"><!-- --></A><H3>
cuModuleLoadFatBinary</H3>
<PRE>
public static int <B>cuModuleLoadFatBinary</B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;module,
                                        byte[]&nbsp;fatCubin)</PRE>
<DL>
<DD>Load a module's data.
 
 <pre>
 CUresult cuModuleLoadFatBinary (
      CUmodule* module,
      const void* fatCubin )
 </pre>
 <div>
   <p>Load a module's data.  Takes a pointer
     <tt>fatCubin</tt> and loads the corresponding module <tt>module</tt>
     into the current context. The pointer represents a fat binary object,
     which is a collection of different cubin and/or PTX
     files, all representing the same device
     code, but compiled and optimized for different architectures.
   </p>
   <p>Prior to CUDA 4.0, there was no
     documented API for constructing and using fat binary objects by
     programmers. Starting with
     CUDA 4.0, fat binary objects can be
     constructed by providing the -fatbin option to <strong>nvcc</strong>.
     More information can be found in the <strong>nvcc</strong> document.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>module</CODE> - Returned module<DD><CODE>fatCubin</CODE> - Fat binary to load
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_NOT_FOUND,
 CUDA_ERROR_OUT_OF_MEMORY, CUDA_ERROR_NO_BINARY_FOR_GPU,
 CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND,
 CUDA_ERROR_SHARED_OBJECT_INIT_FAILED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadData(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadData(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)"><CODE>cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleUnload(jcuda.driver.CUmodule)"><CODE>cuModuleUnload(jcuda.driver.CUmodule)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleUnload(jcuda.driver.CUmodule)"><!-- --></A><H3>
cuModuleUnload</H3>
<PRE>
public static int <B>cuModuleUnload</B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod)</PRE>
<DL>
<DD>Unloads a module.
 
 <pre>
 CUresult cuModuleUnload (
      CUmodule hmod )
 </pre>
 <div>
   <p>Unloads a module.  Unloads a module <tt>hmod</tt> from the current context.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hmod</CODE> - Module to unload
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadData(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadData(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)"><CODE>cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)"><!-- --></A><H3>
cuModuleGetFunction</H3>
<PRE>
public static int <B>cuModuleGetFunction</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                                      <A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod,
                                      java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Returns a function handle.
 
 <pre>
 CUresult cuModuleGetFunction (
      CUfunction* hfunc,
      CUmodule hmod,
      const char* name )
 </pre>
 <div>
   <p>Returns a function handle.  Returns in
     <tt>*hfunc</tt> the handle of the function of name <tt>name</tt>
     located in module <tt>hmod</tt>. If no function of that name exists,
     cuModuleGetFunction() returns CUDA_ERROR_NOT_FOUND.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hfunc</CODE> - Returned function handle<DD><CODE>hmod</CODE> - Module to retrieve function from<DD><CODE>name</CODE> - Name of function to retrieve
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_NOT_FOUND<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadData(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadData(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)"><CODE>cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleUnload(jcuda.driver.CUmodule)"><CODE>cuModuleUnload(jcuda.driver.CUmodule)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)"><!-- --></A><H3>
cuModuleGetGlobal</H3>
<PRE>
public static int <B>cuModuleGetGlobal</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                                    long[]&nbsp;bytes,
                                    <A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod,
                                    java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Returns a global pointer from a module.
 
 <pre>
 CUresult cuModuleGetGlobal (
      CUdeviceptr* dptr,
      size_t* bytes,
      CUmodule hmod,
      const char* name )
 </pre>
 <div>
   <p>Returns a global pointer from a module. 
     Returns in <tt>*dptr</tt> and <tt>*bytes</tt> the base pointer and
     size of the global of name <tt>name</tt> located in module <tt>hmod</tt>. If no variable of that name exists, cuModuleGetGlobal()
     returns CUDA_ERROR_NOT_FOUND. Both parameters <tt>dptr</tt> and <tt>bytes</tt> are optional. If one of them is NULL, it is ignored.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dptr</CODE> - Returned global device pointer<DD><CODE>bytes</CODE> - Returned global size in bytes<DD><CODE>hmod</CODE> - Module to retrieve global from<DD><CODE>name</CODE> - Name of global to retrieve
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_NOT_FOUND<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadData(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadData(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)"><CODE>cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleUnload(jcuda.driver.CUmodule)"><CODE>cuModuleUnload(jcuda.driver.CUmodule)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)"><!-- --></A><H3>
cuModuleGetTexRef</H3>
<PRE>
public static int <B>cuModuleGetTexRef</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;pTexRef,
                                    <A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod,
                                    java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Returns a handle to a texture reference.
 
 <pre>
 CUresult cuModuleGetTexRef (
      CUtexref* pTexRef,
      CUmodule hmod,
      const char* name )
 </pre>
 <div>
   <p>Returns a handle to a texture reference.
     Returns in <tt>*pTexRef</tt> the handle of the texture reference of
     name <tt>name</tt> in the module <tt>hmod</tt>. If no texture
     reference of that name exists, cuModuleGetTexRef() returns
     CUDA_ERROR_NOT_FOUND. This texture reference handle should not be
     destroyed, since it will be destroyed when the module is unloaded.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pTexRef</CODE> - Returned texture reference<DD><CODE>hmod</CODE> - Module to retrieve texture reference from<DD><CODE>name</CODE> - Name of texture reference to retrieve
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_NOT_FOUND<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetSurfRef(jcuda.driver.CUsurfref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetSurfRef(jcuda.driver.CUsurfref, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadData(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadData(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)"><CODE>cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleUnload(jcuda.driver.CUmodule)"><CODE>cuModuleUnload(jcuda.driver.CUmodule)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleGetSurfRef(jcuda.driver.CUsurfref, jcuda.driver.CUmodule, java.lang.String)"><!-- --></A><H3>
cuModuleGetSurfRef</H3>
<PRE>
public static int <B>cuModuleGetSurfRef</B>(<A HREF="../../jcuda/driver/CUsurfref.html" title="class in jcuda.driver">CUsurfref</A>&nbsp;pSurfRef,
                                     <A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod,
                                     java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Returns a handle to a surface reference.
 
 <pre>
 CUresult cuModuleGetSurfRef (
      CUsurfref* pSurfRef,
      CUmodule hmod,
      const char* name )
 </pre>
 <div>
   <p>Returns a handle to a surface reference.
     Returns in <tt>*pSurfRef</tt> the handle of the surface reference of
     name <tt>name</tt> in the module <tt>hmod</tt>. If no surface
     reference of that name exists, cuModuleGetSurfRef() returns
     CUDA_ERROR_NOT_FOUND.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pSurfRef</CODE> - Returned surface reference<DD><CODE>hmod</CODE> - Module to retrieve surface reference from<DD><CODE>name</CODE> - Name of surface reference to retrieve
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_NOT_FOUND<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetGlobal(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadData(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadData(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)"><CODE>cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleUnload(jcuda.driver.CUmodule)"><CODE>cuModuleUnload(jcuda.driver.CUmodule)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemGetInfo(long[], long[])"><!-- --></A><H3>
cuMemGetInfo</H3>
<PRE>
public static int <B>cuMemGetInfo</B>(long[]&nbsp;free,
                               long[]&nbsp;total)</PRE>
<DL>
<DD>Gets free and total memory.
 
 <pre>
 CUresult cuMemGetInfo (
      size_t* free,
      size_t* total )
 </pre>
 <div>
   <p>Gets free and total memory.  Returns in
     <tt>*free</tt> and <tt>*total</tt> respectively, the free and total
     amount of memory available for allocation by the CUDA context, in
     bytes.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>free</CODE> - Returned free memory in bytes<DD><CODE>total</CODE> - Returned total memory in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemHostAlloc(jcuda.Pointer, long, int)"><!-- --></A><H3>
cuMemHostAlloc</H3>
<PRE>
public static int <B>cuMemHostAlloc</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pp,
                                 long&nbsp;bytes,
                                 int&nbsp;Flags)</PRE>
<DL>
<DD>Allocates page-locked host memory.
 
 <pre>
 CUresult cuMemHostAlloc (
      void** pp,
      size_t bytesize,
      unsigned int  Flags )
 </pre>
 <div>
   <p>Allocates page-locked host memory. 
     Allocates <tt>bytesize</tt> bytes of host memory that is page-locked
     and accessible to the device. The driver tracks the virtual memory
     ranges allocated
     with this function and automatically
     accelerates calls to functions such as cuMemcpyHtoD(). Since the memory
     can be accessed directly by the device, it can be read or written with
     much higher bandwidth than pageable
     memory obtained with functions such as
     malloc(). Allocating excessive amounts of pinned memory may degrade
     system performance,
     since it reduces the amount of memory
     available to the system for paging. As a result, this function is best
     used sparingly
     to allocate staging areas for data
     exchange between host and device.
   </p>
   <p>The <tt>Flags</tt> parameter enables
     different options to be specified that affect the allocation, as
     follows.
   </p>
   <ul>
     <li>
       <p>CU_MEMHOSTALLOC_PORTABLE: The
         memory returned by this call will be considered as pinned memory by
         all CUDA contexts, not just the one that performed
         the allocation.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CU_MEMHOSTALLOC_DEVICEMAP: Maps
         the allocation into the CUDA address space. The device pointer to the
         memory may be obtained by calling cuMemHostGetDevicePointer(). This
         feature is available only on GPUs with compute capability greater than
         or equal to 1.1.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CU_MEMHOSTALLOC_WRITECOMBINED:
         Allocates the memory as write-combined (WC). WC memory can be
         transferred across the PCI Express bus more quickly on some
         system configurations, but
         cannot be read efficiently by most CPUs. WC memory is a good option
         for buffers that will be written
         by the CPU and read by the GPU
         via mapped pinned memory or host-&gt;device transfers.
       </p>
     </li>
   </ul>
   </p>
   <p>All of these flags are orthogonal to
     one another: a developer may allocate memory that is portable, mapped
     and/or write-combined
     with no restrictions.
   </p>
   <p>The CUDA context must have been created
     with the CU_CTX_MAP_HOST flag in order for the CU_MEMHOSTALLOC_DEVICEMAP
     flag to have any effect.
   </p>
   <p>The CU_MEMHOSTALLOC_DEVICEMAP flag may
     be specified on CUDA contexts for devices that do not support mapped
     pinned memory. The failure is deferred to cuMemHostGetDevicePointer()
     because the memory may be mapped into other CUDA contexts via the
     CU_MEMHOSTALLOC_PORTABLE flag.
   </p>
   <p>The memory allocated by this function
     must be freed with cuMemFreeHost().
   </p>
   <p>Note all host memory allocated using
     cuMemHostAlloc() will automatically be immediately accessible to all
     contexts on all devices which support unified addressing (as may be
     queried
     using CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING).
     Unless the flag CU_MEMHOSTALLOC_WRITECOMBINED is specified, the device
     pointer that may be used to access this host memory from those contexts
     is always equal to the returned
     host pointer <tt>*pp</tt>. If the flag
     CU_MEMHOSTALLOC_WRITECOMBINED is specified, then the function
     cuMemHostGetDevicePointer() must be used to query the device pointer,
     even if the context supports unified addressing. See Unified Addressing
     for additional details.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pp</CODE> - Returned host pointer to page-locked memory<DD><CODE>bytesize</CODE> - Requested allocation size in bytes<DD><CODE>Flags</CODE> - Flags for allocation request
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_OUT_OF_MEMORY<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><!-- --></A><H3>
cuMemHostGetDevicePointer</H3>
<PRE>
public static int <B>cuMemHostGetDevicePointer</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;ret,
                                            <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p,
                                            int&nbsp;Flags)</PRE>
<DL>
<DD>Passes back device pointer of mapped pinned memory.
 
 <pre>
 CUresult cuMemHostGetDevicePointer (
      CUdeviceptr* pdptr,
      void* p,
      unsigned int  Flags )
 </pre>
 <div>
   <p>Passes back device pointer of mapped
     pinned memory.  Passes back the device pointer <tt>pdptr</tt>
     corresponding to the mapped, pinned host buffer <tt>p</tt> allocated
     by cuMemHostAlloc.
   </p>
   <p>cuMemHostGetDevicePointer() will fail
     if the CU_MEMHOSTALLOC_DEVICEMAP flag was not specified at the time
     the memory was allocated, or if the function is called on a GPU that
     does not support
     mapped pinned memory.
   </p>
   <p><tt>Flags</tt> provides for future
     releases. For now, it must be set to 0.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pdptr</CODE> - Returned device pointer<DD><CODE>p</CODE> - Host pointer<DD><CODE>Flags</CODE> - Options (must be 0)
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemHostGetFlags(int[], jcuda.Pointer)"><!-- --></A><H3>
cuMemHostGetFlags</H3>
<PRE>
public static int <B>cuMemHostGetFlags</B>(int[]&nbsp;pFlags,
                                    <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p)</PRE>
<DL>
<DD>Passes back flags that were used for a pinned allocation.
 
 <pre>
 CUresult cuMemHostGetFlags (
      unsigned int* pFlags,
      void* p )
 </pre>
 <div>
   <p>Passes back flags that were used for a
     pinned allocation.  Passes back the flags <tt>pFlags</tt> that were
     specified when allocating the pinned host buffer <tt>p</tt> allocated
     by cuMemHostAlloc.
   </p>
   <p>cuMemHostGetFlags() will fail if the
     pointer does not reside in an allocation performed by cuMemAllocHost()
     or cuMemHostAlloc().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pFlags</CODE> - Returned flags word<DD><CODE>p</CODE> - Host pointer
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuDeviceGetByPCIBusId(jcuda.driver.CUdevice, java.lang.String)"><!-- --></A><H3>
cuDeviceGetByPCIBusId</H3>
<PRE>
public static int <B>cuDeviceGetByPCIBusId</B>(<A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev,
                                        java.lang.String&nbsp;pciBusId)</PRE>
<DL>
<DD>Returns a handle to a compute device.
 
 <pre>
 CUresult cuDeviceGetByPCIBusId (
      CUdevice* dev,
      char* pciBusId )
 </pre>
 <div>
   <p>Returns a handle to a compute device. 
     Returns in <tt>*device</tt> a device handle given a PCI bus ID
     string.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dev</CODE> - Returned device handle<DD><CODE>pciBusId</CODE> - String in one of the following forms: [domain]:[bus]:[device].[function] [domain]:[bus]:[device] [bus]:[device].[function] where domain, bus, device, and function are all hexadecimal values
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_INVALID_DEVICE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGet(jcuda.driver.CUdevice, int)"><CODE>cuDeviceGet(jcuda.driver.CUdevice, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetPCIBusId(java.lang.String[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetPCIBusId(java.lang.String[], int, jcuda.driver.CUdevice)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuDeviceGetPCIBusId(java.lang.String[], int, jcuda.driver.CUdevice)"><!-- --></A><H3>
cuDeviceGetPCIBusId</H3>
<PRE>
public static int <B>cuDeviceGetPCIBusId</B>(java.lang.String[]&nbsp;pciBusId,
                                      int&nbsp;len,
                                      <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</PRE>
<DL>
<DD>Returns a PCI Bus Id string for the device.
 
 <pre>
 CUresult cuDeviceGetPCIBusId (
      char* pciBusId,
      int  len,
      CUdevice dev )
 </pre>
 <div>
   <p>Returns a PCI Bus Id string for the
     device.  Returns an ASCII string identifying the device <tt>dev</tt>
     in the NULL-terminated string pointed to by <tt>pciBusId</tt>. <tt>len</tt> specifies the maximum length of the string that may be
     returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pciBusId</CODE> - Returned identifier string for the device in the following format [domain]:[bus]:[device].[function] where domain, bus, device, and function are all hexadecimal values. pciBusId should be large enough to store 13 characters including the NULL-terminator.<DD><CODE>len</CODE> - Maximum length of string to store in name<DD><CODE>dev</CODE> - Device to get identifier string for
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_INVALID_DEVICE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGet(jcuda.driver.CUdevice, int)"><CODE>cuDeviceGet(jcuda.driver.CUdevice, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetByPCIBusId(jcuda.driver.CUdevice, java.lang.String)"><CODE>cuDeviceGetByPCIBusId(jcuda.driver.CUdevice, java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuIpcGetEventHandle(jcuda.driver.CUipcEventHandle, jcuda.driver.CUevent)"><!-- --></A><H3>
cuIpcGetEventHandle</H3>
<PRE>
public static int <B>cuIpcGetEventHandle</B>(<A HREF="../../jcuda/driver/CUipcEventHandle.html" title="class in jcuda.driver">CUipcEventHandle</A>&nbsp;pHandle,
                                      <A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;event)</PRE>
<DL>
<DD>Gets an interprocess handle for a previously allocated event.
 
 <pre>
 CUresult cuIpcGetEventHandle (
      CUipcEventHandle* pHandle,
      CUevent event )
 </pre>
 <div>
   <p>Gets an interprocess handle for a
     previously allocated event.  Takes as input a previously allocated
     event. This event must
     have been created with the
     CU_EVENT_INTERPROCESS and CU_EVENT_DISABLE_TIMING flags set. This
     opaque handle may be copied into other processes and opened with
     cuIpcOpenEventHandle to allow efficient hardware synchronization
     between GPU work in different processes.
   </p>
   <p>After the event has been been opened in
     the importing process, cuEventRecord, cuEventSynchronize,
     cuStreamWaitEvent and cuEventQuery may be used in either process.
     Performing operations on the imported event after the exported event
     has been freed with cuEventDestroy will result in undefined behavior.
   </p>
   <p>IPC functionality is restricted to
     devices with support for unified addressing on Linux operating
     systems.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pHandle</CODE> - Pointer to a user allocated CUipcEventHandle in which to return the opaque event handle<DD><CODE>event</CODE> - Event allocated with CU_EVENT_INTERPROCESS and CU_EVENT_DISABLE_TIMING flags.
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_HANDLE, CUDA_ERROR_OUT_OF_MEMORY,
 CUDA_ERROR_MAP_FAILED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventCreate(jcuda.driver.CUevent, int)"><CODE>cuEventCreate(jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventDestroy(jcuda.driver.CUevent)"><CODE>cuEventDestroy(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventSynchronize(jcuda.driver.CUevent)"><CODE>cuEventSynchronize(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventQuery(jcuda.driver.CUevent)"><CODE>cuEventQuery(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)"><CODE>cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcOpenEventHandle(jcuda.driver.CUevent, jcuda.driver.CUipcEventHandle)"><CODE>cuIpcOpenEventHandle(jcuda.driver.CUevent, jcuda.driver.CUipcEventHandle)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcGetMemHandle(jcuda.driver.CUipcMemHandle, jcuda.driver.CUdeviceptr)"><CODE>cuIpcGetMemHandle(jcuda.driver.CUipcMemHandle, jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcOpenMemHandle(jcuda.driver.CUdeviceptr, jcuda.driver.CUipcMemHandle, int)"><CODE>cuIpcOpenMemHandle(jcuda.driver.CUdeviceptr, jcuda.driver.CUipcMemHandle, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcCloseMemHandle(jcuda.driver.CUdeviceptr)"><CODE>cuIpcCloseMemHandle(jcuda.driver.CUdeviceptr)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuIpcOpenEventHandle(jcuda.driver.CUevent, jcuda.driver.CUipcEventHandle)"><!-- --></A><H3>
cuIpcOpenEventHandle</H3>
<PRE>
public static int <B>cuIpcOpenEventHandle</B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;phEvent,
                                       <A HREF="../../jcuda/driver/CUipcEventHandle.html" title="class in jcuda.driver">CUipcEventHandle</A>&nbsp;handle)</PRE>
<DL>
<DD>Opens an interprocess event handle for use in the current process.
 
 <pre>
 CUresult cuIpcOpenEventHandle (
      CUevent* phEvent,
      CUipcEventHandle handle )
 </pre>
 <div>
   <p>Opens an interprocess event handle for
     use in the current process.  Opens an interprocess event handle exported
     from another
     process with cuIpcGetEventHandle. This
     function returns a CUevent that behaves like a locally created event
     with the CU_EVENT_DISABLE_TIMING flag specified. This event must be
     freed with cuEventDestroy.
   </p>
   <p>Performing operations on the imported
     event after the exported event has been freed with cuEventDestroy will
     result in undefined behavior.
   </p>
   <p>IPC functionality is restricted to
     devices with support for unified addressing on Linux operating
     systems.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>phEvent</CODE> - Returns the imported event<DD><CODE>handle</CODE> - Interprocess handle to open
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_MAP_FAILED,
 CUDA_ERROR_PEER_ACCESS_UNSUPPORTED, CUDA_ERROR_INVALID_HANDLE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventCreate(jcuda.driver.CUevent, int)"><CODE>cuEventCreate(jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventDestroy(jcuda.driver.CUevent)"><CODE>cuEventDestroy(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventSynchronize(jcuda.driver.CUevent)"><CODE>cuEventSynchronize(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventQuery(jcuda.driver.CUevent)"><CODE>cuEventQuery(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)"><CODE>cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcGetEventHandle(jcuda.driver.CUipcEventHandle, jcuda.driver.CUevent)"><CODE>cuIpcGetEventHandle(jcuda.driver.CUipcEventHandle, jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcGetMemHandle(jcuda.driver.CUipcMemHandle, jcuda.driver.CUdeviceptr)"><CODE>cuIpcGetMemHandle(jcuda.driver.CUipcMemHandle, jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcOpenMemHandle(jcuda.driver.CUdeviceptr, jcuda.driver.CUipcMemHandle, int)"><CODE>cuIpcOpenMemHandle(jcuda.driver.CUdeviceptr, jcuda.driver.CUipcMemHandle, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcCloseMemHandle(jcuda.driver.CUdeviceptr)"><CODE>cuIpcCloseMemHandle(jcuda.driver.CUdeviceptr)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuIpcGetMemHandle(jcuda.driver.CUipcMemHandle, jcuda.driver.CUdeviceptr)"><!-- --></A><H3>
cuIpcGetMemHandle</H3>
<PRE>
public static int <B>cuIpcGetMemHandle</B>(<A HREF="../../jcuda/driver/CUipcMemHandle.html" title="class in jcuda.driver">CUipcMemHandle</A>&nbsp;pHandle,
                                    <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr)</PRE>
<DL>
<DD>Gets an interprocess memory handle for an existing device memory
 allocation.

 <pre>
 CUresult cuIpcGetMemHandle (
      CUipcMemHandle* pHandle,
      CUdeviceptr dptr )
 </pre>
 <div>
   <p> /brief Gets an interprocess memory
     handle for an existing device memory allocation
   </p>
   <p>Takes a pointer to the base of an
     existing device memory allocation created with cuMemAlloc and exports
     it for use in another process. This is a lightweight operation and may
     be called multiple times on an allocation
     without adverse effects.
   </p>
   <p>If a region of memory is freed with
     cuMemFree and a subsequent call to cuMemAlloc returns memory with the
     same device address, cuIpcGetMemHandle will return a unique handle for
     the new memory.
   </p>
   <p>IPC functionality is restricted to
     devices with support for unified addressing on Linux operating
     systems.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pHandle</CODE> - Pointer to user allocated CUipcMemHandle to return the handle in.<DD><CODE>dptr</CODE> - Base pointer to previously allocated device memory
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_HANDLE, CUDA_ERROR_OUT_OF_MEMORY,
 CUDA_ERROR_MAP_FAILED,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcGetEventHandle(jcuda.driver.CUipcEventHandle, jcuda.driver.CUevent)"><CODE>cuIpcGetEventHandle(jcuda.driver.CUipcEventHandle, jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcOpenEventHandle(jcuda.driver.CUevent, jcuda.driver.CUipcEventHandle)"><CODE>cuIpcOpenEventHandle(jcuda.driver.CUevent, jcuda.driver.CUipcEventHandle)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcOpenMemHandle(jcuda.driver.CUdeviceptr, jcuda.driver.CUipcMemHandle, int)"><CODE>cuIpcOpenMemHandle(jcuda.driver.CUdeviceptr, jcuda.driver.CUipcMemHandle, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcCloseMemHandle(jcuda.driver.CUdeviceptr)"><CODE>cuIpcCloseMemHandle(jcuda.driver.CUdeviceptr)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuIpcOpenMemHandle(jcuda.driver.CUdeviceptr, jcuda.driver.CUipcMemHandle, int)"><!-- --></A><H3>
cuIpcOpenMemHandle</H3>
<PRE>
public static int <B>cuIpcOpenMemHandle</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;pdptr,
                                     <A HREF="../../jcuda/driver/CUipcMemHandle.html" title="class in jcuda.driver">CUipcMemHandle</A>&nbsp;handle,
                                     int&nbsp;Flags)</PRE>
<DL>
<DD><pre>
 CUresult cuIpcOpenMemHandle (
      CUdeviceptr* pdptr,
      CUipcMemHandle handle,
      unsigned int  Flags )
 </pre>
 <div>
   <p> /brief Opens an interprocess memory
     handle exported from another process and returns a device pointer
     usable in the local
     process.
   </p>
   <p>Maps memory exported from another
     process with cuIpcGetMemHandle into the current device address space.
     For contexts on different devices cuIpcOpenMemHandle can attempt to
     enable peer access between the devices as if the user called
     cuCtxEnablePeerAccess. This behavior is controlled by the
     CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS flag. cuDeviceCanAccessPeer can
     determine if a mapping is possible.
   </p>
   <p>Contexts that may open CUipcMemHandles
     are restricted in the following way. CUipcMemHandles from each CUdevice
     in a given process may only be opened by one CUcontext per CUdevice
     per other process.
   </p>
   <p>Memory returned from cuIpcOpenMemHandle
     must be freed with cuIpcCloseMemHandle.
   </p>
   <p>Calling cuMemFree on an exported memory
     region before calling cuIpcCloseMemHandle in the importing context will
     result in undefined behavior.
   </p>
   <p>IPC functionality is restricted to
     devices with support for unified addressing on Linux operating
     systems.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pdptr</CODE> - Returned device pointer<DD><CODE>handle</CODE> - CUipcMemHandle to open<DD><CODE>Flags</CODE> - Flags for this operation. Must be specified as CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_MAP_FAILED,
 CUDA_ERROR_INVALID_HANDLE, CUDA_ERROR_TOO_MANY_PEERS<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcGetEventHandle(jcuda.driver.CUipcEventHandle, jcuda.driver.CUevent)"><CODE>cuIpcGetEventHandle(jcuda.driver.CUipcEventHandle, jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcOpenEventHandle(jcuda.driver.CUevent, jcuda.driver.CUipcEventHandle)"><CODE>cuIpcOpenEventHandle(jcuda.driver.CUevent, jcuda.driver.CUipcEventHandle)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcGetMemHandle(jcuda.driver.CUipcMemHandle, jcuda.driver.CUdeviceptr)"><CODE>cuIpcGetMemHandle(jcuda.driver.CUipcMemHandle, jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcCloseMemHandle(jcuda.driver.CUdeviceptr)"><CODE>cuIpcCloseMemHandle(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxEnablePeerAccess(jcuda.driver.CUcontext, int)"><CODE>cuCtxEnablePeerAccess(jcuda.driver.CUcontext, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceCanAccessPeer(int[], jcuda.driver.CUdevice, jcuda.driver.CUdevice)"><CODE>cuDeviceCanAccessPeer(int[], jcuda.driver.CUdevice, jcuda.driver.CUdevice)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuIpcCloseMemHandle(jcuda.driver.CUdeviceptr)"><!-- --></A><H3>
cuIpcCloseMemHandle</H3>
<PRE>
public static int <B>cuIpcCloseMemHandle</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr)</PRE>
<DL>
<DD>Close memory mapped with cuIpcOpenMemHandle.
 
 <pre>
 CUresult cuIpcCloseMemHandle (
      CUdeviceptr dptr )
 </pre>
 <div>
   <p>Close memory mapped with cuIpcOpenMemHandle.
     Unmaps memory returnd by cuIpcOpenMemHandle. The original allocation
     in the exporting process as well as imported mappings in other processes
     will be unaffected.
   </p>
   <p>Any resources used to enable peer access
     will be freed if this is the last mapping using them.
   </p>
   <p>IPC functionality is restricted to
     devices with support for unified addressing on Linux operating
     systems.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dptr</CODE> - Device pointer returned by cuIpcOpenMemHandle
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_MAP_FAILED,
 CUDA_ERROR_INVALID_HANDLE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcGetEventHandle(jcuda.driver.CUipcEventHandle, jcuda.driver.CUevent)"><CODE>cuIpcGetEventHandle(jcuda.driver.CUipcEventHandle, jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcOpenEventHandle(jcuda.driver.CUevent, jcuda.driver.CUipcEventHandle)"><CODE>cuIpcOpenEventHandle(jcuda.driver.CUevent, jcuda.driver.CUipcEventHandle)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcGetMemHandle(jcuda.driver.CUipcMemHandle, jcuda.driver.CUdeviceptr)"><CODE>cuIpcGetMemHandle(jcuda.driver.CUipcMemHandle, jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuIpcOpenMemHandle(jcuda.driver.CUdeviceptr, jcuda.driver.CUipcMemHandle, int)"><CODE>cuIpcOpenMemHandle(jcuda.driver.CUdeviceptr, jcuda.driver.CUipcMemHandle, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemHostRegister(jcuda.Pointer, long, int)"><!-- --></A><H3>
cuMemHostRegister</H3>
<PRE>
public static int <B>cuMemHostRegister</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p,
                                    long&nbsp;bytesize,
                                    int&nbsp;Flags)</PRE>
<DL>
<DD>Registers an existing host memory range for use by CUDA.
 
 <pre>
 CUresult cuMemHostRegister (
      void* p,
      size_t bytesize,
      unsigned int  Flags )
 </pre>
 <div>
   <p>Registers an existing host memory range
     for use by CUDA.  Page-locks the memory range specified by <tt>p</tt>
     and <tt>bytesize</tt> and maps it for the device(s) as specified by
     <tt>Flags</tt>. This memory range also is added to the same tracking
     mechanism as cuMemHostAlloc to automatically accelerate calls to
     functions such as cuMemcpyHtoD(). Since the memory can be accessed
     directly by the device, it can be read or written with much higher
     bandwidth than pageable
     memory that has not been registered.
     Page-locking excessive amounts of memory may degrade system performance,
     since it reduces
     the amount of memory available to the
     system for paging. As a result, this function is best used sparingly
     to register staging
     areas for data exchange between host and
     device.
   </p>
   <p>This function has limited support on
     Mac OS X. OS 10.7 or higher is required.
   </p>
   <p>The <tt>Flags</tt> parameter enables
     different options to be specified that affect the allocation, as
     follows.
   </p>
   <ul>
     <li>
       <p>CU_MEMHOSTREGISTER_PORTABLE:
         The memory returned by this call will be considered as pinned memory
         by all CUDA contexts, not just the one that performed
         the allocation.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CU_MEMHOSTREGISTER_DEVICEMAP:
         Maps the allocation into the CUDA address space. The device pointer to
         the memory may be obtained by calling cuMemHostGetDevicePointer(). This
         feature is available only on GPUs with compute capability greater than
         or equal to 1.1.
       </p>
     </li>
   </ul>
   </p>
   <p>All of these flags are orthogonal to
     one another: a developer may page-lock memory that is portable or
     mapped with no restrictions.
   </p>
   <p>The CUDA context must have been created
     with the CU_CTX_MAP_HOST flag in order for the CU_MEMHOSTREGISTER_DEVICEMAP
     flag to have any effect.
   </p>
   <p>The CU_MEMHOSTREGISTER_DEVICEMAP flag
     may be specified on CUDA contexts for devices that do not support
     mapped pinned memory. The failure is deferred to cuMemHostGetDevicePointer()
     because the memory may be mapped into other CUDA contexts via the
     CU_MEMHOSTREGISTER_PORTABLE flag.
   </p>
   <p>The memory page-locked by this function
     must be unregistered with cuMemHostUnregister().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p</CODE> - Host pointer to memory to page-lock<DD><CODE>bytesize</CODE> - Size in bytes of the address range to page-lock<DD><CODE>Flags</CODE> - Flags for allocation request
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_OUT_OF_MEMORY, CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostUnregister(jcuda.Pointer)"><CODE>cuMemHostUnregister(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetFlags(int[], jcuda.Pointer)"><CODE>cuMemHostGetFlags(int[], jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemHostUnregister(jcuda.Pointer)"><!-- --></A><H3>
cuMemHostUnregister</H3>
<PRE>
public static int <B>cuMemHostUnregister</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p)</PRE>
<DL>
<DD>Unregisters a memory range that was registered with cuMemHostRegister.
 
 <pre>
 CUresult cuMemHostUnregister (
      void* p )
 </pre>
 <div>
   <p>Unregisters a memory range that was
     registered with cuMemHostRegister.  Unmaps the memory range whose base
     address is specified
     by <tt>p</tt>, and makes it pageable
     again.
   </p>
   <p>The base address must be the same one
     specified to cuMemHostRegister().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p</CODE> - Host pointer to memory to unregister
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_OUT_OF_MEMORY, CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostRegister(jcuda.Pointer, long, int)"><CODE>cuMemHostRegister(jcuda.Pointer, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpy(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><!-- --></A><H3>
cuMemcpy</H3>
<PRE>
public static int <B>cuMemcpy</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dst,
                           <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;src,
                           long&nbsp;ByteCount)</PRE>
<DL>
<DD>Copies memory.
 
 <pre>
 CUresult cuMemcpy (
      CUdeviceptr dst,
      CUdeviceptr src,
      size_t ByteCount )
 </pre>
 <div>
   <p>Copies memory.  Copies data between two
     pointers. <tt>dst</tt> and <tt>src</tt> are base pointers of the
     destination and source, respectively. <tt>ByteCount</tt> specifies
     the number of bytes to copy. Note that this function infers the type
     of the transfer (host to host, host to device,
     device to device, or device to host) from
     the pointer values. This function is only allowed in contexts which
     support unified
     addressing. Note that this function is
     synchronous.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination unified virtual address space pointer<DD><CODE>src</CODE> - Source unified virtual address space pointer<DD><CODE>ByteCount</CODE> - Size of memory copy in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyPeer(jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, long)"><!-- --></A><H3>
cuMemcpyPeer</H3>
<PRE>
public static int <B>cuMemcpyPeer</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                               <A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;dstContext,
                               <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
                               <A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;srcContext,
                               long&nbsp;ByteCount)</PRE>
<DL>
<DD>Copies device memory between two contexts.
 
 <pre>
 CUresult cuMemcpyPeer (
      CUdeviceptr dstDevice,
      CUcontext dstContext,
      CUdeviceptr srcDevice,
      CUcontext srcContext,
      size_t ByteCount )
 </pre>
 <div>
   <p>Copies device memory between two contexts.
     Copies from device memory in one context to device memory in another
     context.
     <tt>dstDevice</tt> is the base device
     pointer of the destination memory and <tt>dstContext</tt> is the
     destination context. <tt>srcDevice</tt> is the base device pointer of
     the source memory and <tt>srcContext</tt> is the source pointer. <tt>ByteCount</tt> specifies the number of bytes to copy.
   </p>
   <p>Note that this function is asynchronous
     with respect to the host, but serialized with respect all pending and
     future asynchronous
     work in to the current context, <tt>srcContext</tt>, and <tt>dstContext</tt> (use cuMemcpyPeerAsync to
     avoid this synchronization).
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>dstContext</CODE> - Destination context<DD><CODE>srcDevice</CODE> - Source device pointer<DD><CODE>srcContext</CODE> - Source context<DD><CODE>ByteCount</CODE> - Size of memory copy in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DPeer(jcuda.driver.CUDA_MEMCPY3D_PEER)"><CODE>cuMemcpy3DPeer(jcuda.driver.CUDA_MEMCPY3D_PEER)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyPeerAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, long, jcuda.driver.CUstream)"><CODE>cuMemcpyPeerAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DPeerAsync(jcuda.driver.CUDA_MEMCPY3D_PEER, jcuda.driver.CUstream)"><CODE>cuMemcpy3DPeerAsync(jcuda.driver.CUDA_MEMCPY3D_PEER, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><!-- --></A><H3>
cuMemAlloc</H3>
<PRE>
public static int <B>cuMemAlloc</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                             long&nbsp;bytesize)</PRE>
<DL>
<DD>Allocates device memory.
 
 <pre>
 CUresult cuMemAlloc (
      CUdeviceptr* dptr,
      size_t bytesize )
 </pre>
 <div>
   <p>Allocates device memory.  Allocates <tt>bytesize</tt> bytes of linear memory on the device and returns in <tt>*dptr</tt> a pointer to the allocated memory. The allocated memory is
     suitably aligned for any kind of variable. The memory is not cleared.
     If <tt>bytesize</tt> is 0, cuMemAlloc()
     returns CUDA_ERROR_INVALID_VALUE.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dptr</CODE> - Returned device pointer<DD><CODE>bytesize</CODE> - Requested allocation size in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_OUT_OF_MEMORY<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><!-- --></A><H3>
cuMemAllocPitch</H3>
<PRE>
public static int <B>cuMemAllocPitch</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                                  long[]&nbsp;pPitch,
                                  long&nbsp;WidthInBytes,
                                  long&nbsp;Height,
                                  int&nbsp;ElementSizeBytes)</PRE>
<DL>
<DD>Allocates pitched device memory.
 
 <pre>
 CUresult cuMemAllocPitch (
      CUdeviceptr* dptr,
      size_t* pPitch,
      size_t WidthInBytes,
      size_t Height,
      unsigned int  ElementSizeBytes )
 </pre>
 <div>
   <p>Allocates pitched device memory. 
     Allocates at least <tt>WidthInBytes</tt> * <tt>Height</tt> bytes of
     linear memory on the device and returns in <tt>*dptr</tt> a pointer
     to the allocated memory. The function may pad the allocation to ensure
     that corresponding pointers in any given
     row will continue to meet the alignment
     requirements for coalescing as the address is updated from row to row.
     <tt>ElementSizeBytes</tt> specifies the size of the largest reads and
     writes that will be performed on the memory range. <tt>ElementSizeBytes</tt> may be 4, 8 or 16 (since coalesced memory
     transactions are not possible on other data sizes). If <tt>ElementSizeBytes</tt> is smaller than the actual read/write size of a
     kernel, the kernel will run correctly, but possibly at reduced speed.
     The
     pitch returned in <tt>*pPitch</tt> by
     cuMemAllocPitch() is the width in bytes of the allocation. The intended
     usage of pitch is as a separate parameter of the allocation, used to
     compute addresses within the 2D array.
     Given the row and column of an array element of type <strong>T</strong>,
     the address is computed as: 
   <pre>   T* pElement = (T*)((char*)BaseAddress
 + Row * Pitch) + Column;</pre>
   </p>
   <p>The pitch returned by cuMemAllocPitch()
     is guaranteed to work with cuMemcpy2D() under all circumstances. For
     allocations of 2D arrays, it is recommended that programmers consider
     performing pitch allocations
     using cuMemAllocPitch(). Due to alignment
     restrictions in the hardware, this is especially true if the application
     will be performing 2D memory copies
     between different regions of device
     memory (whether linear memory or CUDA arrays).
   </p>
   <p>The byte alignment of the pitch returned
     by cuMemAllocPitch() is guaranteed to match or exceed the alignment
     requirement for texture binding with cuTexRefSetAddress2D().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dptr</CODE> - Returned device pointer<DD><CODE>pPitch</CODE> - Returned pitch of allocation in bytes<DD><CODE>WidthInBytes</CODE> - Requested allocation width in bytes<DD><CODE>Height</CODE> - Requested allocation height in rows<DD><CODE>ElementSizeBytes</CODE> - Size of largest reads/writes for range
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_OUT_OF_MEMORY<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemFree(jcuda.driver.CUdeviceptr)"><!-- --></A><H3>
cuMemFree</H3>
<PRE>
public static int <B>cuMemFree</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr)</PRE>
<DL>
<DD>Frees device memory.
 
 <pre>
 CUresult cuMemFree (
      CUdeviceptr dptr )
 </pre>
 <div>
   <p>Frees device memory.  Frees the memory
     space pointed to by <tt>dptr</tt>, which must have been returned by a
     previous call to cuMemAlloc() or cuMemAllocPitch().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dptr</CODE> - Pointer to memory to free
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><!-- --></A><H3>
cuMemGetAddressRange</H3>
<PRE>
public static int <B>cuMemGetAddressRange</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;pbase,
                                       long[]&nbsp;psize,
                                       <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr)</PRE>
<DL>
<DD>Get information on memory allocations.
 
 <pre>
 CUresult cuMemGetAddressRange (
      CUdeviceptr* pbase,
      size_t* psize,
      CUdeviceptr dptr )
 </pre>
 <div>
   <p>Get information on memory allocations. 
     Returns the base address in <tt>*pbase</tt> and size in <tt>*psize</tt>
     of the allocation by cuMemAlloc() or cuMemAllocPitch() that contains
     the input pointer <tt>dptr</tt>. Both parameters <tt>pbase</tt> and
     <tt>psize</tt> are optional. If one of them is NULL, it is ignored.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pbase</CODE> - Returned base address<DD><CODE>psize</CODE> - Returned size of device memory allocation<DD><CODE>dptr</CODE> - Device pointer to query
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemAllocHost(jcuda.Pointer, long)"><!-- --></A><H3>
cuMemAllocHost</H3>
<PRE>
public static int <B>cuMemAllocHost</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pointer,
                                 long&nbsp;bytesize)</PRE>
<DL>
<DD>Allocates page-locked host memory.
 
 <pre>
 CUresult cuMemAllocHost (
      void** pp,
      size_t bytesize )
 </pre>
 <div>
   <p>Allocates page-locked host memory. 
     Allocates <tt>bytesize</tt> bytes of host memory that is page-locked
     and accessible to the device. The driver tracks the virtual memory
     ranges allocated
     with this function and automatically
     accelerates calls to functions such as cuMemcpy(). Since the memory
     can be accessed directly by the device, it can be read or written with
     much higher bandwidth than pageable
     memory obtained with functions such as
     malloc(). Allocating excessive amounts of memory with cuMemAllocHost()
     may degrade system performance, since it reduces the amount of memory
     available to the system for paging. As a result, this
     function is best used sparingly to
     allocate staging areas for data exchange between host and device.
   </p>
   <p>Note all host memory allocated using
     cuMemHostAlloc() will automatically be immediately accessible to all
     contexts on all devices which support unified addressing (as may be
     queried
     using CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING).
     The device pointer that may be used to access this host memory from
     those contexts is always equal to the returned host
     pointer <tt>*pp</tt>. See Unified
     Addressing for additional details.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pp</CODE> - Returned host pointer to page-locked memory<DD><CODE>bytesize</CODE> - Requested allocation size in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_OUT_OF_MEMORY<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemFreeHost(jcuda.Pointer)"><!-- --></A><H3>
cuMemFreeHost</H3>
<PRE>
public static int <B>cuMemFreeHost</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p)</PRE>
<DL>
<DD>Frees page-locked host memory.
 
 <pre>
 CUresult cuMemFreeHost (
      void* p )
 </pre>
 <div>
   <p>Frees page-locked host memory.  Frees
     the memory space pointed to by <tt>p</tt>, which must have been
     returned by a previous call to cuMemAllocHost().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p</CODE> - Pointer to memory to free
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><!-- --></A><H3>
cuMemcpyHtoD</H3>
<PRE>
public static int <B>cuMemcpyHtoD</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                               <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;srcHost,
                               long&nbsp;ByteCount)</PRE>
<DL>
<DD>Copies memory from Host to Device.
 
 <pre>
 CUresult cuMemcpyHtoD (
      CUdeviceptr dstDevice,
      const void* srcHost,
      size_t ByteCount )
 </pre>
 <div>
   <p>Copies memory from Host to Device. 
     Copies from host memory to device memory. <tt>dstDevice</tt> and <tt>srcHost</tt> are the base addresses of the destination and source,
     respectively. <tt>ByteCount</tt> specifies the number of bytes to
     copy. Note that this function is synchronous.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>srcHost</CODE> - Source host pointer<DD><CODE>ByteCount</CODE> - Size of memory copy in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><!-- --></A><H3>
cuMemcpyDtoH</H3>
<PRE>
public static int <B>cuMemcpyDtoH</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dstHost,
                               <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
                               long&nbsp;ByteCount)</PRE>
<DL>
<DD>Copies memory from Device to Host.
 
 <pre>
 CUresult cuMemcpyDtoH (
      void* dstHost,
      CUdeviceptr srcDevice,
      size_t ByteCount )
 </pre>
 <div>
   <p>Copies memory from Device to Host. 
     Copies from device to host memory. <tt>dstHost</tt> and <tt>srcDevice</tt> specify the base pointers of the destination and
     source, respectively. <tt>ByteCount</tt> specifies the number of bytes
     to copy. Note that this function is synchronous.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstHost</CODE> - Destination host pointer<DD><CODE>srcDevice</CODE> - Source device pointer<DD><CODE>ByteCount</CODE> - Size of memory copy in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><!-- --></A><H3>
cuMemcpyDtoD</H3>
<PRE>
public static int <B>cuMemcpyDtoD</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                               <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
                               long&nbsp;ByteCount)</PRE>
<DL>
<DD>Copies memory from Device to Device.
 
 <pre>
 CUresult cuMemcpyDtoD (
      CUdeviceptr dstDevice,
      CUdeviceptr srcDevice,
      size_t ByteCount )
 </pre>
 <div>
   <p>Copies memory from Device to Device. 
     Copies from device memory to device memory. <tt>dstDevice</tt> and
     <tt>srcDevice</tt> are the base pointers of the destination and
     source, respectively. <tt>ByteCount</tt> specifies the number of bytes
     to copy. Note that this function is asynchronous.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>srcDevice</CODE> - Source device pointer<DD><CODE>ByteCount</CODE> - Size of memory copy in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><!-- --></A><H3>
cuMemcpyDtoA</H3>
<PRE>
public static int <B>cuMemcpyDtoA</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;dstArray,
                               long&nbsp;dstIndex,
                               <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
                               long&nbsp;ByteCount)</PRE>
<DL>
<DD>Copies memory from Device to Array.
 
 <pre>
 CUresult cuMemcpyDtoA (
      CUarray dstArray,
      size_t dstOffset,
      CUdeviceptr srcDevice,
      size_t ByteCount )
 </pre>
 <div>
   <p>Copies memory from Device to Array. 
     Copies from device memory to a 1D CUDA array. <tt>dstArray</tt> and
     <tt>dstOffset</tt> specify the CUDA array handle and starting index
     of the destination data. <tt>srcDevice</tt> specifies the base pointer
     of the source. <tt>ByteCount</tt> specifies the number of bytes to
     copy.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstArray</CODE> - Destination array<DD><CODE>dstOffset</CODE> - Offset in bytes of destination array<DD><CODE>srcDevice</CODE> - Source device pointer<DD><CODE>ByteCount</CODE> - Size of memory copy in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><!-- --></A><H3>
cuMemcpyAtoD</H3>
<PRE>
public static int <B>cuMemcpyAtoD</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                               <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hSrc,
                               long&nbsp;SrcIndex,
                               long&nbsp;ByteCount)</PRE>
<DL>
<DD>Copies memory from Array to Device.
 
 <pre>
 CUresult cuMemcpyAtoD (
      CUdeviceptr dstDevice,
      CUarray srcArray,
      size_t srcOffset,
      size_t ByteCount )
 </pre>
 <div>
   <p>Copies memory from Array to Device. 
     Copies from one 1D CUDA array to device memory. <tt>dstDevice</tt>
     specifies the base pointer of the destination and must be naturally
     aligned with the CUDA array elements. <tt>srcArray</tt> and <tt>srcOffset</tt> specify the CUDA array handle and the offset in bytes
     into the array where the copy is to begin. <tt>ByteCount</tt> specifies
     the number of bytes to copy and must be evenly divisible by the array
     element size.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>srcArray</CODE> - Source array<DD><CODE>srcOffset</CODE> - Offset in bytes of source array<DD><CODE>ByteCount</CODE> - Size of memory copy in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><!-- --></A><H3>
cuMemcpyHtoA</H3>
<PRE>
public static int <B>cuMemcpyHtoA</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;dstArray,
                               long&nbsp;dstIndex,
                               <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pSrc,
                               long&nbsp;ByteCount)</PRE>
<DL>
<DD>Copies memory from Host to Array.
 
 <pre>
 CUresult cuMemcpyHtoA (
      CUarray dstArray,
      size_t dstOffset,
      const void* srcHost,
      size_t ByteCount )
 </pre>
 <div>
   <p>Copies memory from Host to Array.  Copies
     from host memory to a 1D CUDA array. <tt>dstArray</tt> and <tt>dstOffset</tt> specify the CUDA array handle and starting offset in
     bytes of the destination data. <tt>pSrc</tt> specifies the base
     address of the source. <tt>ByteCount</tt> specifies the number of
     bytes to copy.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstArray</CODE> - Destination array<DD><CODE>dstOffset</CODE> - Offset in bytes of destination array<DD><CODE>srcHost</CODE> - Source host pointer<DD><CODE>ByteCount</CODE> - Size of memory copy in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><!-- --></A><H3>
cuMemcpyAtoH</H3>
<PRE>
public static int <B>cuMemcpyAtoH</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dstHost,
                               <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;srcArray,
                               long&nbsp;srcIndex,
                               long&nbsp;ByteCount)</PRE>
<DL>
<DD>Copies memory from Array to Host.
 
 <pre>
 CUresult cuMemcpyAtoH (
      void* dstHost,
      CUarray srcArray,
      size_t srcOffset,
      size_t ByteCount )
 </pre>
 <div>
   <p>Copies memory from Array to Host.  Copies
     from one 1D CUDA array to host memory. <tt>dstHost</tt> specifies the
     base pointer of the destination. <tt>srcArray</tt> and <tt>srcOffset</tt> specify the CUDA array handle and starting offset in
     bytes of the source data. <tt>ByteCount</tt> specifies the number of
     bytes to copy.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstHost</CODE> - Destination device pointer<DD><CODE>srcArray</CODE> - Source array<DD><CODE>srcOffset</CODE> - Offset in bytes of source array<DD><CODE>ByteCount</CODE> - Size of memory copy in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><!-- --></A><H3>
cuMemcpyAtoA</H3>
<PRE>
public static int <B>cuMemcpyAtoA</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;dstArray,
                               long&nbsp;dstIndex,
                               <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;srcArray,
                               long&nbsp;srcIndex,
                               long&nbsp;ByteCount)</PRE>
<DL>
<DD>Copies memory from Array to Array.
 
 <pre>
 CUresult cuMemcpyAtoA (
      CUarray dstArray,
      size_t dstOffset,
      CUarray srcArray,
      size_t srcOffset,
      size_t ByteCount )
 </pre>
 <div>
   <p>Copies memory from Array to Array. 
     Copies from one 1D CUDA array to another. <tt>dstArray</tt> and <tt>srcArray</tt> specify the handles of the destination and source CUDA
     arrays for the copy, respectively. <tt>dstOffset</tt> and <tt>srcOffset</tt> specify the destination and source offsets in bytes
     into the CUDA arrays. <tt>ByteCount</tt> is the number of bytes to be
     copied. The size of the elements in the CUDA arrays need not be the
     same format, but the elements
     must be the same size; and count must be
     evenly divisible by that size.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstArray</CODE> - Destination array<DD><CODE>dstOffset</CODE> - Offset in bytes of destination array<DD><CODE>srcArray</CODE> - Source array<DD><CODE>srcOffset</CODE> - Offset in bytes of source array<DD><CODE>ByteCount</CODE> - Size of memory copy in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><!-- --></A><H3>
cuMemcpy2D</H3>
<PRE>
public static int <B>cuMemcpy2D</B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY2D.html" title="class in jcuda.driver">CUDA_MEMCPY2D</A>&nbsp;pCopy)</PRE>
<DL>
<DD>Copies memory for 2D arrays.
 
 <pre>
 CUresult cuMemcpy2D (
      const CUDA_MEMCPY2D* pCopy )
 </pre>
 <div>
   <p>Copies memory for 2D arrays.  Perform a
     2D memory copy according to the parameters specified in <tt>pCopy</tt>.
     The CUDA_MEMCPY2D structure is defined as:
   </p>
   <pre>   typedef struct CUDA_MEMCPY2D_st {
       unsigned int srcXInBytes, srcY;
       CUmemorytype srcMemoryType;
           const void *srcHost;
           CUdeviceptr srcDevice;
           CUarray srcArray;
           unsigned int srcPitch;
 
       unsigned int dstXInBytes, dstY;
       CUmemorytype dstMemoryType;
           void *dstHost;
           CUdeviceptr dstDevice;
           CUarray dstArray;
           unsigned int dstPitch;
 
       unsigned int WidthInBytes;
       unsigned int Height;
    } CUDA_MEMCPY2D;</pre>
   where:
   <ul>
     <li>
       <p>srcMemoryType and dstMemoryType
         specify the type of memory of the source and destination, respectively;
         CUmemorytype_enum
         is defined as:
       </p>
     </li>
   </ul>
   </p>
   <pre>   typedef enum CUmemorytype_enum {
       CU_MEMORYTYPE_HOST = 0x01,
       CU_MEMORYTYPE_DEVICE = 0x02,
       CU_MEMORYTYPE_ARRAY = 0x03,
       CU_MEMORYTYPE_UNIFIED = 0x04
    } CUmemorytype;</pre>
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_UNIFIED,
     srcDevice and srcPitch specify the (unified virtual address space) base
     address of the source data and the bytes per row
     to apply. srcArray is ignored. This value
     may be used only if unified addressing is supported in the calling
     context.
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_HOST,
     srcHost and srcPitch specify the (host) base address of the source data
     and the bytes per row to apply. srcArray is ignored.
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_DEVICE,
     srcDevice and srcPitch specify the (device) base address of the source
     data and the bytes per row to apply. srcArray is
     ignored.
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_ARRAY,
     srcArray specifies the handle of the source data. srcHost, srcDevice
     and srcPitch are ignored.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_HOST,
     dstHost and dstPitch specify the (host) base address of the destination
     data and the bytes per row to apply. dstArray is
     ignored.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_UNIFIED,
     dstDevice and dstPitch specify the (unified virtual address space) base
     address of the source data and the bytes per row
     to apply. dstArray is ignored. This value
     may be used only if unified addressing is supported in the calling
     context.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_DEVICE,
     dstDevice and dstPitch specify the (device) base address of the
     destination data and the bytes per row to apply. dstArray
     is ignored.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_ARRAY,
     dstArray specifies the handle of the destination data. dstHost,
     dstDevice and dstPitch are ignored.
   </p>
   <ul>
     <li>
       <p>srcXInBytes and srcY specify
         the base address of the source data for the copy.
       </p>
     </li>
   </ul>
   </p>
   <p>For host pointers, the starting address
     is 
   <pre>  void* Start = (void*)((char*)srcHost+srcY*srcPitch +
 srcXInBytes);</pre>
   </p>
   <p>For device pointers, the starting
     address is 
   <pre>  CUdeviceptr Start =
 srcDevice+srcY*srcPitch+srcXInBytes;</pre>
   </p>
   <p>For CUDA arrays, srcXInBytes must be
     evenly divisible by the array element size.
   </p>
   <ul>
     <li>
       <p>dstXInBytes and dstY specify
         the base address of the destination data for the copy.
       </p>
     </li>
   </ul>
   </p>
   <p>For host pointers, the base address is
   <pre>  void* dstStart = (void*)((char*)dstHost+dstY*dstPitch +
 dstXInBytes);</pre>
   </p>
   <p>For device pointers, the starting
     address is 
   <pre>  CUdeviceptr dstStart =
 dstDevice+dstY*dstPitch+dstXInBytes;</pre>
   </p>
   <p>For CUDA arrays, dstXInBytes must be
     evenly divisible by the array element size.
   </p>
   <ul>
     <li>
       <p>WidthInBytes and Height specify
         the width (in bytes) and height of the 2D copy being performed.
       </p>
     </li>
     <li>
       <p>If specified, srcPitch must be
         greater than or equal to WidthInBytes + srcXInBytes, and dstPitch must
         be greater than or equal
         to WidthInBytes + dstXInBytes.
       </p>
     </li>
   </ul>
   </p>
   <p>cuMemcpy2D() returns an error if any
     pitch is greater than the maximum allowed (CU_DEVICE_ATTRIBUTE_MAX_PITCH).
     cuMemAllocPitch() passes back pitches that always work with cuMemcpy2D().
     On intra-device memory copies (device to device, CUDA array to device,
     CUDA array to CUDA array), cuMemcpy2D() may fail for pitches not
     computed by cuMemAllocPitch(). cuMemcpy2DUnaligned() does not have this
     restriction, but may run significantly slower in the cases where
     cuMemcpy2D() would have returned an error code.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCopy</CODE> - Parameters for the memory copy
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><!-- --></A><H3>
cuMemcpy2DUnaligned</H3>
<PRE>
public static int <B>cuMemcpy2DUnaligned</B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY2D.html" title="class in jcuda.driver">CUDA_MEMCPY2D</A>&nbsp;pCopy)</PRE>
<DL>
<DD>Copies memory for 2D arrays.
 
 <pre>
 CUresult cuMemcpy2DUnaligned (
      const CUDA_MEMCPY2D* pCopy )
 </pre>
 <div>
   <p>Copies memory for 2D arrays.  Perform a
     2D memory copy according to the parameters specified in <tt>pCopy</tt>.
     The CUDA_MEMCPY2D structure is defined as:
   </p>
   <pre>   typedef struct CUDA_MEMCPY2D_st {
       unsigned int srcXInBytes, srcY;
       CUmemorytype srcMemoryType;
       const void *srcHost;
       CUdeviceptr srcDevice;
       CUarray srcArray;
       unsigned int srcPitch;
       unsigned int dstXInBytes, dstY;
       CUmemorytype dstMemoryType;
       void *dstHost;
       CUdeviceptr dstDevice;
       CUarray dstArray;
       unsigned int dstPitch;
       unsigned int WidthInBytes;
       unsigned int Height;
    } CUDA_MEMCPY2D;</pre>
   where:
   <ul>
     <li>
       <p>srcMemoryType and dstMemoryType
         specify the type of memory of the source and destination, respectively;
         CUmemorytype_enum
         is defined as:
       </p>
     </li>
   </ul>
   </p>
   <pre>   typedef enum CUmemorytype_enum {
       CU_MEMORYTYPE_HOST = 0x01,
       CU_MEMORYTYPE_DEVICE = 0x02,
       CU_MEMORYTYPE_ARRAY = 0x03,
       CU_MEMORYTYPE_UNIFIED = 0x04
    } CUmemorytype;</pre>
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_UNIFIED,
     srcDevice and srcPitch specify the (unified virtual address space) base
     address of the source data and the bytes per row
     to apply. srcArray is ignored. This value
     may be used only if unified addressing is supported in the calling
     context.
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_HOST,
     srcHost and srcPitch specify the (host) base address of the source data
     and the bytes per row to apply. srcArray is ignored.
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_DEVICE,
     srcDevice and srcPitch specify the (device) base address of the source
     data and the bytes per row to apply. srcArray is
     ignored.
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_ARRAY,
     srcArray specifies the handle of the source data. srcHost, srcDevice
     and srcPitch are ignored.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_UNIFIED,
     dstDevice and dstPitch specify the (unified virtual address space) base
     address of the source data and the bytes per row
     to apply. dstArray is ignored. This value
     may be used only if unified addressing is supported in the calling
     context.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_HOST,
     dstHost and dstPitch specify the (host) base address of the destination
     data and the bytes per row to apply. dstArray is
     ignored.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_DEVICE,
     dstDevice and dstPitch specify the (device) base address of the
     destination data and the bytes per row to apply. dstArray
     is ignored.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_ARRAY,
     dstArray specifies the handle of the destination data. dstHost,
     dstDevice and dstPitch are ignored.
   </p>
   <ul>
     <li>
       <p>srcXInBytes and srcY specify
         the base address of the source data for the copy.
       </p>
     </li>
   </ul>
   </p>
   <p>For host pointers, the starting address
     is 
   <pre>  void* Start = (void*)((char*)srcHost+srcY*srcPitch +
 srcXInBytes);</pre>
   </p>
   <p>For device pointers, the starting
     address is 
   <pre>  CUdeviceptr Start =
 srcDevice+srcY*srcPitch+srcXInBytes;</pre>
   </p>
   <p>For CUDA arrays, srcXInBytes must be
     evenly divisible by the array element size.
   </p>
   <ul>
     <li>
       <p>dstXInBytes and dstY specify
         the base address of the destination data for the copy.
       </p>
     </li>
   </ul>
   </p>
   <p>For host pointers, the base address is
   <pre>  void* dstStart = (void*)((char*)dstHost+dstY*dstPitch +
 dstXInBytes);</pre>
   </p>
   <p>For device pointers, the starting
     address is 
   <pre>  CUdeviceptr dstStart =
 dstDevice+dstY*dstPitch+dstXInBytes;</pre>
   </p>
   <p>For CUDA arrays, dstXInBytes must be
     evenly divisible by the array element size.
   </p>
   <ul>
     <li>
       <p>WidthInBytes and Height specify
         the width (in bytes) and height of the 2D copy being performed.
       </p>
     </li>
     <li>
       <p>If specified, srcPitch must be
         greater than or equal to WidthInBytes + srcXInBytes, and dstPitch must
         be greater than or equal
         to WidthInBytes + dstXInBytes.
       </p>
     </li>
   </ul>
   </p>
   <p>cuMemcpy2D() returns an error if any
     pitch is greater than the maximum allowed (CU_DEVICE_ATTRIBUTE_MAX_PITCH).
     cuMemAllocPitch() passes back pitches that always work with cuMemcpy2D().
     On intra-device memory copies (device to device, CUDA array to device,
     CUDA array to CUDA array), cuMemcpy2D() may fail for pitches not
     computed by cuMemAllocPitch(). cuMemcpy2DUnaligned() does not have this
     restriction, but may run significantly slower in the cases where
     cuMemcpy2D() would have returned an error code.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCopy</CODE> - Parameters for the memory copy
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><!-- --></A><H3>
cuMemcpy3D</H3>
<PRE>
public static int <B>cuMemcpy3D</B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY3D.html" title="class in jcuda.driver">CUDA_MEMCPY3D</A>&nbsp;pCopy)</PRE>
<DL>
<DD>Copies memory for 3D arrays.
 
 <pre>
 CUresult cuMemcpy3D (
      const CUDA_MEMCPY3D* pCopy )
 </pre>
 <div>
   <p>Copies memory for 3D arrays.  Perform a
     3D memory copy according to the parameters specified in <tt>pCopy</tt>.
     The CUDA_MEMCPY3D structure is defined as:
   </p>
   <pre>        typedef struct CUDA_MEMCPY3D_st
 {
 
             unsigned int srcXInBytes, srcY, srcZ;
             unsigned int srcLOD;
             CUmemorytype srcMemoryType;
                 const void *srcHost;
                 CUdeviceptr srcDevice;
                 CUarray srcArray;
                 unsigned int srcPitch;  // ignored when src is array
                 unsigned int srcHeight; // ignored when src is array;
 may be 0 if Depth==1
 
             unsigned int dstXInBytes, dstY, dstZ;
             unsigned int dstLOD;
             CUmemorytype dstMemoryType;
                 void *dstHost;
                 CUdeviceptr dstDevice;
                 CUarray dstArray;
                 unsigned int dstPitch;  // ignored when dst is array
                 unsigned int dstHeight; // ignored when dst is array;
 may be 0 if Depth==1
 
             unsigned int WidthInBytes;
             unsigned int Height;
             unsigned int Depth;
         } CUDA_MEMCPY3D;</pre>
   where:
   <ul>
     <li>
       <p>srcMemoryType and dstMemoryType
         specify the type of memory of the source and destination, respectively;
         CUmemorytype_enum
         is defined as:
       </p>
     </li>
   </ul>
   </p>
   <pre>   typedef enum CUmemorytype_enum {
       CU_MEMORYTYPE_HOST = 0x01,
       CU_MEMORYTYPE_DEVICE = 0x02,
       CU_MEMORYTYPE_ARRAY = 0x03,
       CU_MEMORYTYPE_UNIFIED = 0x04
    } CUmemorytype;</pre>
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_UNIFIED,
     srcDevice and srcPitch specify the (unified virtual address space) base
     address of the source data and the bytes per row
     to apply. srcArray is ignored. This value
     may be used only if unified addressing is supported in the calling
     context.
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_HOST,
     srcHost, srcPitch and srcHeight specify the (host) base address of the
     source data, the bytes per row, and the height of
     each 2D slice of the 3D array. srcArray
     is ignored.
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_DEVICE,
     srcDevice, srcPitch and srcHeight specify the (device) base address of
     the source data, the bytes per row, and the height
     of each 2D slice of the 3D array. srcArray
     is ignored.
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_ARRAY,
     srcArray specifies the handle of the source data. srcHost, srcDevice,
     srcPitch and srcHeight are ignored.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_UNIFIED,
     dstDevice and dstPitch specify the (unified virtual address space) base
     address of the source data and the bytes per row
     to apply. dstArray is ignored. This value
     may be used only if unified addressing is supported in the calling
     context.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_HOST,
     dstHost and dstPitch specify the (host) base address of the destination
     data, the bytes per row, and the height of each
     2D slice of the 3D array. dstArray is
     ignored.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_DEVICE,
     dstDevice and dstPitch specify the (device) base address of the
     destination data, the bytes per row, and the height of each
     2D slice of the 3D array. dstArray is
     ignored.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_ARRAY,
     dstArray specifies the handle of the destination data. dstHost,
     dstDevice, dstPitch and dstHeight are ignored.
   </p>
   <ul>
     <li>
       <p>srcXInBytes, srcY and srcZ
         specify the base address of the source data for the copy.
       </p>
     </li>
   </ul>
   </p>
   <p>For host pointers, the starting address
     is 
   <pre>  void* Start = (void*)((char*)srcHost+(srcZ*srcHeight+srcY)*srcPitch
 + srcXInBytes);</pre>
   </p>
   <p>For device pointers, the starting
     address is 
   <pre>  CUdeviceptr Start =
 srcDevice+(srcZ*srcHeight+srcY)*srcPitch+srcXInBytes;</pre>
   </p>
   <p>For CUDA arrays, srcXInBytes must be
     evenly divisible by the array element size.
   </p>
   <ul>
     <li>
       <p>dstXInBytes, dstY and dstZ
         specify the base address of the destination data for the copy.
       </p>
     </li>
   </ul>
   </p>
   <p>For host pointers, the base address is
   <pre>  void* dstStart = (void*)((char*)dstHost+(dstZ*dstHeight+dstY)*dstPitch
 + dstXInBytes);</pre>
   </p>
   <p>For device pointers, the starting
     address is 
   <pre>  CUdeviceptr dstStart =
 dstDevice+(dstZ*dstHeight+dstY)*dstPitch+dstXInBytes;</pre>
   </p>
   <p>For CUDA arrays, dstXInBytes must be
     evenly divisible by the array element size.
   </p>
   <ul>
     <li>
       <p>WidthInBytes, Height and Depth
         specify the width (in bytes), height and depth of the 3D copy being
         performed.
       </p>
     </li>
     <li>
       <p>If specified, srcPitch must be
         greater than or equal to WidthInBytes + srcXInBytes, and dstPitch must
         be greater than or equal
         to WidthInBytes + dstXInBytes.
       </p>
     </li>
     <li>
       <p>If specified, srcHeight must
         be greater than or equal to Height + srcY, and dstHeight must be
         greater than or equal to Height
         + dstY.
       </p>
     </li>
   </ul>
   </p>
   <p>cuMemcpy3D() returns an error if any
     pitch is greater than the maximum allowed
     (CU_DEVICE_ATTRIBUTE_MAX_PITCH).
   </p>
   <p>
     The srcLOD and dstLOD members of the
     CUDA_MEMCPY3D structure must be set to 0.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCopy</CODE> - Parameters for the memory copy
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpy3DPeer(jcuda.driver.CUDA_MEMCPY3D_PEER)"><!-- --></A><H3>
cuMemcpy3DPeer</H3>
<PRE>
public static int <B>cuMemcpy3DPeer</B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY3D_PEER.html" title="class in jcuda.driver">CUDA_MEMCPY3D_PEER</A>&nbsp;pCopy)</PRE>
<DL>
<DD>Copies memory between contexts.
 
 <pre>
 CUresult cuMemcpy3DPeer (
      const CUDA_MEMCPY3D_PEER* pCopy )
 </pre>
 <div>
   <p>Copies memory between contexts.  Perform
     a 3D memory copy according to the parameters specified in <tt>pCopy</tt>. See the definition of the CUDA_MEMCPY3D_PEER structure
     for documentation of its parameters.
   </p>
   <p>Note that this function is synchronous
     with respect to the host only if the source or destination memory is
     of type CU_MEMORYTYPE_HOST. Note also that this copy is serialized with
     respect all pending and future asynchronous work in to the current
     context,
     the copy's source context, and the copy's
     destination context (use cuMemcpy3DPeerAsync to avoid this
     synchronization).
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCopy</CODE> - Parameters for the memory copy
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyPeer(jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, long)"><CODE>cuMemcpyPeer(jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyPeerAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, long, jcuda.driver.CUstream)"><CODE>cuMemcpyPeerAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DPeerAsync(jcuda.driver.CUDA_MEMCPY3D_PEER, jcuda.driver.CUstream)"><CODE>cuMemcpy3DPeerAsync(jcuda.driver.CUDA_MEMCPY3D_PEER, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemcpyAsync</H3>
<PRE>
public static int <B>cuMemcpyAsync</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dst,
                                <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;src,
                                long&nbsp;ByteCount,
                                <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Copies memory asynchronously.
 
 <pre>
 CUresult cuMemcpyAsync (
      CUdeviceptr dst,
      CUdeviceptr src,
      size_t ByteCount,
      CUstream hStream )
 </pre>
 <div>
   <p>Copies memory asynchronously.  Copies
     data between two pointers. <tt>dst</tt> and <tt>src</tt> are base
     pointers of the destination and source, respectively. <tt>ByteCount</tt>
     specifies the number of bytes to copy. Note that this function infers
     the type of the transfer (host to host, host to device,
     device to device, or device to host) from
     the pointer values. This function is only allowed in contexts which
     support unified
     addressing. Note that this function is
     asynchronous and can optionally be associated to a stream by passing a
     non-zero <tt>hStream</tt> argument
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination unified virtual address space pointer<DD><CODE>src</CODE> - Source unified virtual address space pointer<DD><CODE>ByteCount</CODE> - Size of memory copy in bytes<DD><CODE>hStream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyPeerAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, long, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemcpyPeerAsync</H3>
<PRE>
public static int <B>cuMemcpyPeerAsync</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                                    <A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;dstContext,
                                    <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
                                    <A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;srcContext,
                                    long&nbsp;ByteCount,
                                    <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Copies device memory between two contexts asynchronously.
 
 <pre>
 CUresult cuMemcpyPeerAsync (
      CUdeviceptr dstDevice,
      CUcontext dstContext,
      CUdeviceptr srcDevice,
      CUcontext srcContext,
      size_t ByteCount,
      CUstream hStream )
 </pre>
 <div>
   <p>Copies device memory between two contexts
     asynchronously.  Copies from device memory in one context to device
     memory in another
     context. <tt>dstDevice</tt> is the base
     device pointer of the destination memory and <tt>dstContext</tt> is
     the destination context. <tt>srcDevice</tt> is the base device pointer
     of the source memory and <tt>srcContext</tt> is the source pointer.
     <tt>ByteCount</tt> specifies the number of bytes to copy. Note that
     this function is asynchronous with respect to the host and all work in
     other
     streams in other devices.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>dstContext</CODE> - Destination context<DD><CODE>srcDevice</CODE> - Source device pointer<DD><CODE>srcContext</CODE> - Source context<DD><CODE>ByteCount</CODE> - Size of memory copy in bytes<DD><CODE>hStream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyPeer(jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, long)"><CODE>cuMemcpyPeer(jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DPeer(jcuda.driver.CUDA_MEMCPY3D_PEER)"><CODE>cuMemcpy3DPeer(jcuda.driver.CUDA_MEMCPY3D_PEER)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DPeerAsync(jcuda.driver.CUDA_MEMCPY3D_PEER, jcuda.driver.CUstream)"><CODE>cuMemcpy3DPeerAsync(jcuda.driver.CUDA_MEMCPY3D_PEER, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemcpyHtoDAsync</H3>
<PRE>
public static int <B>cuMemcpyHtoDAsync</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                                    <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;srcHost,
                                    long&nbsp;ByteCount,
                                    <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Copies memory from Host to Device.
 
 <pre>
 CUresult cuMemcpyHtoDAsync (
      CUdeviceptr dstDevice,
      const void* srcHost,
      size_t ByteCount,
      CUstream hStream )
 </pre>
 <div>
   <p>Copies memory from Host to Device. 
     Copies from host memory to device memory. <tt>dstDevice</tt> and <tt>srcHost</tt> are the base addresses of the destination and source,
     respectively. <tt>ByteCount</tt> specifies the number of bytes to
     copy.
   </p>
   <p>cuMemcpyHtoDAsync() is asynchronous and
     can optionally be associated to a stream by passing a non-zero <tt>hStream</tt> argument. It only works on page-locked memory and returns
     an error if a pointer to pageable memory is passed as input.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>srcHost</CODE> - Source host pointer<DD><CODE>ByteCount</CODE> - Size of memory copy in bytes<DD><CODE>hStream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemcpyDtoHAsync</H3>
<PRE>
public static int <B>cuMemcpyDtoHAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dstHost,
                                    <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
                                    long&nbsp;ByteCount,
                                    <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Copies memory from Device to Host.
 
 <pre>
 CUresult cuMemcpyDtoHAsync (
      void* dstHost,
      CUdeviceptr srcDevice,
      size_t ByteCount,
      CUstream hStream )
 </pre>
 <div>
   <p>Copies memory from Device to Host. 
     Copies from device to host memory. <tt>dstHost</tt> and <tt>srcDevice</tt> specify the base pointers of the destination and
     source, respectively. <tt>ByteCount</tt> specifies the number of bytes
     to copy.
   </p>
   <p>cuMemcpyDtoHAsync() is asynchronous and
     can optionally be associated to a stream by passing a non-zero <tt>hStream</tt> argument. It only works on page-locked memory and returns
     an error if a pointer to pageable memory is passed as input.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstHost</CODE> - Destination host pointer<DD><CODE>srcDevice</CODE> - Source device pointer<DD><CODE>ByteCount</CODE> - Size of memory copy in bytes<DD><CODE>hStream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemcpyDtoDAsync</H3>
<PRE>
public static int <B>cuMemcpyDtoDAsync</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                                    <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
                                    long&nbsp;ByteCount,
                                    <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Copies memory from Device to Device.
 
 <pre>
 CUresult cuMemcpyDtoDAsync (
      CUdeviceptr dstDevice,
      CUdeviceptr srcDevice,
      size_t ByteCount,
      CUstream hStream )
 </pre>
 <div>
   <p>Copies memory from Device to Device. 
     Copies from device memory to device memory. <tt>dstDevice</tt> and
     <tt>srcDevice</tt> are the base pointers of the destination and
     source, respectively. <tt>ByteCount</tt> specifies the number of bytes
     to copy. Note that this function is asynchronous and can optionally be
     associated to a stream
     by passing a non-zero <tt>hStream</tt>
     argument
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>srcDevice</CODE> - Source device pointer<DD><CODE>ByteCount</CODE> - Size of memory copy in bytes<DD><CODE>hStream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemcpyHtoAAsync</H3>
<PRE>
public static int <B>cuMemcpyHtoAAsync</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;dstArray,
                                    long&nbsp;dstIndex,
                                    <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pSrc,
                                    long&nbsp;ByteCount,
                                    <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Copies memory from Host to Array.
 
 <pre>
 CUresult cuMemcpyHtoAAsync (
      CUarray dstArray,
      size_t dstOffset,
      const void* srcHost,
      size_t ByteCount,
      CUstream hStream )
 </pre>
 <div>
   <p>Copies memory from Host to Array.  Copies
     from host memory to a 1D CUDA array. <tt>dstArray</tt> and <tt>dstOffset</tt> specify the CUDA array handle and starting offset in
     bytes of the destination data. <tt>srcHost</tt> specifies the base
     address of the source. <tt>ByteCount</tt> specifies the number of
     bytes to copy.
   </p>
   <p>cuMemcpyHtoAAsync() is asynchronous and
     can optionally be associated to a stream by passing a non-zero <tt>hStream</tt> argument. It only works on page-locked memory and returns
     an error if a pointer to pageable memory is passed as input.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstArray</CODE> - Destination array<DD><CODE>dstOffset</CODE> - Offset in bytes of destination array<DD><CODE>srcHost</CODE> - Source host pointer<DD><CODE>ByteCount</CODE> - Size of memory copy in bytes<DD><CODE>hStream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemcpyAtoHAsync</H3>
<PRE>
public static int <B>cuMemcpyAtoHAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dstHost,
                                    <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;srcArray,
                                    long&nbsp;srcIndex,
                                    long&nbsp;ByteCount,
                                    <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Copies memory from Array to Host.
 
 <pre>
 CUresult cuMemcpyAtoHAsync (
      void* dstHost,
      CUarray srcArray,
      size_t srcOffset,
      size_t ByteCount,
      CUstream hStream )
 </pre>
 <div>
   <p>Copies memory from Array to Host.  Copies
     from one 1D CUDA array to host memory. <tt>dstHost</tt> specifies the
     base pointer of the destination. <tt>srcArray</tt> and <tt>srcOffset</tt> specify the CUDA array handle and starting offset in
     bytes of the source data. <tt>ByteCount</tt> specifies the number of
     bytes to copy.
   </p>
   <p>cuMemcpyAtoHAsync() is asynchronous and
     can optionally be associated to a stream by passing a non-zero <tt>stream</tt> argument. It only works on page-locked host memory and
     returns an error if a pointer to pageable memory is passed as input.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstHost</CODE> - Destination pointer<DD><CODE>srcArray</CODE> - Source array<DD><CODE>srcOffset</CODE> - Offset in bytes of source array<DD><CODE>ByteCount</CODE> - Size of memory copy in bytes<DD><CODE>hStream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemcpy2DAsync</H3>
<PRE>
public static int <B>cuMemcpy2DAsync</B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY2D.html" title="class in jcuda.driver">CUDA_MEMCPY2D</A>&nbsp;pCopy,
                                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Copies memory for 2D arrays.
 
 <pre>
 CUresult cuMemcpy2DAsync (
      const CUDA_MEMCPY2D* pCopy,
      CUstream hStream )
 </pre>
 <div>
   <p>Copies memory for 2D arrays.  Perform a
     2D memory copy according to the parameters specified in <tt>pCopy</tt>.
     The CUDA_MEMCPY2D structure is defined as:
   </p>
   <pre>   typedef struct CUDA_MEMCPY2D_st {
       unsigned int srcXInBytes, srcY;
       CUmemorytype srcMemoryType;
       const void *srcHost;
       CUdeviceptr srcDevice;
       CUarray srcArray;
       unsigned int srcPitch;
       unsigned int dstXInBytes, dstY;
       CUmemorytype dstMemoryType;
       void *dstHost;
       CUdeviceptr dstDevice;
       CUarray dstArray;
       unsigned int dstPitch;
       unsigned int WidthInBytes;
       unsigned int Height;
    } CUDA_MEMCPY2D;</pre>
   where:
   <ul>
     <li>
       <p>srcMemoryType and dstMemoryType
         specify the type of memory of the source and destination, respectively;
         CUmemorytype_enum
         is defined as:
       </p>
     </li>
   </ul>
   </p>
   <pre>   typedef enum CUmemorytype_enum {
       CU_MEMORYTYPE_HOST = 0x01,
       CU_MEMORYTYPE_DEVICE = 0x02,
       CU_MEMORYTYPE_ARRAY = 0x03,
       CU_MEMORYTYPE_UNIFIED = 0x04
    } CUmemorytype;</pre>
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_HOST,
     srcHost and srcPitch specify the (host) base address of the source data
     and the bytes per row to apply. srcArray is ignored.
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_UNIFIED,
     srcDevice and srcPitch specify the (unified virtual address space) base
     address of the source data and the bytes per row
     to apply. srcArray is ignored. This value
     may be used only if unified addressing is supported in the calling
     context.
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_DEVICE,
     srcDevice and srcPitch specify the (device) base address of the source
     data and the bytes per row to apply. srcArray is
     ignored.
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_ARRAY,
     srcArray specifies the handle of the source data. srcHost, srcDevice
     and srcPitch are ignored.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_UNIFIED,
     dstDevice and dstPitch specify the (unified virtual address space) base
     address of the source data and the bytes per row
     to apply. dstArray is ignored. This value
     may be used only if unified addressing is supported in the calling
     context.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_HOST,
     dstHost and dstPitch specify the (host) base address of the destination
     data and the bytes per row to apply. dstArray is
     ignored.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_DEVICE,
     dstDevice and dstPitch specify the (device) base address of the
     destination data and the bytes per row to apply. dstArray
     is ignored.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_ARRAY,
     dstArray specifies the handle of the destination data. dstHost,
     dstDevice and dstPitch are ignored.
   </p>
   <ul>
     <li>
       <p>srcXInBytes and srcY specify
         the base address of the source data for the copy.
       </p>
     </li>
   </ul>
   </p>
   <p>For host pointers, the starting address
     is 
   <pre>  void* Start = (void*)((char*)srcHost+srcY*srcPitch +
 srcXInBytes);</pre>
   </p>
   <p>For device pointers, the starting
     address is 
   <pre>  CUdeviceptr Start =
 srcDevice+srcY*srcPitch+srcXInBytes;</pre>
   </p>
   <p>For CUDA arrays, srcXInBytes must be
     evenly divisible by the array element size.
   </p>
   <ul>
     <li>
       <p>dstXInBytes and dstY specify
         the base address of the destination data for the copy.
       </p>
     </li>
   </ul>
   </p>
   <p>For host pointers, the base address is
   <pre>  void* dstStart = (void*)((char*)dstHost+dstY*dstPitch +
 dstXInBytes);</pre>
   </p>
   <p>For device pointers, the starting
     address is 
   <pre>  CUdeviceptr dstStart =
 dstDevice+dstY*dstPitch+dstXInBytes;</pre>
   </p>
   <p>For CUDA arrays, dstXInBytes must be
     evenly divisible by the array element size.
   </p>
   <ul>
     <li>
       <p>WidthInBytes and Height specify
         the width (in bytes) and height of the 2D copy being performed.
       </p>
     </li>
     <li>
       <p>If specified, srcPitch must be
         greater than or equal to WidthInBytes + srcXInBytes, and dstPitch must
         be greater than or equal
         to WidthInBytes + dstXInBytes.
       </p>
     </li>
     <li>
       <p>If specified, srcPitch must be
         greater than or equal to WidthInBytes + srcXInBytes, and dstPitch must
         be greater than or equal
         to WidthInBytes + dstXInBytes.
       </p>
     </li>
     <li>
       <p>If specified, srcHeight must
         be greater than or equal to Height + srcY, and dstHeight must be
         greater than or equal to Height
         + dstY.
       </p>
     </li>
   </ul>
   </p>
   <p>cuMemcpy2D() returns an error if any
     pitch is greater than the maximum allowed (CU_DEVICE_ATTRIBUTE_MAX_PITCH).
     cuMemAllocPitch() passes back pitches that always work with cuMemcpy2D().
     On intra-device memory copies (device to device, CUDA array to device,
     CUDA array to CUDA array), cuMemcpy2D() may fail for pitches not
     computed by cuMemAllocPitch(). cuMemcpy2DUnaligned() does not have this
     restriction, but may run significantly slower in the cases where
     cuMemcpy2D() would have returned an error code.
   </p>
   <p>cuMemcpy2DAsync() is asynchronous and
     can optionally be associated to a stream by passing a non-zero <tt>hStream</tt> argument. It only works on page-locked host memory and
     returns an error if a pointer to pageable memory is passed as input.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCopy</CODE> - Parameters for the memory copy<DD><CODE>hStream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemcpy3DAsync</H3>
<PRE>
public static int <B>cuMemcpy3DAsync</B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY3D.html" title="class in jcuda.driver">CUDA_MEMCPY3D</A>&nbsp;pCopy,
                                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Copies memory for 3D arrays.
 
 <pre>
 CUresult cuMemcpy3DAsync (
      const CUDA_MEMCPY3D* pCopy,
      CUstream hStream )
 </pre>
 <div>
   <p>Copies memory for 3D arrays.  Perform a
     3D memory copy according to the parameters specified in <tt>pCopy</tt>.
     The CUDA_MEMCPY3D structure is defined as:
   </p>
   <pre>        typedef struct CUDA_MEMCPY3D_st
 {
 
             unsigned int srcXInBytes, srcY, srcZ;
             unsigned int srcLOD;
             CUmemorytype srcMemoryType;
                 const void *srcHost;
                 CUdeviceptr srcDevice;
                 CUarray srcArray;
                 unsigned int srcPitch;  // ignored when src is array
                 unsigned int srcHeight; // ignored when src is array;
 may be 0 if Depth==1
 
             unsigned int dstXInBytes, dstY, dstZ;
             unsigned int dstLOD;
             CUmemorytype dstMemoryType;
                 void *dstHost;
                 CUdeviceptr dstDevice;
                 CUarray dstArray;
                 unsigned int dstPitch;  // ignored when dst is array
                 unsigned int dstHeight; // ignored when dst is array;
 may be 0 if Depth==1
 
             unsigned int WidthInBytes;
             unsigned int Height;
             unsigned int Depth;
         } CUDA_MEMCPY3D;</pre>
   where:
   <ul>
     <li>
       <p>srcMemoryType and dstMemoryType
         specify the type of memory of the source and destination, respectively;
         CUmemorytype_enum
         is defined as:
       </p>
     </li>
   </ul>
   </p>
   <pre>   typedef enum CUmemorytype_enum {
       CU_MEMORYTYPE_HOST = 0x01,
       CU_MEMORYTYPE_DEVICE = 0x02,
       CU_MEMORYTYPE_ARRAY = 0x03,
       CU_MEMORYTYPE_UNIFIED = 0x04
    } CUmemorytype;</pre>
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_UNIFIED,
     srcDevice and srcPitch specify the (unified virtual address space) base
     address of the source data and the bytes per row
     to apply. srcArray is ignored. This value
     may be used only if unified addressing is supported in the calling
     context.
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_HOST,
     srcHost, srcPitch and srcHeight specify the (host) base address of the
     source data, the bytes per row, and the height of
     each 2D slice of the 3D array. srcArray
     is ignored.
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_DEVICE,
     srcDevice, srcPitch and srcHeight specify the (device) base address of
     the source data, the bytes per row, and the height
     of each 2D slice of the 3D array. srcArray
     is ignored.
   </p>
   <p>If srcMemoryType is CU_MEMORYTYPE_ARRAY,
     srcArray specifies the handle of the source data. srcHost, srcDevice,
     srcPitch and srcHeight are ignored.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_UNIFIED,
     dstDevice and dstPitch specify the (unified virtual address space) base
     address of the source data and the bytes per row
     to apply. dstArray is ignored. This value
     may be used only if unified addressing is supported in the calling
     context.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_HOST,
     dstHost and dstPitch specify the (host) base address of the destination
     data, the bytes per row, and the height of each
     2D slice of the 3D array. dstArray is
     ignored.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_DEVICE,
     dstDevice and dstPitch specify the (device) base address of the
     destination data, the bytes per row, and the height of each
     2D slice of the 3D array. dstArray is
     ignored.
   </p>
   <p>If dstMemoryType is CU_MEMORYTYPE_ARRAY,
     dstArray specifies the handle of the destination data. dstHost,
     dstDevice, dstPitch and dstHeight are ignored.
   </p>
   <ul>
     <li>
       <p>srcXInBytes, srcY and srcZ
         specify the base address of the source data for the copy.
       </p>
     </li>
   </ul>
   </p>
   <p>For host pointers, the starting address
     is 
   <pre>  void* Start = (void*)((char*)srcHost+(srcZ*srcHeight+srcY)*srcPitch
 + srcXInBytes);</pre>
   </p>
   <p>For device pointers, the starting
     address is 
   <pre>  CUdeviceptr Start =
 srcDevice+(srcZ*srcHeight+srcY)*srcPitch+srcXInBytes;</pre>
   </p>
   <p>For CUDA arrays, srcXInBytes must be
     evenly divisible by the array element size.
   </p>
   <ul>
     <li>
       <p>dstXInBytes, dstY and dstZ
         specify the base address of the destination data for the copy.
       </p>
     </li>
   </ul>
   </p>
   <p>For host pointers, the base address is
   <pre>  void* dstStart = (void*)((char*)dstHost+(dstZ*dstHeight+dstY)*dstPitch
 + dstXInBytes);</pre>
   </p>
   <p>For device pointers, the starting
     address is 
   <pre>  CUdeviceptr dstStart =
 dstDevice+(dstZ*dstHeight+dstY)*dstPitch+dstXInBytes;</pre>
   </p>
   <p>For CUDA arrays, dstXInBytes must be
     evenly divisible by the array element size.
   </p>
   <ul>
     <li>
       <p>WidthInBytes, Height and Depth
         specify the width (in bytes), height and depth of the 3D copy being
         performed.
       </p>
     </li>
     <li>
       <p>If specified, srcPitch must be
         greater than or equal to WidthInBytes + srcXInBytes, and dstPitch must
         be greater than or equal
         to WidthInBytes + dstXInBytes.
       </p>
     </li>
     <li>
       <p>If specified, srcHeight must
         be greater than or equal to Height + srcY, and dstHeight must be
         greater than or equal to Height
         + dstY.
       </p>
     </li>
   </ul>
   </p>
   <p>cuMemcpy3D() returns an error if any
     pitch is greater than the maximum allowed
     (CU_DEVICE_ATTRIBUTE_MAX_PITCH).
   </p>
   <p>cuMemcpy3DAsync() is asynchronous and
     can optionally be associated to a stream by passing a non-zero <tt>hStream</tt> argument. It only works on page-locked host memory and
     returns an error if a pointer to pageable memory is passed as input.
   </p>
   <p>The srcLOD and dstLOD members of the
     CUDA_MEMCPY3D structure must be set to 0.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCopy</CODE> - Parameters for the memory copy<DD><CODE>hStream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpy3DPeerAsync(jcuda.driver.CUDA_MEMCPY3D_PEER, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemcpy3DPeerAsync</H3>
<PRE>
public static int <B>cuMemcpy3DPeerAsync</B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY3D_PEER.html" title="class in jcuda.driver">CUDA_MEMCPY3D_PEER</A>&nbsp;pCopy,
                                      <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Copies memory between contexts asynchronously.
 
 <pre>
 CUresult cuMemcpy3DPeerAsync (
      const CUDA_MEMCPY3D_PEER* pCopy,
      CUstream hStream )
 </pre>
 <div>
   <p>Copies memory between contexts
     asynchronously.  Perform a 3D memory copy according to the parameters
     specified in <tt>pCopy</tt>. See the definition of the CUDA_MEMCPY3D_PEER
     structure for documentation of its parameters.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCopy</CODE> - Parameters for the memory copy<DD><CODE>hStream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyPeer(jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, long)"><CODE>cuMemcpyPeer(jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyPeerAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, long, jcuda.driver.CUstream)"><CODE>cuMemcpyPeerAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, jcuda.driver.CUdeviceptr, jcuda.driver.CUcontext, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DPeerAsync(jcuda.driver.CUDA_MEMCPY3D_PEER, jcuda.driver.CUstream)"><CODE>cuMemcpy3DPeerAsync(jcuda.driver.CUDA_MEMCPY3D_PEER, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><!-- --></A><H3>
cuMemsetD8</H3>
<PRE>
public static int <B>cuMemsetD8</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                             byte&nbsp;uc,
                             long&nbsp;N)</PRE>
<DL>
<DD>Initializes device memory.
 
 <pre>
 CUresult cuMemsetD8 (
      CUdeviceptr dstDevice,
      unsigned char  uc,
      size_t N )
 </pre>
 <div>
   <p>Initializes device memory.  Sets the
     memory range of <tt>N</tt> 8-bit values to the specified value <tt>uc</tt>.
   </p>
   <p>Note that this function is asynchronous
     with respect to the host unless <tt>dstDevice</tt> refers to pinned
     host memory.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>uc</CODE> - Value to set<DD><CODE>N</CODE> - Number of elements
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><!-- --></A><H3>
cuMemsetD16</H3>
<PRE>
public static int <B>cuMemsetD16</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                              short&nbsp;us,
                              long&nbsp;N)</PRE>
<DL>
<DD>Initializes device memory.
 
 <pre>
 CUresult cuMemsetD16 (
      CUdeviceptr dstDevice,
      unsigned short us,
      size_t N )
 </pre>
 <div>
   <p>Initializes device memory.  Sets the
     memory range of <tt>N</tt> 16-bit values to the specified value <tt>us</tt>. The <tt>dstDevice</tt> pointer must be two byte aligned.
   </p>
   <p>Note that this function is asynchronous
     with respect to the host unless <tt>dstDevice</tt> refers to pinned
     host memory.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>us</CODE> - Value to set<DD><CODE>N</CODE> - Number of elements
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><!-- --></A><H3>
cuMemsetD32</H3>
<PRE>
public static int <B>cuMemsetD32</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                              int&nbsp;ui,
                              long&nbsp;N)</PRE>
<DL>
<DD>Initializes device memory.
 
 <pre>
 CUresult cuMemsetD32 (
      CUdeviceptr dstDevice,
      unsigned int  ui,
      size_t N )
 </pre>
 <div>
   <p>Initializes device memory.  Sets the
     memory range of <tt>N</tt> 32-bit values to the specified value <tt>ui</tt>. The <tt>dstDevice</tt> pointer must be four byte aligned.
   </p>
   <p>Note that this function is asynchronous
     with respect to the host unless <tt>dstDevice</tt> refers to pinned
     host memory.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>ui</CODE> - Value to set<DD><CODE>N</CODE> - Number of elements
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><!-- --></A><H3>
cuMemsetD2D8</H3>
<PRE>
public static int <B>cuMemsetD2D8</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                               long&nbsp;dstPitch,
                               byte&nbsp;uc,
                               long&nbsp;Width,
                               long&nbsp;Height)</PRE>
<DL>
<DD>Initializes device memory.
 
 <pre>
 CUresult cuMemsetD2D8 (
      CUdeviceptr dstDevice,
      size_t dstPitch,
      unsigned char  uc,
      size_t Width,
      size_t Height )
 </pre>
 <div>
   <p>Initializes device memory.  Sets the 2D
     memory range of <tt>Width</tt> 8-bit values to the specified value
     <tt>uc</tt>. <tt>Height</tt> specifies the number of rows to set,
     and <tt>dstPitch</tt> specifies the number of bytes between each row.
     This function performs fastest when the pitch is one that has been
     passed
     back by cuMemAllocPitch().
   </p>
   <p>Note that this function is asynchronous
     with respect to the host unless <tt>dstDevice</tt> refers to pinned
     host memory.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>dstPitch</CODE> - Pitch of destination device pointer<DD><CODE>uc</CODE> - Value to set<DD><CODE>Width</CODE> - Width of row<DD><CODE>Height</CODE> - Number of rows
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><!-- --></A><H3>
cuMemsetD2D16</H3>
<PRE>
public static int <B>cuMemsetD2D16</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                                long&nbsp;dstPitch,
                                short&nbsp;us,
                                long&nbsp;Width,
                                long&nbsp;Height)</PRE>
<DL>
<DD>Initializes device memory.
 
 <pre>
 CUresult cuMemsetD2D16 (
      CUdeviceptr dstDevice,
      size_t dstPitch,
      unsigned short us,
      size_t Width,
      size_t Height )
 </pre>
 <div>
   <p>Initializes device memory.  Sets the 2D
     memory range of <tt>Width</tt> 16-bit values to the specified value
     <tt>us</tt>. <tt>Height</tt> specifies the number of rows to set,
     and <tt>dstPitch</tt> specifies the number of bytes between each row.
     The <tt>dstDevice</tt> pointer and <tt>dstPitch</tt> offset must be
     two byte aligned. This function performs fastest when the pitch is one
     that has been passed back by cuMemAllocPitch().
   </p>
   <p>Note that this function is asynchronous
     with respect to the host unless <tt>dstDevice</tt> refers to pinned
     host memory.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>dstPitch</CODE> - Pitch of destination device pointer<DD><CODE>us</CODE> - Value to set<DD><CODE>Width</CODE> - Width of row<DD><CODE>Height</CODE> - Number of rows
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><!-- --></A><H3>
cuMemsetD2D32</H3>
<PRE>
public static int <B>cuMemsetD2D32</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                                long&nbsp;dstPitch,
                                int&nbsp;ui,
                                long&nbsp;Width,
                                long&nbsp;Height)</PRE>
<DL>
<DD>Initializes device memory.
 
 <pre>
 CUresult cuMemsetD2D32 (
      CUdeviceptr dstDevice,
      size_t dstPitch,
      unsigned int  ui,
      size_t Width,
      size_t Height )
 </pre>
 <div>
   <p>Initializes device memory.  Sets the 2D
     memory range of <tt>Width</tt> 32-bit values to the specified value
     <tt>ui</tt>. <tt>Height</tt> specifies the number of rows to set,
     and <tt>dstPitch</tt> specifies the number of bytes between each row.
     The <tt>dstDevice</tt> pointer and <tt>dstPitch</tt> offset must be
     four byte aligned. This function performs fastest when the pitch is
     one that has been passed back by cuMemAllocPitch().
   </p>
   <p>Note that this function is asynchronous
     with respect to the host unless <tt>dstDevice</tt> refers to pinned
     host memory.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>dstPitch</CODE> - Pitch of destination device pointer<DD><CODE>ui</CODE> - Value to set<DD><CODE>Width</CODE> - Width of row<DD><CODE>Height</CODE> - Number of rows
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemsetD8Async</H3>
<PRE>
public static int <B>cuMemsetD8Async</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                                  byte&nbsp;uc,
                                  long&nbsp;N,
                                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Sets device memory.
 
 <pre>
 CUresult cuMemsetD8Async (
      CUdeviceptr dstDevice,
      unsigned char  uc,
      size_t N,
      CUstream hStream )
 </pre>
 <div>
   <p>Sets device memory.  Sets the memory
     range of <tt>N</tt> 8-bit values to the specified value <tt>uc</tt>.
   </p>
   <p>cuMemsetD8Async() is asynchronous and
     can optionally be associated to a stream by passing a non-zero <tt>stream</tt> argument.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>uc</CODE> - Value to set<DD><CODE>N</CODE> - Number of elements<DD><CODE>hStream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemsetD16Async</H3>
<PRE>
public static int <B>cuMemsetD16Async</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                                   short&nbsp;us,
                                   long&nbsp;N,
                                   <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Sets device memory.
 
 <pre>
 CUresult cuMemsetD16Async (
      CUdeviceptr dstDevice,
      unsigned short us,
      size_t N,
      CUstream hStream )
 </pre>
 <div>
   <p>Sets device memory.  Sets the memory
     range of <tt>N</tt> 16-bit values to the specified value <tt>us</tt>.
     The <tt>dstDevice</tt> pointer must be two byte aligned.
   </p>
   <p>cuMemsetD16Async() is asynchronous and
     can optionally be associated to a stream by passing a non-zero <tt>stream</tt> argument.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>us</CODE> - Value to set<DD><CODE>N</CODE> - Number of elements<DD><CODE>hStream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemsetD32Async</H3>
<PRE>
public static int <B>cuMemsetD32Async</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                                   int&nbsp;ui,
                                   long&nbsp;N,
                                   <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Sets device memory.
 
 <pre>
 CUresult cuMemsetD32Async (
      CUdeviceptr dstDevice,
      unsigned int  ui,
      size_t N,
      CUstream hStream )
 </pre>
 <div>
   <p>Sets device memory.  Sets the memory
     range of <tt>N</tt> 32-bit values to the specified value <tt>ui</tt>.
     The <tt>dstDevice</tt> pointer must be four byte aligned.
   </p>
   <p>cuMemsetD32Async() is asynchronous and
     can optionally be associated to a stream by passing a non-zero <tt>stream</tt> argument.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>ui</CODE> - Value to set<DD><CODE>N</CODE> - Number of elements<DD><CODE>hStream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemsetD2D8Async</H3>
<PRE>
public static int <B>cuMemsetD2D8Async</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                                    long&nbsp;dstPitch,
                                    byte&nbsp;uc,
                                    long&nbsp;Width,
                                    long&nbsp;Height,
                                    <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Sets device memory.
 
 <pre>
 CUresult cuMemsetD2D8Async (
      CUdeviceptr dstDevice,
      size_t dstPitch,
      unsigned char  uc,
      size_t Width,
      size_t Height,
      CUstream hStream )
 </pre>
 <div>
   <p>Sets device memory.  Sets the 2D memory
     range of <tt>Width</tt> 8-bit values to the specified value <tt>uc</tt>. <tt>Height</tt> specifies the number of rows to set, and
     <tt>dstPitch</tt> specifies the number of bytes between each row. This
     function performs fastest when the pitch is one that has been passed
     back by cuMemAllocPitch().
   </p>
   <p>cuMemsetD2D8Async() is asynchronous and
     can optionally be associated to a stream by passing a non-zero <tt>stream</tt> argument.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>dstPitch</CODE> - Pitch of destination device pointer<DD><CODE>uc</CODE> - Value to set<DD><CODE>Width</CODE> - Width of row<DD><CODE>Height</CODE> - Number of rows<DD><CODE>hStream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemsetD2D16Async</H3>
<PRE>
public static int <B>cuMemsetD2D16Async</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                                     long&nbsp;dstPitch,
                                     short&nbsp;us,
                                     long&nbsp;Width,
                                     long&nbsp;Height,
                                     <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Sets device memory.
 
 <pre>
 CUresult cuMemsetD2D16Async (
      CUdeviceptr dstDevice,
      size_t dstPitch,
      unsigned short us,
      size_t Width,
      size_t Height,
      CUstream hStream )
 </pre>
 <div>
   <p>Sets device memory.  Sets the 2D memory
     range of <tt>Width</tt> 16-bit values to the specified value <tt>us</tt>. <tt>Height</tt> specifies the number of rows to set, and
     <tt>dstPitch</tt> specifies the number of bytes between each row. The
     <tt>dstDevice</tt> pointer and <tt>dstPitch</tt> offset must be two
     byte aligned. This function performs fastest when the pitch is one that
     has been passed back by cuMemAllocPitch().
   </p>
   <p>cuMemsetD2D16Async() is asynchronous
     and can optionally be associated to a stream by passing a non-zero <tt>stream</tt> argument.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>dstPitch</CODE> - Pitch of destination device pointer<DD><CODE>us</CODE> - Value to set<DD><CODE>Width</CODE> - Width of row<DD><CODE>Height</CODE> - Number of rows<DD><CODE>hStream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD2D32Async(jcuda.driver.CUdeviceptr, long, int, long, long, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemsetD2D32Async</H3>
<PRE>
public static int <B>cuMemsetD2D32Async</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                                     long&nbsp;dstPitch,
                                     int&nbsp;ui,
                                     long&nbsp;Width,
                                     long&nbsp;Height,
                                     <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Sets device memory.
 
 <pre>
 CUresult cuMemsetD2D32Async (
      CUdeviceptr dstDevice,
      size_t dstPitch,
      unsigned int  ui,
      size_t Width,
      size_t Height,
      CUstream hStream )
 </pre>
 <div>
   <p>Sets device memory.  Sets the 2D memory
     range of <tt>Width</tt> 32-bit values to the specified value <tt>ui</tt>. <tt>Height</tt> specifies the number of rows to set, and
     <tt>dstPitch</tt> specifies the number of bytes between each row. The
     <tt>dstDevice</tt> pointer and <tt>dstPitch</tt> offset must be four
     byte aligned. This function performs fastest when the pitch is one that
     has been passed back by cuMemAllocPitch().
   </p>
   <p>cuMemsetD2D32Async() is asynchronous
     and can optionally be associated to a stream by passing a non-zero <tt>stream</tt> argument.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstDevice</CODE> - Destination device pointer<DD><CODE>dstPitch</CODE> - Pitch of destination device pointer<DD><CODE>ui</CODE> - Value to set<DD><CODE>Width</CODE> - Width of row<DD><CODE>Height</CODE> - Number of rows<DD><CODE>hStream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D8Async(jcuda.driver.CUdeviceptr, long, byte, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)"><CODE>cuMemsetD2D16Async(jcuda.driver.CUdeviceptr, long, short, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)"><CODE>cuMemsetD8Async(jcuda.driver.CUdeviceptr, byte, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)"><CODE>cuMemsetD16Async(jcuda.driver.CUdeviceptr, short, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)"><CODE>cuMemsetD32Async(jcuda.driver.CUdeviceptr, int, long, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)"><!-- --></A><H3>
cuFuncGetAttribute</H3>
<PRE>
public static int <B>cuFuncGetAttribute</B>(int[]&nbsp;pi,
                                     int&nbsp;attrib,
                                     <A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;func)</PRE>
<DL>
<DD>Returns information about a function.
 
 <pre>
 CUresult cuFuncGetAttribute (
      int* pi,
      CUfunction_attribute attrib,
      CUfunction hfunc )
 </pre>
 <div>
   <p>Returns information about a function. 
     Returns in <tt>*pi</tt> the integer value of the attribute <tt>attrib</tt> on the kernel given by <tt>hfunc</tt>. The supported
     attributes are:
   <ul>
     <li>
       <p>CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK:
         The maximum number of threads per block, beyond which a launch of the
         function would fail. This number depends on both the
         function and the device on which
         the function is currently loaded.
       </p>
     </li>
     <li>
       <p>CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES:
         The size in bytes of statically-allocated shared memory per block
         required by this function. This does not include dynamically-allocated
         shared memory requested by the
         user at runtime.
       </p>
     </li>
     <li>
       <p>CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES:
         The size in bytes of user-allocated constant memory required by this
         function.
       </p>
     </li>
     <li>
       <p>CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES:
         The size in bytes of local memory used by each thread of this
         function.
       </p>
     </li>
     <li>
       <p>CU_FUNC_ATTRIBUTE_NUM_REGS:
         The number of registers used by each thread of this function.
       </p>
     </li>
     <li>
       <p>CU_FUNC_ATTRIBUTE_PTX_VERSION:
         The PTX virtual architecture version for which the function was
         compiled. This value is the major PTX version * 10 + the
         minor PTX version, so a PTX
         version 1.3 function would return the value 13. Note that this may
         return the undefined value
         of 0 for cubins compiled prior
         to CUDA 3.0.
       </p>
     </li>
     <li>
       <p>CU_FUNC_ATTRIBUTE_BINARY_VERSION:
         The binary architecture version for which the function was compiled.
         This value is the major binary version * 10 + the minor
         binary version, so a binary
         version 1.3 function would return the value 13. Note that this will
         return a value of 10 for legacy
         cubins that do not have a
         properly-encoded binary architecture version.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pi</CODE> - Returned attribute value<DD><CODE>attrib</CODE> - Attribute requested<DD><CODE>hfunc</CODE> - Function to query attribute of
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])"><CODE>cuCtxGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCacheConfig(int)"><CODE>cuCtxSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)"><CODE>cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><!-- --></A><H3>
cuFuncSetBlockShape</H3>
<PRE>
public static int <B>cuFuncSetBlockShape</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                                      int&nbsp;x,
                                      int&nbsp;y,
                                      int&nbsp;z)</PRE>
<DL>
<DD>Sets the block-dimensions for the function.
 
 <pre>
 CUresult cuFuncSetBlockShape (
      CUfunction hfunc,
      int  x,
      int  y,
      int  z )
 </pre>
 <div>
   <p>Sets the block-dimensions for the
     function.  
     DeprecatedSpecifies the <tt>x</tt>, <tt>y</tt>, and <tt>z</tt> dimensions of the thread blocks that are
     created when the kernel given by <tt>hfunc</tt> is launched.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hfunc</CODE> - Kernel to specify dimensions of<DD><CODE>x</CODE> - X dimension<DD><CODE>y</CODE> - Y dimension<DD><CODE>z</CODE> - Z dimension
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetSharedSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)"><CODE>cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)"><CODE>cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)"><CODE>cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><!-- --></A><H3>
cuFuncSetSharedSize</H3>
<PRE>
public static int <B>cuFuncSetSharedSize</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                                      int&nbsp;bytes)</PRE>
<DL>
<DD>Sets the dynamic shared-memory size for the function.
 
 <pre>
 CUresult cuFuncSetSharedSize (
      CUfunction hfunc,
      unsigned int  bytes )
 </pre>
 <div>
   <p>Sets the dynamic shared-memory size for
     the function.  
     DeprecatedSets through <tt>bytes</tt>
     the amount of dynamic shared memory that will be available to each
     thread block when the kernel given by <tt>hfunc</tt> is launched.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hfunc</CODE> - Kernel to specify dynamic shared-memory size for<DD><CODE>bytes</CODE> - Dynamic shared-memory size per thread in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)"><CODE>cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)"><CODE>cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)"><CODE>cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)"><!-- --></A><H3>
cuFuncSetCacheConfig</H3>
<PRE>
public static int <B>cuFuncSetCacheConfig</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                                       int&nbsp;config)</PRE>
<DL>
<DD>Sets the preferred cache configuration for a device function.
 
 <pre>
 CUresult cuFuncSetCacheConfig (
      CUfunction hfunc,
      CUfunc_cache config )
 </pre>
 <div>
   <p>Sets the preferred cache configuration
     for a device function.  On devices where the L1 cache and shared memory
     use the same
     hardware resources, this sets through
     <tt>config</tt> the preferred cache configuration for the device
     function <tt>hfunc</tt>. This is only a preference. The driver will
     use the requested configuration if possible, but it is free to choose
     a different
     configuration if required to execute <tt>hfunc</tt>. Any context-wide preference set via cuCtxSetCacheConfig()
     will be overridden by this per-function setting unless the per-function
     setting is CU_FUNC_CACHE_PREFER_NONE. In that case, the current
     context-wide setting will be used.
   </p>
   <p>This setting does nothing on devices
     where the size of the L1 cache and shared memory are fixed.
   </p>
   <p>Launching a kernel with a different
     preference than the most recent preference setting may insert a
     device-side synchronization
     point.
   </p>
   <p>The supported cache configurations are:
   <ul>
     <li>
       <p>CU_FUNC_CACHE_PREFER_NONE: no
         preference for shared memory or L1 (default)
       </p>
     </li>
     <li>
       <p>CU_FUNC_CACHE_PREFER_SHARED:
         prefer larger shared memory and smaller L1 cache
       </p>
     </li>
     <li>
       <p>CU_FUNC_CACHE_PREFER_L1: prefer
         larger L1 cache and smaller shared memory
       </p>
     </li>
     <li>
       <p>CU_FUNC_CACHE_PREFER_EQUAL:
         prefer equal sized L1 cache and shared memory
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hfunc</CODE> - Kernel to configure cache for<DD><CODE>config</CODE> - Requested cache configuration
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_DEINITIALIZED,
 CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])"><CODE>cuCtxGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCacheConfig(int)"><CODE>cuCtxSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)"><CODE>cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)"><CODE>cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuFuncSetSharedMemConfig(jcuda.driver.CUfunction, int)"><!-- --></A><H3>
cuFuncSetSharedMemConfig</H3>
<PRE>
public static int <B>cuFuncSetSharedMemConfig</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                                           int&nbsp;config)</PRE>
<DL>
<DD>Sets the shared memory configuration for a device function.
 
 <pre>
 CUresult cuFuncSetSharedMemConfig (
      CUfunction hfunc,
      CUsharedconfig config )
 </pre>
 <div>
   <p>Sets the shared memory configuration for
     a device function.  On devices with configurable shared memory banks,
     this function
     will force all subsequent launches of
     the specified device function to have the given shared memory bank size
     configuration.
     On any given launch of the function, the
     shared memory configuration of the device will be temporarily changed
     if needed to
     suit the function's preferred
     configuration. Changes in shared memory configuration between subsequent
     launches of functions,
     may introduce a device side synchronization
     point.
   </p>
   <p>Any per-function setting of shared
     memory bank size set via cuFuncSetSharedMemConfig will override the
     context wide setting set with cuCtxSetSharedMemConfig.
   </p>
   <p>Changing the shared memory bank size
     will not increase shared memory usage or affect occupancy of kernels,
     but may have major
     effects on performance. Larger bank sizes
     will allow for greater potential bandwidth to shared memory, but will
     change what
     kinds of accesses to shared memory will
     result in bank conflicts.
   </p>
   <p>This function will do nothing on devices
     with fixed shared memory bank size.
   </p>
   <p>The supported bank configurations are:
   <ul>
     <li>
       <p>CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE:
         use the context's shared memory configuration when launching this
         function.
       </p>
     </li>
     <li>
       <p>CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE: set shared memory bank width
         to be natively four bytes when launching this function.
       </p>
     </li>
     <li>
       <p>CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE: set shared memory bank
         width to be natively eight bytes when launching this function.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hfunc</CODE> - kernel to be given a shared memory config<DD><CODE>config</CODE> - requested shared memory configuration
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_DEINITIALIZED,
 CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])"><CODE>cuCtxGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCacheConfig(int)"><CODE>cuCtxSetCacheConfig(int)</CODE></A>, 
<CODE>JCudaDriver#cuCtxGetSharedMemConfigcuCtxSetSharedMemConfigcuFuncGetAttribute</CODE>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)"><CODE>cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><!-- --></A><H3>
cuArrayCreate</H3>
<PRE>
public static int <B>cuArrayCreate</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;pHandle,
                                <A HREF="../../jcuda/driver/CUDA_ARRAY_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY_DESCRIPTOR</A>&nbsp;pAllocateArray)</PRE>
<DL>
<DD>Creates a 1D or 2D CUDA array.
 
 <pre>
 CUresult cuArrayCreate (
      CUarray* pHandle,
      const CUDA_ARRAY_DESCRIPTOR* pAllocateArray )
 </pre>
 <div>
   <p>Creates a 1D or 2D CUDA array.  Creates
     a CUDA array according to the CUDA_ARRAY_DESCRIPTOR structure <tt>pAllocateArray</tt> and returns a handle to the new CUDA array in <tt>*pHandle</tt>. The CUDA_ARRAY_DESCRIPTOR is defined as:
   </p>
   <pre>    typedef struct {
         unsigned int Width;
         unsigned int Height;
         CUarray_format Format;
         unsigned int NumChannels;
     } CUDA_ARRAY_DESCRIPTOR;</pre>
   where:</p>
   <ul>
     <li>
       <p><tt>Width</tt>, and <tt>Height</tt> are the width, and height of the CUDA array (in elements);
         the CUDA array is one-dimensional if height is 0, two-dimensional
         otherwise;
       </p>
     </li>
     <li>
       <div>
         Format specifies the format
         of the elements; CUarray_format is defined as: 
         <pre>    typedef enum
 CUarray_format_enum {
         CU_AD_FORMAT_UNSIGNED_INT8 = 0x01,
         CU_AD_FORMAT_UNSIGNED_INT16 = 0x02,
         CU_AD_FORMAT_UNSIGNED_INT32 = 0x03,
         CU_AD_FORMAT_SIGNED_INT8 = 0x08,
         CU_AD_FORMAT_SIGNED_INT16 = 0x09,
         CU_AD_FORMAT_SIGNED_INT32 = 0x0a,
         CU_AD_FORMAT_HALF = 0x10,
         CU_AD_FORMAT_FLOAT = 0x20
     } CUarray_format;</pre>
       </div>
     </li>
     <li>
       <p><tt>NumChannels</tt> specifies
         the number of packed components per CUDA array element; it may be 1,
         2, or 4;
       </p>
     </li>
   </ul>
   </p>
   <p>Here are examples of CUDA array
     descriptions:
   </p>
   <p>Description for a CUDA array of 2048
     floats: 
   <pre>    CUDA_ARRAY_DESCRIPTOR desc;
     desc.Format = CU_AD_FORMAT_FLOAT;
     desc.NumChannels = 1;
     desc.Width = 2048;
     desc.Height = 1;</pre>
   </p>
   <p>Description for a 64 x 64 CUDA array of
     floats: 
   <pre>    CUDA_ARRAY_DESCRIPTOR desc;
     desc.Format = CU_AD_FORMAT_FLOAT;
     desc.NumChannels = 1;
     desc.Width = 64;
     desc.Height = 64;</pre>
   </p>
   <p>Description for a <tt>width</tt> x <tt>height</tt> CUDA array of 64-bit, 4x16-bit float16's: 
   <pre>   
 CUDA_ARRAY_DESCRIPTOR desc;
     desc.FormatFlags = CU_AD_FORMAT_HALF;
     desc.NumChannels = 4;
     desc.Width = width;
     desc.Height = height;</pre>
   </p>
   <p>Description for a <tt>width</tt> x <tt>height</tt> CUDA array of 16-bit elements, each of which is two 8-bit
     unsigned chars: 
   <pre>    CUDA_ARRAY_DESCRIPTOR arrayDesc;
     desc.FormatFlags = CU_AD_FORMAT_UNSIGNED_INT8;
     desc.NumChannels = 2;
     desc.Width = width;
     desc.Height = height;</pre>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pHandle</CODE> - Returned array<DD><CODE>pAllocateArray</CODE> - Array descriptor
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_OUT_OF_MEMORY, CUDA_ERROR_UNKNOWN<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><!-- --></A><H3>
cuArrayGetDescriptor</H3>
<PRE>
public static int <B>cuArrayGetDescriptor</B>(<A HREF="../../jcuda/driver/CUDA_ARRAY_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY_DESCRIPTOR</A>&nbsp;pArrayDescriptor,
                                       <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray)</PRE>
<DL>
<DD>Get a 1D or 2D CUDA array descriptor.
 
 <pre>
 CUresult cuArrayGetDescriptor (
      CUDA_ARRAY_DESCRIPTOR* pArrayDescriptor,
      CUarray hArray )
 </pre>
 <div>
   <p>Get a 1D or 2D CUDA array descriptor. 
     Returns in <tt>*pArrayDescriptor</tt> a descriptor containing
     information on the format and dimensions of the CUDA array <tt>hArray</tt>. It is useful for subroutines that have been passed a CUDA
     array, but need to know the CUDA array parameters for validation
     or other purposes.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pArrayDescriptor</CODE> - Returned array descriptor<DD><CODE>hArray</CODE> - Array to get descriptor of
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_INVALID_HANDLE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuArrayDestroy(jcuda.driver.CUarray)"><!-- --></A><H3>
cuArrayDestroy</H3>
<PRE>
public static int <B>cuArrayDestroy</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray)</PRE>
<DL>
<DD>Destroys a CUDA array.
 
 <pre>
 CUresult cuArrayDestroy (
      CUarray hArray )
 </pre>
 <div>
   <p>Destroys a CUDA array.  Destroys the CUDA
     array <tt>hArray</tt>.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hArray</CODE> - Array to destroy
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_ARRAY_IS_MAPPED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><!-- --></A><H3>
cuArray3DCreate</H3>
<PRE>
public static int <B>cuArray3DCreate</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;pHandle,
                                  <A HREF="../../jcuda/driver/CUDA_ARRAY3D_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY3D_DESCRIPTOR</A>&nbsp;pAllocateArray)</PRE>
<DL>
<DD>Creates a 3D CUDA array.
 
 <pre>
 CUresult cuArray3DCreate (
      CUarray* pHandle,
      const CUDA_ARRAY3D_DESCRIPTOR* pAllocateArray )
 </pre>
 <div>
   <p>Creates a 3D CUDA array.  Creates a CUDA
     array according to the CUDA_ARRAY3D_DESCRIPTOR structure <tt>pAllocateArray</tt> and returns a handle to the new CUDA array in <tt>*pHandle</tt>. The CUDA_ARRAY3D_DESCRIPTOR is defined as:
   </p>
   <pre>    typedef struct {
         unsigned int Width;
         unsigned int Height;
         unsigned int Depth;
         CUarray_format Format;
         unsigned int NumChannels;
         unsigned int Flags;
     } CUDA_ARRAY3D_DESCRIPTOR;</pre>
   where:</p>
   <ul>
     <li>
       <div>
         <tt>Width</tt>, <tt>Height</tt>, and <tt>Depth</tt> are the width, height, and depth of
         the CUDA array (in elements); the following types of CUDA arrays can
         be allocated:
         <ul>
           <li>
             <p>A 1D array is allocated
               if <tt>Height</tt> and <tt>Depth</tt> extents are both zero.
             </p>
           </li>
           <li>
             <p>A 2D array is allocated
               if only <tt>Depth</tt> extent is zero.
             </p>
           </li>
           <li>
             <p>A 3D array is allocated
               if all three extents are non-zero.
             </p>
           </li>
           <li>
             <p>A 1D layered CUDA
               array is allocated if only <tt>Height</tt> is zero and the
               CUDA_ARRAY3D_LAYERED flag is set. Each layer is a 1D array. The number
               of layers is determined by the depth extent.
             </p>
           </li>
           <li>
             <p>A 2D layered CUDA
               array is allocated if all three extents are non-zero and the
               CUDA_ARRAY3D_LAYERED flag is set. Each layer is a 2D array. The number
               of layers is determined by the depth extent.
             </p>
           </li>
           <li>
             <p>A cubemap CUDA array
               is allocated if all three extents are non-zero and the CUDA_ARRAY3D_CUBEMAP
               flag is set. <tt>Width</tt> must be equal to <tt>Height</tt>, and
               <tt>Depth</tt> must be six. A cubemap is a special type of 2D layered
               CUDA array, where the six layers represent the six faces of a cube.
               The order of the six
               layers in memory is the same as that listed in CUarray_cubemap_face.
             </p>
           </li>
           <li>
             <p>A cubemap layered CUDA
               array is allocated if all three extents are non-zero, and both,
               CUDA_ARRAY3D_CUBEMAP and CUDA_ARRAY3D_LAYERED flags are set. <tt>Width</tt> must be equal to <tt>Height</tt>, and <tt>Depth</tt> must
               be a multiple of six. A cubemap layered CUDA array is a special type
               of 2D layered CUDA array that consists of a collection
               of cubemaps. The first
               six layers represent the first cubemap, the next six layers form the
               second cubemap, and so on.
             </p>
           </li>
         </ul>
       </div>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <div>
         Format specifies the format
         of the elements; CUarray_format is defined as: 
         <pre>    typedef enum
 CUarray_format_enum {
         CU_AD_FORMAT_UNSIGNED_INT8 = 0x01,
         CU_AD_FORMAT_UNSIGNED_INT16 = 0x02,
         CU_AD_FORMAT_UNSIGNED_INT32 = 0x03,
         CU_AD_FORMAT_SIGNED_INT8 = 0x08,
         CU_AD_FORMAT_SIGNED_INT16 = 0x09,
         CU_AD_FORMAT_SIGNED_INT32 = 0x0a,
         CU_AD_FORMAT_HALF = 0x10,
         CU_AD_FORMAT_FLOAT = 0x20
     } CUarray_format;</pre>
       </div>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p><tt>NumChannels</tt> specifies
         the number of packed components per CUDA array element; it may be 1,
         2, or 4;
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <div>
         Flags may be set to
         <ul>
           <li>
             <p>CUDA_ARRAY3D_LAYERED
               to enable creation of layered CUDA arrays. If this flag is set, <tt>Depth</tt> specifies the number of layers, not the depth of a 3D
               array.
             </p>
           </li>
           <li>
             <p>CUDA_ARRAY3D_SURFACE_LDST
               to enable surface references to be bound to the CUDA array. If this
               flag is not set, cuSurfRefSetArray will fail when attempting to bind
               the CUDA array to a surface reference.
             </p>
           </li>
           <li>
             <p>CUDA_ARRAY3D_CUBEMAP
               to enable creation of cubemaps. If this flag is set, <tt>Width</tt>
               must be equal to <tt>Height</tt>, and <tt>Depth</tt> must be six. If
               the CUDA_ARRAY3D_LAYERED flag is also set, then <tt>Depth</tt> must
               be a multiple of six.
             </p>
           </li>
           <li>
             <p>CUDA_ARRAY3D_TEXTURE_GATHER
               to indicate that the CUDA array will be used for texture gather.
               Texture gather can only be performed on 2D CUDA arrays.
             </p>
           </li>
         </ul>
       </div>
     </li>
   </ul>
   </p>
   <p><tt>Width</tt>, <tt>Height</tt> and
     <tt>Depth</tt> must meet certain size requirements as listed in the
     following table. All values are specified in elements. Note that for
     brevity's sake, the full name of the
     device attribute is not specified. For ex., TEXTURE1D_WIDTH refers to
     the device attribute
     CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH.
   </p>
   <p>Note that 2D CUDA arrays have different
     size requirements if the CUDA_ARRAY3D_TEXTURE_GATHER flag is set. <tt>Width</tt> and <tt>Height</tt> must not be greater than
     CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH and
     CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT respectively, in
     that case.
   </p>
   <div>
     <table cellpadding="4" cellspacing="0" summary="" frame="border" border="1" rules="all">
       <tbody>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p><strong>CUDA array
               type</strong>
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p><strong>Valid extents
               that must always be met
               {(width range in
               elements), (height range), (depth range)}</strong>
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p><strong>Valid extents
               with CUDA_ARRAY3D_SURFACE_LDST set
               {(width range in
               elements), (height range), (depth range)}</strong>
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>1D </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,TEXTURE1D_WIDTH),
               0, 0 } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,SURFACE1D_WIDTH),
               0, 0 } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>2D </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,TEXTURE2D_WIDTH),
               (1,TEXTURE2D_HEIGHT), 0 } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,SURFACE2D_WIDTH),
               (1,SURFACE2D_HEIGHT), 0 } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>3D </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,TEXTURE3D_WIDTH),
               (1,TEXTURE3D_HEIGHT), (1,TEXTURE3D_DEPTH) } 
               OR
               {
               (1,TEXTURE3D_WIDTH_ALTERNATE), (1,TEXTURE3D_HEIGHT_ALTERNATE),
               (1,TEXTURE3D_DEPTH_ALTERNATE) } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,SURFACE3D_WIDTH),
               (1,SURFACE3D_HEIGHT), (1,SURFACE3D_DEPTH) } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>1D Layered </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,TEXTURE1D_LAYERED_WIDTH), 0, (1,TEXTURE1D_LAYERED_LAYERS) } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,SURFACE1D_LAYERED_WIDTH), 0, (1,SURFACE1D_LAYERED_LAYERS) } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>2D Layered </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,TEXTURE2D_LAYERED_WIDTH), (1,TEXTURE2D_LAYERED_HEIGHT),
               (1,TEXTURE2D_LAYERED_LAYERS) } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,SURFACE2D_LAYERED_WIDTH), (1,SURFACE2D_LAYERED_HEIGHT),
               (1,SURFACE2D_LAYERED_LAYERS) } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>Cubemap </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,TEXTURECUBEMAP_WIDTH),
               (1,TEXTURECUBEMAP_WIDTH), 6 } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,SURFACECUBEMAP_WIDTH),
               (1,SURFACECUBEMAP_WIDTH), 6 } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>Cubemap Layered </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,TEXTURECUBEMAP_LAYERED_WIDTH), (1,TEXTURECUBEMAP_LAYERED_WIDTH),
               (1,TEXTURECUBEMAP_LAYERED_LAYERS) } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,SURFACECUBEMAP_LAYERED_WIDTH), (1,SURFACECUBEMAP_LAYERED_WIDTH),
               (1,SURFACECUBEMAP_LAYERED_LAYERS) } 
             </p>
           </td>
         </tr>
       </tbody>
     </table>
   </div>
   </p>
   <p>Here are examples of CUDA array
     descriptions:
   </p>
   <p>Description for a CUDA array of 2048
     floats: 
   <pre>    CUDA_ARRAY3D_DESCRIPTOR desc;
     desc.Format = CU_AD_FORMAT_FLOAT;
     desc.NumChannels = 1;
     desc.Width = 2048;
     desc.Height = 0;
     desc.Depth = 0;</pre>
   </p>
   <p>Description for a 64 x 64 CUDA array of
     floats: 
   <pre>    CUDA_ARRAY3D_DESCRIPTOR desc;
     desc.Format = CU_AD_FORMAT_FLOAT;
     desc.NumChannels = 1;
     desc.Width = 64;
     desc.Height = 64;
     desc.Depth = 0;</pre>
   </p>
   <p>Description for a <tt>width</tt> x <tt>height</tt> x <tt>depth</tt> CUDA array of 64-bit, 4x16-bit float16's:
   <pre>    CUDA_ARRAY3D_DESCRIPTOR desc;
     desc.FormatFlags = CU_AD_FORMAT_HALF;
     desc.NumChannels = 4;
     desc.Width = width;
     desc.Height = height;
     desc.Depth = depth;</pre>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pHandle</CODE> - Returned array<DD><CODE>pAllocateArray</CODE> - 3D array descriptor
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_OUT_OF_MEMORY, CUDA_ERROR_UNKNOWN<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><!-- --></A><H3>
cuArray3DGetDescriptor</H3>
<PRE>
public static int <B>cuArray3DGetDescriptor</B>(<A HREF="../../jcuda/driver/CUDA_ARRAY3D_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY3D_DESCRIPTOR</A>&nbsp;pArrayDescriptor,
                                         <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray)</PRE>
<DL>
<DD>Get a 3D CUDA array descriptor.
 
 <pre>
 CUresult cuArray3DGetDescriptor (
      CUDA_ARRAY3D_DESCRIPTOR* pArrayDescriptor,
      CUarray hArray )
 </pre>
 <div>
   <p>Get a 3D CUDA array descriptor.  Returns
     in <tt>*pArrayDescriptor</tt> a descriptor containing information on
     the format and dimensions of the CUDA array <tt>hArray</tt>. It is
     useful for subroutines that have been passed a CUDA array, but need to
     know the CUDA array parameters for validation
     or other purposes.
   </p>
   <p>This function may be called on 1D and
     2D arrays, in which case the <tt>Height</tt> and/or <tt>Depth</tt>
     members of the descriptor struct will be set to 0.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pArrayDescriptor</CODE> - Returned 3D array descriptor<DD><CODE>hArray</CODE> - 3D array to get descriptor of
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_INVALID_HANDLE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, long[], long, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, long, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, long, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, long, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, long, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, long, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, long, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(long[], long[])"><CODE>cuMemGetInfo(long[], long[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, long, byte, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, long, short, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, byte, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMipmappedArrayCreate(jcuda.driver.CUmipmappedArray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, int)"><!-- --></A><H3>
cuMipmappedArrayCreate</H3>
<PRE>
public static int <B>cuMipmappedArrayCreate</B>(<A HREF="../../jcuda/driver/CUmipmappedArray.html" title="class in jcuda.driver">CUmipmappedArray</A>&nbsp;pHandle,
                                         <A HREF="../../jcuda/driver/CUDA_ARRAY3D_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY3D_DESCRIPTOR</A>&nbsp;pMipmappedArrayDesc,
                                         int&nbsp;numMipmapLevels)</PRE>
<DL>
<DD>Creates a CUDA mipmapped array.
 
 <pre>
 CUresult cuMipmappedArrayCreate (
      CUmipmappedArray* pHandle,
      const CUDA_ARRAY3D_DESCRIPTOR* pMipmappedArrayDesc,
      unsigned int  numMipmapLevels )
 </pre>
 <div>
   <p>Creates a CUDA mipmapped array.  Creates
     a CUDA mipmapped array according to the CUDA_ARRAY3D_DESCRIPTOR
     structure <tt>pMipmappedArrayDesc</tt> and returns a handle to the
     new CUDA mipmapped array in <tt>*pHandle</tt>. <tt>numMipmapLevels</tt>
     specifies the number of mipmap levels to be allocated. This value is
     clamped to the range [1, 1 + floor(log2(max(width, height,
     depth)))].
   </p>
   <p>The CUDA_ARRAY3D_DESCRIPTOR is defined
     as:
   </p>
   <pre>    typedef struct {
         unsigned int Width;
         unsigned int Height;
         unsigned int Depth;
         CUarray_format Format;
         unsigned int NumChannels;
         unsigned int Flags;
     } CUDA_ARRAY3D_DESCRIPTOR;</pre>
   where:</p>
   <ul>
     <li>
       <div>
         <tt>Width</tt>, <tt>Height</tt>, and <tt>Depth</tt> are the width, height, and depth of
         the CUDA array (in elements); the following types of CUDA arrays can
         be allocated:
         <ul>
           <li>
             <p>A 1D mipmapped array
               is allocated if <tt>Height</tt> and <tt>Depth</tt> extents are both
               zero.
             </p>
           </li>
           <li>
             <p>A 2D mipmapped array
               is allocated if only <tt>Depth</tt> extent is zero.
             </p>
           </li>
           <li>
             <p>A 3D mipmapped array
               is allocated if all three extents are non-zero.
             </p>
           </li>
           <li>
             <p>A 1D layered CUDA
               mipmapped array is allocated if only <tt>Height</tt> is zero and the
               CUDA_ARRAY3D_LAYERED flag is set. Each layer is a 1D array. The number
               of layers is determined by the depth extent.
             </p>
           </li>
           <li>
             <p>A 2D layered CUDA
               mipmapped array is allocated if all three extents are non-zero and the
               CUDA_ARRAY3D_LAYERED flag is set. Each layer is a 2D array. The number
               of layers is determined by the depth extent.
             </p>
           </li>
           <li>
             <p>A cubemap CUDA
               mipmapped array is allocated if all three extents are non-zero and the
               CUDA_ARRAY3D_CUBEMAP flag is set. <tt>Width</tt> must be equal to <tt>Height</tt>, and <tt>Depth</tt> must be six. A cubemap is a special
               type of 2D layered CUDA array, where the six layers represent the six
               faces of a cube.
               The order of the six
               layers in memory is the same as that listed in CUarray_cubemap_face.
             </p>
           </li>
           <li>
             <p>A cubemap layered CUDA
               mipmapped array is allocated if all three extents are non-zero, and
               both, CUDA_ARRAY3D_CUBEMAP and CUDA_ARRAY3D_LAYERED flags are set. <tt>Width</tt> must be equal to <tt>Height</tt>, and <tt>Depth</tt> must
               be a multiple of six. A cubemap layered CUDA array is a special type
               of 2D layered CUDA array that consists of a collection
               of cubemaps. The first
               six layers represent the first cubemap, the next six layers form the
               second cubemap, and so on.
             </p>
           </li>
         </ul>
       </div>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <div>
         Format specifies the format
         of the elements; CUarray_format is defined as: 
         <pre>    typedef enum
 CUarray_format_enum {
         CU_AD_FORMAT_UNSIGNED_INT8 = 0x01,
         CU_AD_FORMAT_UNSIGNED_INT16 = 0x02,
         CU_AD_FORMAT_UNSIGNED_INT32 = 0x03,
         CU_AD_FORMAT_SIGNED_INT8 = 0x08,
         CU_AD_FORMAT_SIGNED_INT16 = 0x09,
         CU_AD_FORMAT_SIGNED_INT32 = 0x0a,
         CU_AD_FORMAT_HALF = 0x10,
         CU_AD_FORMAT_FLOAT = 0x20
     } CUarray_format;</pre>
       </div>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p><tt>NumChannels</tt> specifies
         the number of packed components per CUDA array element; it may be 1,
         2, or 4;
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <div>
         Flags may be set to
         <ul>
           <li>
             <p>CUDA_ARRAY3D_LAYERED
               to enable creation of layered CUDA mipmapped arrays. If this flag is
               set, <tt>Depth</tt> specifies the number of layers, not the depth of
               a 3D array.
             </p>
           </li>
           <li>
             <p>CUDA_ARRAY3D_SURFACE_LDST
               to enable surface references to be bound to individual mipmap levels
               of the CUDA mipmapped array. If this flag is not set,
               cuSurfRefSetArray will
               fail when attempting to bind a mipmap level of the CUDA mipmapped array
               to a surface reference.
             </p>
           </li>
           <li>
             <p>CUDA_ARRAY3D_CUBEMAP
               to enable creation of mipmapped cubemaps. If this flag is set, <tt>Width</tt> must be equal to <tt>Height</tt>, and <tt>Depth</tt> must
               be six. If the CUDA_ARRAY3D_LAYERED flag is also set, then <tt>Depth</tt> must be a multiple of six.
             </p>
           </li>
           <li>
             <p>CUDA_ARRAY3D_TEXTURE_GATHER
               to indicate that the CUDA mipmapped array will be used for texture
               gather. Texture gather can only be performed on 2D CUDA
               mipmapped arrays.
             </p>
           </li>
         </ul>
       </div>
     </li>
   </ul>
   </p>
   <p><tt>Width</tt>, <tt>Height</tt> and
     <tt>Depth</tt> must meet certain size requirements as listed in the
     following table. All values are specified in elements. Note that for
     brevity's sake, the full name of the
     device attribute is not specified. For ex., TEXTURE1D_MIPMAPPED_WIDTH
     refers to the device
     attribute
     CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH.
   </p>
   <div>
     <table cellpadding="4" cellspacing="0" summary="" frame="border" border="1" rules="all">
       <tbody>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p><strong>CUDA array
               type</strong>
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p><strong>Valid extents
               that must always be met
               {(width range in
               elements), (height range), (depth range)}</strong>
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>1D </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,TEXTURE1D_MIPMAPPED_WIDTH), 0, 0 } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>2D </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,TEXTURE2D_MIPMAPPED_WIDTH), (1,TEXTURE2D_MIPMAPPED_HEIGHT), 0 }
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>3D </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,TEXTURE3D_WIDTH),
               (1,TEXTURE3D_HEIGHT), (1,TEXTURE3D_DEPTH) } 
               OR
               {
               (1,TEXTURE3D_WIDTH_ALTERNATE), (1,TEXTURE3D_HEIGHT_ALTERNATE),
               (1,TEXTURE3D_DEPTH_ALTERNATE) } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>1D Layered </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,TEXTURE1D_LAYERED_WIDTH), 0, (1,TEXTURE1D_LAYERED_LAYERS) } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>2D Layered </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,TEXTURE2D_LAYERED_WIDTH), (1,TEXTURE2D_LAYERED_HEIGHT),
               (1,TEXTURE2D_LAYERED_LAYERS) } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>Cubemap </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,TEXTURECUBEMAP_WIDTH),
               (1,TEXTURECUBEMAP_WIDTH), 6 } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>Cubemap Layered </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,TEXTURECUBEMAP_LAYERED_WIDTH), (1,TEXTURECUBEMAP_LAYERED_WIDTH),
               (1,TEXTURECUBEMAP_LAYERED_LAYERS) } 
             </p>
           </td>
         </tr>
       </tbody>
     </table>
   </div>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pHandle</CODE> - Returned mipmapped array<DD><CODE>pMipmappedArrayDesc</CODE> - mipmapped array descriptor<DD><CODE>numMipmapLevels</CODE> - Number of mipmap levels
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_OUT_OF_MEMORY, CUDA_ERROR_UNKNOWN<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMipmappedArrayDestroy(jcuda.driver.CUmipmappedArray)"><CODE>cuMipmappedArrayDestroy(jcuda.driver.CUmipmappedArray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMipmappedArrayGetLevel(jcuda.driver.CUarray, jcuda.driver.CUmipmappedArray, int)"><CODE>cuMipmappedArrayGetLevel(jcuda.driver.CUarray, jcuda.driver.CUmipmappedArray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMipmappedArrayGetLevel(jcuda.driver.CUarray, jcuda.driver.CUmipmappedArray, int)"><!-- --></A><H3>
cuMipmappedArrayGetLevel</H3>
<PRE>
public static int <B>cuMipmappedArrayGetLevel</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;pLevelArray,
                                           <A HREF="../../jcuda/driver/CUmipmappedArray.html" title="class in jcuda.driver">CUmipmappedArray</A>&nbsp;hMipmappedArray,
                                           int&nbsp;level)</PRE>
<DL>
<DD>Gets a mipmap level of a CUDA mipmapped array.
 
 <pre>
 CUresult cuMipmappedArrayGetLevel (
      CUarray* pLevelArray,
      CUmipmappedArray hMipmappedArray,
      unsigned int  level )
 </pre>
 <div>
   <p>Gets a mipmap level of a CUDA mipmapped
     array.  Returns in <tt>*pLevelArray</tt> a CUDA array that represents
     a single mipmap level of the CUDA mipmapped array <tt>hMipmappedArray</tt>.
   </p>
   <p>If <tt>level</tt> is greater than the
     maximum number of levels in this mipmapped array, CUDA_ERROR_INVALID_VALUE
     is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pLevelArray</CODE> - Returned mipmap level CUDA array<DD><CODE>hMipmappedArray</CODE> - CUDA mipmapped array<DD><CODE>level</CODE> - Mipmap level
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_INVALID_HANDLE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMipmappedArrayCreate(jcuda.driver.CUmipmappedArray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, int)"><CODE>cuMipmappedArrayCreate(jcuda.driver.CUmipmappedArray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMipmappedArrayDestroy(jcuda.driver.CUmipmappedArray)"><CODE>cuMipmappedArrayDestroy(jcuda.driver.CUmipmappedArray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMipmappedArrayDestroy(jcuda.driver.CUmipmappedArray)"><!-- --></A><H3>
cuMipmappedArrayDestroy</H3>
<PRE>
public static int <B>cuMipmappedArrayDestroy</B>(<A HREF="../../jcuda/driver/CUmipmappedArray.html" title="class in jcuda.driver">CUmipmappedArray</A>&nbsp;hMipmappedArray)</PRE>
<DL>
<DD>Destroys a CUDA mipmapped array.
 
 <pre>
 CUresult cuMipmappedArrayDestroy (
      CUmipmappedArray hMipmappedArray )
 </pre>
 <div>
   <p>Destroys a CUDA mipmapped array.  Destroys
     the CUDA mipmapped array <tt>hMipmappedArray</tt>.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hMipmappedArray</CODE> - Mipmapped array to destroy
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_ARRAY_IS_MAPPED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMipmappedArrayCreate(jcuda.driver.CUmipmappedArray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, int)"><CODE>cuMipmappedArrayCreate(jcuda.driver.CUmipmappedArray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMipmappedArrayGetLevel(jcuda.driver.CUarray, jcuda.driver.CUmipmappedArray, int)"><CODE>cuMipmappedArrayGetLevel(jcuda.driver.CUarray, jcuda.driver.CUmipmappedArray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefCreate(jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefCreate</H3>
<PRE>
public static int <B>cuTexRefCreate</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;pTexRef)</PRE>
<DL>
<DD>Creates a texture reference.
 
 <pre>
 CUresult cuTexRefCreate (
      CUtexref* pTexRef )
 </pre>
 <div>
   <p>Creates a texture reference.  
     DeprecatedCreates a texture reference
     and returns its handle in <tt>*pTexRef</tt>. Once created, the
     application must call cuTexRefSetArray() or cuTexRefSetAddress() to
     associate the reference with allocated memory. Other texture reference
     functions are used to specify the format and interpretation
     (addressing, filtering, etc.) to be used
     when the memory is read through this texture reference.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pTexRef</CODE> - Returned texture reference
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefDestroy(jcuda.driver.CUtexref)"><CODE>cuTexRefDestroy(jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefDestroy(jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefDestroy</H3>
<PRE>
public static int <B>cuTexRefDestroy</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Destroys a texture reference.
 
 <pre>
 CUresult cuTexRefDestroy (
      CUtexref hTexRef )
 </pre>
 <div>
   <p>Destroys a texture reference.  
     DeprecatedDestroys the texture reference
     specified by <tt>hTexRef</tt>.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hTexRef</CODE> - Texture reference to destroy
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefCreate(jcuda.driver.CUtexref)"><CODE>cuTexRefCreate(jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><!-- --></A><H3>
cuTexRefSetArray</H3>
<PRE>
public static int <B>cuTexRefSetArray</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                   <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray,
                                   int&nbsp;Flags)</PRE>
<DL>
<DD>Binds an array as a texture reference.
 
 <pre>
 CUresult cuTexRefSetArray (
      CUtexref hTexRef,
      CUarray hArray,
      unsigned int  Flags )
 </pre>
 <div>
   <p>Binds an array as a texture reference. 
     Binds the CUDA array <tt>hArray</tt> to the texture reference <tt>hTexRef</tt>. Any previous address or CUDA array state associated with
     the texture reference is superseded by this function. <tt>Flags</tt>
     must be set to CU_TRSA_OVERRIDE_FORMAT. Any CUDA array previously bound
     to <tt>hTexRef</tt> is unbound.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hTexRef</CODE> - Texture reference to bind<DD><CODE>hArray</CODE> - Array to bind<DD><CODE>Flags</CODE> - Options (must be CU_TRSA_OVERRIDE_FORMAT)
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetMipmappedArray(jcuda.driver.CUtexref, jcuda.driver.CUmipmappedArray, int)"><!-- --></A><H3>
cuTexRefSetMipmappedArray</H3>
<PRE>
public static int <B>cuTexRefSetMipmappedArray</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                            <A HREF="../../jcuda/driver/CUmipmappedArray.html" title="class in jcuda.driver">CUmipmappedArray</A>&nbsp;hMipmappedArray,
                                            int&nbsp;Flags)</PRE>
<DL>
<DD>Binds a mipmapped array to a texture reference.
 
 <pre>
 CUresult cuTexRefSetMipmappedArray (
      CUtexref hTexRef,
      CUmipmappedArray hMipmappedArray,
      unsigned int  Flags )
 </pre>
 <div>
   <p>Binds a mipmapped array to a texture
     reference.  Binds the CUDA mipmapped array <tt>hMipmappedArray</tt>
     to the texture reference <tt>hTexRef</tt>. Any previous address or
     CUDA array state associated with the texture reference is superseded
     by this function. <tt>Flags</tt> must be set to CU_TRSA_OVERRIDE_FORMAT.
     Any CUDA array previously bound to <tt>hTexRef</tt> is unbound.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hTexRef</CODE> - Texture reference to bind<DD><CODE>hMipmappedArray</CODE> - Mipmapped array to bind<DD><CODE>Flags</CODE> - Options (must be CU_TRSA_OVERRIDE_FORMAT)
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><!-- --></A><H3>
cuTexRefSetAddress</H3>
<PRE>
public static int <B>cuTexRefSetAddress</B>(long[]&nbsp;ByteOffset,
                                     <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                     <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                                     long&nbsp;bytes)</PRE>
<DL>
<DD>Binds an address as a texture reference.
 
 <pre>
 CUresult cuTexRefSetAddress (
      size_t* ByteOffset,
      CUtexref hTexRef,
      CUdeviceptr dptr,
      size_t bytes )
 </pre>
 <div>
   <p>Binds an address as a texture reference.
     Binds a linear address range to the texture reference <tt>hTexRef</tt>.
     Any previous address or CUDA array state associated with the texture
     reference is superseded by this function. Any memory
     previously bound to <tt>hTexRef</tt> is
     unbound.
   </p>
   <p>Since the hardware enforces an alignment
     requirement on texture base addresses, cuTexRefSetAddress() passes back
     a byte offset in <tt>*ByteOffset</tt> that must be applied to texture
     fetches in order to read from the desired memory. This offset must be
     divided by the texel
     size and passed to kernels that read from
     the texture so they can be applied to the tex1Dfetch() function.
   </p>
   <p>If the device memory pointer was returned
     from cuMemAlloc(), the offset is guaranteed to be 0 and NULL may be
     passed as the <tt>ByteOffset</tt> parameter.
   </p>
   <p>The total number of elements (or texels)
     in the linear address range cannot exceed
     CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH. The number of
     elements is computed as (<tt>bytes</tt> / bytesPerElement), where
     bytesPerElement is determined from the data format and number of
     components set using cuTexRefSetFormat().
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ByteOffset</CODE> - Returned byte offset<DD><CODE>hTexRef</CODE> - Texture reference to bind<DD><CODE>dptr</CODE> - Device pointer to bind<DD><CODE>bytes</CODE> - Size of memory to bind in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><!-- --></A><H3>
cuTexRefSetFormat</H3>
<PRE>
public static int <B>cuTexRefSetFormat</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                    int&nbsp;fmt,
                                    int&nbsp;NumPackedComponents)</PRE>
<DL>
<DD>Sets the format for a texture reference.
 
 <pre>
 CUresult cuTexRefSetFormat (
      CUtexref hTexRef,
      CUarray_format fmt,
      int  NumPackedComponents )
 </pre>
 <div>
   <p>Sets the format for a texture reference.
     Specifies the format of the data to be read by the texture reference
     <tt>hTexRef</tt>. <tt>fmt</tt> and <tt>NumPackedComponents</tt> are
     exactly analogous to the Format and NumChannels members of the
     CUDA_ARRAY_DESCRIPTOR structure: They specify the format of each
     component and the number of components per array element.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hTexRef</CODE> - Texture reference<DD><CODE>fmt</CODE> - Format to set<DD><CODE>NumPackedComponents</CODE> - Number of components per array element
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><!-- --></A><H3>
cuTexRefSetAddress2D</H3>
<PRE>
public static int <B>cuTexRefSetAddress2D</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                       <A HREF="../../jcuda/driver/CUDA_ARRAY_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY_DESCRIPTOR</A>&nbsp;desc,
                                       <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                                       long&nbsp;PitchInBytes)</PRE>
<DL>
<DD>Binds an address as a 2D texture reference.
 
 <pre>
 CUresult cuTexRefSetAddress2D (
      CUtexref hTexRef,
      const CUDA_ARRAY_DESCRIPTOR* desc,
      CUdeviceptr dptr,
      size_t Pitch )
 </pre>
 <div>
   <p>Binds an address as a 2D texture
     reference.  Binds a linear address range to the texture reference <tt>hTexRef</tt>. Any previous address or CUDA array state associated with
     the texture reference is superseded by this function. Any memory
     previously bound to <tt>hTexRef</tt> is
     unbound.
   </p>
   <p>Using a tex2D() function inside a kernel
     requires a call to either cuTexRefSetArray() to bind the corresponding
     texture reference to an array, or cuTexRefSetAddress2D() to bind the
     texture reference to linear memory.
   </p>
   <p>Function calls to cuTexRefSetFormat()
     cannot follow calls to cuTexRefSetAddress2D() for the same texture
     reference.
   </p>
   <p>It is required that <tt>dptr</tt> be
     aligned to the appropriate hardware-specific texture alignment. You
     can query this value using the device attribute
     CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT. If an unaligned <tt>dptr</tt>
     is supplied, CUDA_ERROR_INVALID_VALUE is returned.
   </p>
   <p><tt>Pitch</tt> has to be aligned to
     the hardware-specific texture pitch alignment. This value can be
     queried using the device attribute
     CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT.
     If an unaligned <tt>Pitch</tt> is supplied, CUDA_ERROR_INVALID_VALUE
     is returned.
   </p>
   <p>Width and Height, which are specified
     in elements (or texels), cannot exceed
     CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH and
     CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT respectively. <tt>Pitch</tt>, which is specified in bytes, cannot exceed
     CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hTexRef</CODE> - Texture reference to bind<DD><CODE>desc</CODE> - Descriptor of CUDA array<DD><CODE>dptr</CODE> - Device pointer to bind<DD><CODE>Pitch</CODE> - Line pitch in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><!-- --></A><H3>
cuTexRefSetAddressMode</H3>
<PRE>
public static int <B>cuTexRefSetAddressMode</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                         int&nbsp;dim,
                                         int&nbsp;am)</PRE>
<DL>
<DD>Sets the addressing mode for a texture reference.
 
 <pre>
 CUresult cuTexRefSetAddressMode (
      CUtexref hTexRef,
      int  dim,
      CUaddress_mode am )
 </pre>
 <div>
   <p>Sets the addressing mode for a texture
     reference.  Specifies the addressing mode <tt>am</tt> for the given
     dimension <tt>dim</tt> of the texture reference <tt>hTexRef</tt>. If
     <tt>dim</tt> is zero, the addressing mode is applied to the first
     parameter of the functions used to fetch from the texture; if <tt>dim</tt> is 1, the second, and so on. CUaddress_mode is defined as:
   <pre>   typedef enum CUaddress_mode_enum {
       CU_TR_ADDRESS_MODE_WRAP = 0,
       CU_TR_ADDRESS_MODE_CLAMP = 1,
       CU_TR_ADDRESS_MODE_MIRROR = 2,
       CU_TR_ADDRESS_MODE_BORDER = 3
    } CUaddress_mode;</pre>
   </p>
   <p>Note that this call has no effect if
     <tt>hTexRef</tt> is bound to linear memory. Also, if the flag,
     CU_TRSF_NORMALIZED_COORDINATES, is not set, the only supported address
     mode is CU_TR_ADDRESS_MODE_CLAMP.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hTexRef</CODE> - Texture reference<DD><CODE>dim</CODE> - Dimension<DD><CODE>am</CODE> - Addressing mode to set
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><!-- --></A><H3>
cuTexRefSetFilterMode</H3>
<PRE>
public static int <B>cuTexRefSetFilterMode</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                        int&nbsp;fm)</PRE>
<DL>
<DD>Sets the filtering mode for a texture reference.
 
 <pre>
 CUresult cuTexRefSetFilterMode (
      CUtexref hTexRef,
      CUfilter_mode fm )
 </pre>
 <div>
   <p>Sets the filtering mode for a texture
     reference.  Specifies the filtering mode <tt>fm</tt> to be used when
     reading memory through the texture reference <tt>hTexRef</tt>.
     CUfilter_mode_enum is defined as:
   </p>
   <pre>   typedef enum CUfilter_mode_enum {
       CU_TR_FILTER_MODE_POINT = 0,
       CU_TR_FILTER_MODE_LINEAR = 1
    } CUfilter_mode;</pre>
   </p>
   <p>Note that this call has no effect if
     <tt>hTexRef</tt> is bound to linear memory.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hTexRef</CODE> - Texture reference<DD><CODE>fm</CODE> - Filtering mode to set
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetMipmapFilterMode(jcuda.driver.CUtexref, int)"><!-- --></A><H3>
cuTexRefSetMipmapFilterMode</H3>
<PRE>
public static int <B>cuTexRefSetMipmapFilterMode</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                              int&nbsp;fm)</PRE>
<DL>
<DD>Sets the mipmap filtering mode for a texture reference.
 
 <pre>
 CUresult cuTexRefSetMipmapFilterMode (
      CUtexref hTexRef,
      CUfilter_mode fm )
 </pre>
 <div>
   <p>Sets the mipmap filtering mode for a
     texture reference.  Specifies the mipmap filtering mode <tt>fm</tt>
     to be used when reading memory through the texture reference <tt>hTexRef</tt>. CUfilter_mode_enum is defined as:
   </p>
   <pre>   typedef enum CUfilter_mode_enum {
       CU_TR_FILTER_MODE_POINT = 0,
       CU_TR_FILTER_MODE_LINEAR = 1
    } CUfilter_mode;</pre>
   </p>
   <p>Note that this call has no effect if
     <tt>hTexRef</tt> is not bound to a mipmapped array.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hTexRef</CODE> - Texture reference<DD><CODE>fm</CODE> - Filtering mode to set
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetMipmapLevelBias(jcuda.driver.CUtexref, float)"><!-- --></A><H3>
cuTexRefSetMipmapLevelBias</H3>
<PRE>
public static int <B>cuTexRefSetMipmapLevelBias</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                             float&nbsp;bias)</PRE>
<DL>
<DD>Sets the mipmap level bias for a texture reference.
 
 <pre>
 CUresult cuTexRefSetMipmapLevelBias (
      CUtexref hTexRef,
      float  bias )
 </pre>
 <div>
   <p>Sets the mipmap level bias for a texture
     reference.  Specifies the mipmap level bias <tt>bias</tt> to be added
     to the specified mipmap level when reading memory through the texture
     reference <tt>hTexRef</tt>.
   </p>
   <p>Note that this call has no effect if
     <tt>hTexRef</tt> is not bound to a mipmapped array.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hTexRef</CODE> - Texture reference<DD><CODE>bias</CODE> - Mipmap level bias
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetMipmapLevelClamp(jcuda.driver.CUtexref, float, float)"><!-- --></A><H3>
cuTexRefSetMipmapLevelClamp</H3>
<PRE>
public static int <B>cuTexRefSetMipmapLevelClamp</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                              float&nbsp;minMipmapLevelClamp,
                                              float&nbsp;maxMipmapLevelClamp)</PRE>
<DL>
<DD>Sets the mipmap min/max mipmap level clamps for a texture reference.
 
 <pre>
 CUresult cuTexRefSetMipmapLevelClamp (
      CUtexref hTexRef,
      float  minMipmapLevelClamp,
      float  maxMipmapLevelClamp )
 </pre>
 <div>
   <p>Sets the mipmap min/max mipmap level
     clamps for a texture reference.  Specifies the min/max mipmap level
     clamps, <tt>minMipmapLevelClamp</tt> and <tt>maxMipmapLevelClamp</tt>
     respectively, to be used when reading memory through the texture
     reference <tt>hTexRef</tt>.
   </p>
   <p>Note that this call has no effect if
     <tt>hTexRef</tt> is not bound to a mipmapped array.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hTexRef</CODE> - Texture reference<DD><CODE>minMipmapLevelClamp</CODE> - Mipmap min level clamp<DD><CODE>maxMipmapLevelClamp</CODE> - Mipmap max level clamp
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetMaxAnisotropy(jcuda.driver.CUtexref, int)"><!-- --></A><H3>
cuTexRefSetMaxAnisotropy</H3>
<PRE>
public static int <B>cuTexRefSetMaxAnisotropy</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                           int&nbsp;maxAniso)</PRE>
<DL>
<DD>Sets the maximum anistropy for a texture reference.
 
 <pre>
 CUresult cuTexRefSetMaxAnisotropy (
      CUtexref hTexRef,
      unsigned int  maxAniso )
 </pre>
 <div>
   <p>Sets the maximum anistropy for a texture
     reference.  Specifies the maximum aniostropy <tt>maxAniso</tt> to be
     used when reading memory through the texture reference <tt>hTexRef</tt>.
   </p>
   <p>Note that this call has no effect if
     <tt>hTexRef</tt> is bound to linear memory.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hTexRef</CODE> - Texture reference<DD><CODE>maxAniso</CODE> - Maximum anisotropy
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><!-- --></A><H3>
cuTexRefSetFlags</H3>
<PRE>
public static int <B>cuTexRefSetFlags</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                   int&nbsp;Flags)</PRE>
<DL>
<DD>Sets the flags for a texture reference.
 
 <pre>
 CUresult cuTexRefSetFlags (
      CUtexref hTexRef,
      unsigned int  Flags )
 </pre>
 <div>
   <p>Sets the flags for a texture reference. 
     Specifies optional flags via <tt>Flags</tt> to specify the behavior
     of data returned through the texture reference <tt>hTexRef</tt>. The
     valid flags are:
   </p>
   <ul>
     <li>
       <p>CU_TRSF_READ_AS_INTEGER, which
         suppresses the default behavior of having the texture promote integer
         data to floating point data in the range [0,
         1]. Note that texture with
         32-bit integer format would not be promoted, regardless of whether or
         not this flag is specified;
       </p>
     </li>
     <li>
       <p>CU_TRSF_NORMALIZED_COORDINATES,
         which suppresses the default behavior of having the texture coordinates
         range from [0, Dim) where Dim is the width or height
         of the CUDA array. Instead, the
         texture coordinates [0, 1.0) reference the entire breadth of the array
         dimension;
       </p>
     </li>
   </ul>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hTexRef</CODE> - Texture reference<DD><CODE>Flags</CODE> - Optional flags to set
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefGetAddress</H3>
<PRE>
public static int <B>cuTexRefGetAddress</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;pdptr,
                                     <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Gets the address associated with a texture reference.
 
 <pre>
 CUresult cuTexRefGetAddress (
      CUdeviceptr* pdptr,
      CUtexref hTexRef )
 </pre>
 <div>
   <p>Gets the address associated with a
     texture reference.  Returns in <tt>*pdptr</tt> the base address bound
     to the texture reference <tt>hTexRef</tt>, or returns
     CUDA_ERROR_INVALID_VALUE if the texture reference is not bound to any
     device memory range.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pdptr</CODE> - Returned device address<DD><CODE>hTexRef</CODE> - Texture reference
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefGetArray</H3>
<PRE>
public static int <B>cuTexRefGetArray</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;phArray,
                                   <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Gets the array bound to a texture reference.
 
 <pre>
 CUresult cuTexRefGetArray (
      CUarray* phArray,
      CUtexref hTexRef )
 </pre>
 <div>
   <p>Gets the array bound to a texture
     reference.  Returns in <tt>*phArray</tt> the CUDA array bound to the
     texture reference <tt>hTexRef</tt>, or returns CUDA_ERROR_INVALID_VALUE
     if the texture reference is not bound to any CUDA array.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>phArray</CODE> - Returned array<DD><CODE>hTexRef</CODE> - Texture reference
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefGetMipmappedArray(jcuda.driver.CUmipmappedArray, jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefGetMipmappedArray</H3>
<PRE>
public static int <B>cuTexRefGetMipmappedArray</B>(<A HREF="../../jcuda/driver/CUmipmappedArray.html" title="class in jcuda.driver">CUmipmappedArray</A>&nbsp;phMipmappedArray,
                                            <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Gets the mipmapped array bound to a texture reference.
 
 <pre>
 CUresult cuTexRefGetMipmappedArray (
      CUmipmappedArray* phMipmappedArray,
      CUtexref hTexRef )
 </pre>
 <div>
   <p>Gets the mipmapped array bound to a
     texture reference.  Returns in <tt>*phMipmappedArray</tt> the CUDA
     mipmapped array bound to the texture reference <tt>hTexRef</tt>, or
     returns CUDA_ERROR_INVALID_VALUE if the texture reference is not bound
     to any CUDA mipmapped array.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>phMipmappedArray</CODE> - Returned mipmapped array<DD><CODE>hTexRef</CODE> - Texture reference
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><!-- --></A><H3>
cuTexRefGetAddressMode</H3>
<PRE>
public static int <B>cuTexRefGetAddressMode</B>(int[]&nbsp;pam,
                                         <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                         int&nbsp;dim)</PRE>
<DL>
<DD>Gets the addressing mode used by a texture reference.
 
 <pre>
 CUresult cuTexRefGetAddressMode (
      CUaddress_mode* pam,
      CUtexref hTexRef,
      int  dim )
 </pre>
 <div>
   <p>Gets the addressing mode used by a
     texture reference.  Returns in <tt>*pam</tt> the addressing mode
     corresponding to the dimension <tt>dim</tt> of the texture reference
     <tt>hTexRef</tt>. Currently, the only valid value for <tt>dim</tt>
     are 0 and 1.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pam</CODE> - Returned addressing mode<DD><CODE>hTexRef</CODE> - Texture reference<DD><CODE>dim</CODE> - Dimension
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefGetFilterMode</H3>
<PRE>
public static int <B>cuTexRefGetFilterMode</B>(int[]&nbsp;pfm,
                                        <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Gets the filter-mode used by a texture reference.
 
 <pre>
 CUresult cuTexRefGetFilterMode (
      CUfilter_mode* pfm,
      CUtexref hTexRef )
 </pre>
 <div>
   <p>Gets the filter-mode used by a texture
     reference.  Returns in <tt>*pfm</tt> the filtering mode of the texture
     reference <tt>hTexRef</tt>.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pfm</CODE> - Returned filtering mode<DD><CODE>hTexRef</CODE> - Texture reference
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefGetFormat</H3>
<PRE>
public static int <B>cuTexRefGetFormat</B>(int[]&nbsp;pFormat,
                                    int[]&nbsp;pNumChannels,
                                    <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Gets the format used by a texture reference.
 
 <pre>
 CUresult cuTexRefGetFormat (
      CUarray_format* pFormat,
      int* pNumChannels,
      CUtexref hTexRef )
 </pre>
 <div>
   <p>Gets the format used by a texture
     reference.  Returns in <tt>*pFormat</tt> and <tt>*pNumChannels</tt>
     the format and number of components of the CUDA array bound to the
     texture reference <tt>hTexRef</tt>. If <tt>pFormat</tt> or <tt>pNumChannels</tt> is NULL, it will be ignored.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pFormat</CODE> - Returned format<DD><CODE>pNumChannels</CODE> - Returned number of components<DD><CODE>hTexRef</CODE> - Texture reference
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefGetMipmapFilterMode(int[], jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefGetMipmapFilterMode</H3>
<PRE>
public static int <B>cuTexRefGetMipmapFilterMode</B>(int[]&nbsp;pfm,
                                              <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Gets the mipmap filtering mode for a texture reference.
 
 <pre>
 CUresult cuTexRefGetMipmapFilterMode (
      CUfilter_mode* pfm,
      CUtexref hTexRef )
 </pre>
 <div>
   <p>Gets the mipmap filtering mode for a
     texture reference.  Returns the mipmap filtering mode in <tt>pfm</tt>
     that's used when reading memory through the texture reference <tt>hTexRef</tt>.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pfm</CODE> - Returned mipmap filtering mode<DD><CODE>hTexRef</CODE> - Texture reference
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefGetMipmapLevelBias(float[], jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefGetMipmapLevelBias</H3>
<PRE>
public static int <B>cuTexRefGetMipmapLevelBias</B>(float[]&nbsp;pbias,
                                             <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Gets the mipmap level bias for a texture reference.
 
 <pre>
 CUresult cuTexRefGetMipmapLevelBias (
      float* pbias,
      CUtexref hTexRef )
 </pre>
 <div>
   <p>Gets the mipmap level bias for a texture
     reference.  Returns the mipmap level bias in <tt>pBias</tt> that's
     added to the specified mipmap level when reading memory through the
     texture reference <tt>hTexRef</tt>.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pbias</CODE> - Returned mipmap level bias<DD><CODE>hTexRef</CODE> - Texture reference
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefGetMipmapLevelClamp(float[], float[], jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefGetMipmapLevelClamp</H3>
<PRE>
public static int <B>cuTexRefGetMipmapLevelClamp</B>(float[]&nbsp;pminMipmapLevelClamp,
                                              float[]&nbsp;pmaxMipmapLevelClamp,
                                              <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Gets the min/max mipmap level clamps for a texture reference.
 
 <pre>
 CUresult cuTexRefGetMipmapLevelClamp (
      float* pminMipmapLevelClamp,
      float* pmaxMipmapLevelClamp,
      CUtexref hTexRef )
 </pre>
 <div>
   <p>Gets the min/max mipmap level clamps for
     a texture reference.  Returns the min/max mipmap level clamps in <tt>pminMipmapLevelClamp</tt> and <tt>pmaxMipmapLevelClamp</tt> that's
     used when reading memory through the texture reference <tt>hTexRef</tt>.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pminMipmapLevelClamp</CODE> - Returned mipmap min level clamp<DD><CODE>pmaxMipmapLevelClamp</CODE> - Returned mipmap max level clamp<DD><CODE>hTexRef</CODE> - Texture reference
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefGetMaxAnisotropy(int[], jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefGetMaxAnisotropy</H3>
<PRE>
public static int <B>cuTexRefGetMaxAnisotropy</B>(int[]&nbsp;pmaxAniso,
                                           <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Gets the maximum anistropy for a texture reference.
 
 <pre>
 CUresult cuTexRefGetMaxAnisotropy (
      int* pmaxAniso,
      CUtexref hTexRef )
 </pre>
 <div>
   <p>Gets the maximum anistropy for a texture
     reference.  Returns the maximum aniostropy in <tt>pmaxAniso</tt>
     that's used when reading memory through the texture reference <tt>hTexRef</tt>.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pmaxAniso</CODE> - Returned maximum anisotropy<DD><CODE>hTexRef</CODE> - Texture reference
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefGetFlags</H3>
<PRE>
public static int <B>cuTexRefGetFlags</B>(int[]&nbsp;pFlags,
                                   <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Gets the flags used by a texture reference.
 
 <pre>
 CUresult cuTexRefGetFlags (
      unsigned int* pFlags,
      CUtexref hTexRef )
 </pre>
 <div>
   <p>Gets the flags used by a texture
     reference.  Returns in <tt>*pFlags</tt> the flags of the texture
     reference <tt>hTexRef</tt>.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pFlags</CODE> - Returned flags<DD><CODE>hTexRef</CODE> - Texture reference
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress(long[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)"><CODE>cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuSurfRefSetArray(jcuda.driver.CUsurfref, jcuda.driver.CUarray, int)"><!-- --></A><H3>
cuSurfRefSetArray</H3>
<PRE>
public static int <B>cuSurfRefSetArray</B>(<A HREF="../../jcuda/driver/CUsurfref.html" title="class in jcuda.driver">CUsurfref</A>&nbsp;hSurfRef,
                                    <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray,
                                    int&nbsp;Flags)</PRE>
<DL>
<DD>Sets the CUDA array for a surface reference.
 
 <pre>
 CUresult cuSurfRefSetArray (
      CUsurfref hSurfRef,
      CUarray hArray,
      unsigned int  Flags )
 </pre>
 <div>
   <p>Sets the CUDA array for a surface
     reference.  Sets the CUDA array <tt>hArray</tt> to be read and written
     by the surface reference <tt>hSurfRef</tt>. Any previous CUDA array
     state associated with the surface reference is superseded by this
     function. <tt>Flags</tt> must be set to 0. The CUDA_ARRAY3D_SURFACE_LDST
     flag must have been set for the CUDA array. Any CUDA array previously
     bound to <tt>hSurfRef</tt> is unbound.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hSurfRef</CODE> - Surface reference handle<DD><CODE>hArray</CODE> - CUDA array handle<DD><CODE>Flags</CODE> - set to 0
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetSurfRef(jcuda.driver.CUsurfref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetSurfRef(jcuda.driver.CUsurfref, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuSurfRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUsurfref)"><CODE>cuSurfRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUsurfref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuSurfRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUsurfref)"><!-- --></A><H3>
cuSurfRefGetArray</H3>
<PRE>
public static int <B>cuSurfRefGetArray</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;phArray,
                                    <A HREF="../../jcuda/driver/CUsurfref.html" title="class in jcuda.driver">CUsurfref</A>&nbsp;hSurfRef)</PRE>
<DL>
<DD>Passes back the CUDA array bound to a surface reference.
 
 <pre>
 CUresult cuSurfRefGetArray (
      CUarray* phArray,
      CUsurfref hSurfRef )
 </pre>
 <div>
   <p>Passes back the CUDA array bound to a
     surface reference.  Returns in <tt>*phArray</tt> the CUDA array bound
     to the surface reference <tt>hSurfRef</tt>, or returns
     CUDA_ERROR_INVALID_VALUE if the surface reference is not bound to any
     CUDA array.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>phArray</CODE> - Surface reference handle<DD><CODE>hSurfRef</CODE> - Surface reference handle
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetSurfRef(jcuda.driver.CUsurfref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetSurfRef(jcuda.driver.CUsurfref, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuSurfRefSetArray(jcuda.driver.CUsurfref, jcuda.driver.CUarray, int)"><CODE>cuSurfRefSetArray(jcuda.driver.CUsurfref, jcuda.driver.CUarray, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexObjectCreate(jcuda.driver.CUtexObject, jcuda.driver.CUDA_RESOURCE_DESC, jcuda.driver.CUDA_TEXTURE_DESC, jcuda.driver.CUDA_RESOURCE_VIEW_DESC)"><!-- --></A><H3>
cuTexObjectCreate</H3>
<PRE>
public static int <B>cuTexObjectCreate</B>(<A HREF="../../jcuda/driver/CUtexObject.html" title="class in jcuda.driver">CUtexObject</A>&nbsp;pTexObject,
                                    <A HREF="../../jcuda/driver/CUDA_RESOURCE_DESC.html" title="class in jcuda.driver">CUDA_RESOURCE_DESC</A>&nbsp;pResDesc,
                                    <A HREF="../../jcuda/driver/CUDA_TEXTURE_DESC.html" title="class in jcuda.driver">CUDA_TEXTURE_DESC</A>&nbsp;pTexDesc,
                                    <A HREF="../../jcuda/driver/CUDA_RESOURCE_VIEW_DESC.html" title="class in jcuda.driver">CUDA_RESOURCE_VIEW_DESC</A>&nbsp;pResViewDesc)</PRE>
<DL>
<DD>Creates a texture object.
 
 <pre>
 CUresult cuTexObjectCreate (
      CUtexObject* pTexObject,
      const CUDA_RESOURCE_DESC* pResDesc,
      const CUDA_TEXTURE_DESC* pTexDesc,
      const CUDA_RESOURCE_VIEW_DESC* pResViewDesc )
 </pre>
 <div>
   <p>Creates a texture object.  Creates a
     texture object and returns it in <tt>pTexObject</tt>. <tt>pResDesc</tt>
     describes the data to texture from. <tt>pTexDesc</tt> describes how
     the data should be sampled. <tt>pResViewDesc</tt> is an optional
     argument that specifies an alternate format for the data described by
     <tt>pResDesc</tt>, and also describes the subresource region to
     restrict access to when texturing. <tt>pResViewDesc</tt> can only be
     specified if the type of resource is a CUDA array or a CUDA mipmapped
     array.
   </p>
   <p>Texture objects are only supported on
     devices of compute capability 3.0 or higher.
   </p>
   <p>The CUDA_RESOURCE_DESC structure is
     defined as: 
   <pre>        typedef struct CUDA_RESOURCE_DESC_st
         {
             CUresourcetype resType;
 
             union {
                 struct {
                     CUarray hArray;
                 } array;
                 struct {
                     CUmipmappedArray hMipmappedArray;
                 } mipmap;
                 struct {
                     CUdeviceptr devPtr;
                     CUarray_format format;
                     unsigned int numChannels;
                     size_t sizeInBytes;
                 } linear;
                 struct {
                     CUdeviceptr devPtr;
                     CUarray_format format;
                     unsigned int numChannels;
                     size_t width;
                     size_t height;
                     size_t pitchInBytes;
                 } pitch2D;
             } res;
 
             unsigned int flags;
         } CUDA_RESOURCE_DESC;</pre>
   where:
   <ul>
     <li>
       <div>
         CUDA_RESOURCE_DESC::resType
         specifies the type of resource to texture from. CUresourceType is
         defined as: 
         <pre>        typedef enum CUresourcetype_enum {
             CU_RESOURCE_TYPE_ARRAY           = 0x00,
             CU_RESOURCE_TYPE_MIPMAPPED_ARRAY = 0x01,
             CU_RESOURCE_TYPE_LINEAR          = 0x02,
             CU_RESOURCE_TYPE_PITCH2D         = 0x03
         } CUresourcetype;</pre>
       </div>
     </li>
   </ul>
   </p>
   <p>If CUDA_RESOURCE_DESC::resType is set
     to CU_RESOURCE_TYPE_ARRAY, CUDA_RESOURCE_DESC::res::array::hArray must
     be set to a valid CUDA array handle.
   </p>
   <p>If CUDA_RESOURCE_DESC::resType is set
     to CU_RESOURCE_TYPE_MIPMAPPED_ARRAY,
     CUDA_RESOURCE_DESC::res::mipmap::hMipmappedArray must be set to a valid
     CUDA mipmapped array handle.
   </p>
   <p>If CUDA_RESOURCE_DESC::resType is set
     to CU_RESOURCE_TYPE_LINEAR, CUDA_RESOURCE_DESC::res::linear::devPtr
     must be set to a valid device pointer, that is aligned to
     CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT. CUDA_RESOURCE_DESC::res::linear::format
     and CUDA_RESOURCE_DESC::res::linear::numChannels describe the format
     of each component
     and the number of components per array
     element. CUDA_RESOURCE_DESC::res::linear::sizeInBytes specifies the
     size of the array
     in bytes. The total number of elements
     in the linear address range cannot exceed
     CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH. The number of
     elements is computed as (sizeInBytes / (sizeof(format) *
     numChannels)).
   </p>
   <p>If CUDA_RESOURCE_DESC::resType is set
     to CU_RESOURCE_TYPE_PITCH2D, CUDA_RESOURCE_DESC::res::pitch2D::devPtr
     must be set to a valid device pointer, that is aligned to
     CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT. CUDA_RESOURCE_DESC::res::pitch2D::format
     and CUDA_RESOURCE_DESC::res::pitch2D::numChannels describe the format
     of each component
     and the number of components per array
     element. CUDA_RESOURCE_DESC::res::pitch2D::width and
     CUDA_RESOURCE_DESC::res::pitch2D::height
     specify the width and height of the array
     in elements, and cannot exceed CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH
     and CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT respectively.
     CUDA_RESOURCE_DESC::res::pitch2D::pitchInBytes specifies the pitch
     between two rows in bytes and has to be
     aligned to
     CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT. Pitch cannot exceed
     CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH.
   </p>
   <ul>
     <li>
       <p>flags must be set to zero.</p>
     </li>
   </ul>
   </p>
   <p>The CUDA_TEXTURE_DESC struct is defined
     as 
   <pre>        typedef struct CUDA_TEXTURE_DESC_st {
             CUaddress_mode addressMode[3];
             CUfilter_mode filterMode;
             unsigned int flags;
             unsigned int maxAnisotropy;
             CUfilter_mode mipmapFilterMode;
             float mipmapLevelBias;
             float minMipmapLevelClamp;
             float maxMipmapLevelClamp;
         } CUDA_TEXTURE_DESC;</pre>
   where
   <ul>
     <li>
       <div>
         CUDA_TEXTURE_DESC::addressMode
         specifies the addressing mode for each dimension of the texture data.
         CUaddress_mode is defined as: 
         <pre>        typedef enum
 CUaddress_mode_enum {
             CU_TR_ADDRESS_MODE_WRAP = 0,
             CU_TR_ADDRESS_MODE_CLAMP = 1,
             CU_TR_ADDRESS_MODE_MIRROR = 2,
             CU_TR_ADDRESS_MODE_BORDER = 3
         } CUaddress_mode;</pre>
         This is ignored if
         CUDA_RESOURCE_DESC::resType is CU_RESOURCE_TYPE_LINEAR. Also, if the
         flag, CU_TRSF_NORMALIZED_COORDINATES is not set, the only supported
         address mode is CU_TR_ADDRESS_MODE_CLAMP.
       </div>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <div>
         CUDA_TEXTURE_DESC::filterMode
         specifies the filtering mode to be used when fetching from the texture.
         CUfilter_mode is defined as: 
         <pre>        typedef enum CUfilter_mode_enum
 {
             CU_TR_FILTER_MODE_POINT = 0,
             CU_TR_FILTER_MODE_LINEAR = 1
         } CUfilter_mode;</pre>
         This is ignored if
         CUDA_RESOURCE_DESC::resType is CU_RESOURCE_TYPE_LINEAR.
       </div>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <div>
         CUDA_TEXTURE_DESC::flags can
         be any combination of the following:
         <ul>
           <li>
             <p>CU_TRSF_READ_AS_INTEGER,
               which suppresses the default behavior of having the texture promote
               integer data to floating point data in the range [0,
               1]. Note that texture
               with 32-bit integer format would not be promoted, regardless of whether
               or not this flag is specified.
             </p>
           </li>
           <li>
             <p>CU_TRSF_NORMALIZED_COORDINATES, which suppresses the default behavior
               of having the texture coordinates range from [0, Dim) where Dim is the
               width or height
               of the CUDA array.
               Instead, the texture coordinates [0, 1.0) reference the entire breadth
               of the array dimension; Note that
               for CUDA mipmapped
               arrays, this flag has to be set.
             </p>
           </li>
         </ul>
       </div>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CUDA_TEXTURE_DESC::maxAnisotropy
         specifies the maximum anistropy ratio to be used when doing anisotropic
         filtering. This value will be clamped to the range
         [1,16].
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CUDA_TEXTURE_DESC::mipmapFilterMode
         specifies the filter mode when the calculated mipmap level lies between
         two defined mipmap levels.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CUDA_TEXTURE_DESC::mipmapLevelBias
         specifies the offset to be applied to the calculated mipmap level.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CUDA_TEXTURE_DESC::minMipmapLevelClamp
         specifies the lower end of the mipmap level range to clamp access to.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CUDA_TEXTURE_DESC::maxMipmapLevelClamp
         specifies the upper end of the mipmap level range to clamp access to.
       </p>
     </li>
   </ul>
   </p>
   <p>The CUDA_RESOURCE_VIEW_DESC struct is
     defined as 
   <pre>        typedef struct CUDA_RESOURCE_VIEW_DESC_st
         {
             CUresourceViewFormat format;
             size_t width;
             size_t height;
             size_t depth;
             unsigned int firstMipmapLevel;
             unsigned int lastMipmapLevel;
             unsigned int firstLayer;
             unsigned int lastLayer;
         } CUDA_RESOURCE_VIEW_DESC;</pre>
   where:
   <ul>
     <li>
       <p>CUDA_RESOURCE_VIEW_DESC::format
         specifies how the data contained in the CUDA array or CUDA mipmapped
         array should be interpreted. Note that this can incur
         a change in size of the texture
         data. If the resource view format is a block compressed format, then
         the underlying CUDA array
         or CUDA mipmapped array has to
         have a base of format CU_AD_FORMAT_UNSIGNED_INT32. with 2 or 4 channels,
         depending on the block compressed format. For ex., BC1 and BC4 require
         the underlying CUDA array to
         have a format of
         CU_AD_FORMAT_UNSIGNED_INT32 with 2 channels. The other BC formats
         require the underlying resource to have the same base format but with
         4 channels.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CUDA_RESOURCE_VIEW_DESC::width
         specifies the new width of the texture data. If the resource view
         format is a block compressed format, this value has to
         be 4 times the original width
         of the resource. For non block compressed formats, this value has to
         be equal to that of the
         original resource.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CUDA_RESOURCE_VIEW_DESC::height
         specifies the new height of the texture data. If the resource view
         format is a block compressed format, this value has to
         be 4 times the original height
         of the resource. For non block compressed formats, this value has to
         be equal to that of the
         original resource.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CUDA_RESOURCE_VIEW_DESC::depth
         specifies the new depth of the texture data. This value has to be equal
         to that of the original resource.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CUDA_RESOURCE_VIEW_DESC::firstMipmapLevel specifies the most detailed
         mipmap level. This will be the new mipmap level zero. For non-mipmapped
         resources, this value
         has to be
         zero.CUDA_TEXTURE_DESC::minMipmapLevelClamp and
         CUDA_TEXTURE_DESC::maxMipmapLevelClamp will be relative to this value.
         For ex., if the firstMipmapLevel is set to 2, and a minMipmapLevelClamp
         of 1.2 is specified,
         then the actual minimum mipmap
         level clamp will be 3.2.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CUDA_RESOURCE_VIEW_DESC::lastMipmapLevel
         specifies the least detailed mipmap level. For non-mipmapped resources,
         this value has to be zero.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CUDA_RESOURCE_VIEW_DESC::firstLayer
         specifies the first layer index for layered textures. This will be the
         new layer zero. For non-layered resources, this value
         has to be zero.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CUDA_RESOURCE_VIEW_DESC::lastLayer
         specifies the last layer index for layered textures. For non-layered
         resources, this value has to be zero.
       </p>
     </li>
   </ul>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pTexObject</CODE> - Texture object to create<DD><CODE>pResDesc</CODE> - Resource descriptor<DD><CODE>pTexDesc</CODE> - Texture descriptor<DD><CODE>pResViewDesc</CODE> - Resource view descriptor
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexObjectDestroy(jcuda.driver.CUtexObject)"><CODE>cuTexObjectDestroy(jcuda.driver.CUtexObject)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexObjectDestroy(jcuda.driver.CUtexObject)"><!-- --></A><H3>
cuTexObjectDestroy</H3>
<PRE>
public static int <B>cuTexObjectDestroy</B>(<A HREF="../../jcuda/driver/CUtexObject.html" title="class in jcuda.driver">CUtexObject</A>&nbsp;texObject)</PRE>
<DL>
<DD>Destroys a texture object.
 
 <pre>
 CUresult cuTexObjectDestroy (
      CUtexObject texObject )
 </pre>
 <div>
   <p>Destroys a texture object.  Destroys the
     texture object specified by <tt>texObject</tt>.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texObject</CODE> - Texture object to destroy
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexObjectCreate(jcuda.driver.CUtexObject, jcuda.driver.CUDA_RESOURCE_DESC, jcuda.driver.CUDA_TEXTURE_DESC, jcuda.driver.CUDA_RESOURCE_VIEW_DESC)"><CODE>cuTexObjectCreate(jcuda.driver.CUtexObject, jcuda.driver.CUDA_RESOURCE_DESC, jcuda.driver.CUDA_TEXTURE_DESC, jcuda.driver.CUDA_RESOURCE_VIEW_DESC)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexObjectGetResourceDesc(jcuda.driver.CUDA_RESOURCE_DESC, jcuda.driver.CUtexObject)"><!-- --></A><H3>
cuTexObjectGetResourceDesc</H3>
<PRE>
public static int <B>cuTexObjectGetResourceDesc</B>(<A HREF="../../jcuda/driver/CUDA_RESOURCE_DESC.html" title="class in jcuda.driver">CUDA_RESOURCE_DESC</A>&nbsp;pResDesc,
                                             <A HREF="../../jcuda/driver/CUtexObject.html" title="class in jcuda.driver">CUtexObject</A>&nbsp;texObject)</PRE>
<DL>
<DD>Returns a texture object's resource descriptor.
 
 <pre>
 CUresult cuTexObjectGetResourceDesc (
      CUDA_RESOURCE_DESC* pResDesc,
      CUtexObject texObject )
 </pre>
 <div>
   <p>Returns a texture object's resource
     descriptor.  Returns the resource descriptor for the texture object
     specified by <tt>texObject</tt>.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pResDesc</CODE> - Resource descriptor<DD><CODE>texObject</CODE> - Texture object
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexObjectCreate(jcuda.driver.CUtexObject, jcuda.driver.CUDA_RESOURCE_DESC, jcuda.driver.CUDA_TEXTURE_DESC, jcuda.driver.CUDA_RESOURCE_VIEW_DESC)"><CODE>cuTexObjectCreate(jcuda.driver.CUtexObject, jcuda.driver.CUDA_RESOURCE_DESC, jcuda.driver.CUDA_TEXTURE_DESC, jcuda.driver.CUDA_RESOURCE_VIEW_DESC)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexObjectGetTextureDesc(jcuda.driver.CUDA_TEXTURE_DESC, jcuda.driver.CUtexObject)"><!-- --></A><H3>
cuTexObjectGetTextureDesc</H3>
<PRE>
public static int <B>cuTexObjectGetTextureDesc</B>(<A HREF="../../jcuda/driver/CUDA_TEXTURE_DESC.html" title="class in jcuda.driver">CUDA_TEXTURE_DESC</A>&nbsp;pTexDesc,
                                            <A HREF="../../jcuda/driver/CUtexObject.html" title="class in jcuda.driver">CUtexObject</A>&nbsp;texObject)</PRE>
<DL>
<DD>Returns a texture object's texture descriptor.
 
 <pre>
 CUresult cuTexObjectGetTextureDesc (
      CUDA_TEXTURE_DESC* pTexDesc,
      CUtexObject texObject )
 </pre>
 <div>
   <p>Returns a texture object's texture
     descriptor.  Returns the texture descriptor for the texture object
     specified by <tt>texObject</tt>.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pTexDesc</CODE> - Texture descriptor<DD><CODE>texObject</CODE> - Texture object
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexObjectCreate(jcuda.driver.CUtexObject, jcuda.driver.CUDA_RESOURCE_DESC, jcuda.driver.CUDA_TEXTURE_DESC, jcuda.driver.CUDA_RESOURCE_VIEW_DESC)"><CODE>cuTexObjectCreate(jcuda.driver.CUtexObject, jcuda.driver.CUDA_RESOURCE_DESC, jcuda.driver.CUDA_TEXTURE_DESC, jcuda.driver.CUDA_RESOURCE_VIEW_DESC)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexObjectGetResourceViewDesc(jcuda.driver.CUDA_RESOURCE_VIEW_DESC, jcuda.driver.CUtexObject)"><!-- --></A><H3>
cuTexObjectGetResourceViewDesc</H3>
<PRE>
public static int <B>cuTexObjectGetResourceViewDesc</B>(<A HREF="../../jcuda/driver/CUDA_RESOURCE_VIEW_DESC.html" title="class in jcuda.driver">CUDA_RESOURCE_VIEW_DESC</A>&nbsp;pResViewDesc,
                                                 <A HREF="../../jcuda/driver/CUtexObject.html" title="class in jcuda.driver">CUtexObject</A>&nbsp;texObject)</PRE>
<DL>
<DD>Returns a texture object's resource view descriptor.
 
 <pre>
 CUresult cuTexObjectGetResourceViewDesc (
      CUDA_RESOURCE_VIEW_DESC* pResViewDesc,
      CUtexObject texObject )
 </pre>
 <div>
   <p>Returns a texture object's resource view
     descriptor.  Returns the resource view descriptor for the texture
     object specified
     by <tt>texObject</tt>. If no resource
     view was set for <tt>texObject</tt>, the CUDA_ERROR_INVALID_VALUE is
     returned.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pResViewDesc</CODE> - Resource view descriptor<DD><CODE>texObject</CODE> - Texture object
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexObjectCreate(jcuda.driver.CUtexObject, jcuda.driver.CUDA_RESOURCE_DESC, jcuda.driver.CUDA_TEXTURE_DESC, jcuda.driver.CUDA_RESOURCE_VIEW_DESC)"><CODE>cuTexObjectCreate(jcuda.driver.CUtexObject, jcuda.driver.CUDA_RESOURCE_DESC, jcuda.driver.CUDA_TEXTURE_DESC, jcuda.driver.CUDA_RESOURCE_VIEW_DESC)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuSurfObjectCreate(jcuda.driver.CUsurfObject, jcuda.driver.CUDA_RESOURCE_DESC)"><!-- --></A><H3>
cuSurfObjectCreate</H3>
<PRE>
public static int <B>cuSurfObjectCreate</B>(<A HREF="../../jcuda/driver/CUsurfObject.html" title="class in jcuda.driver">CUsurfObject</A>&nbsp;pSurfObject,
                                     <A HREF="../../jcuda/driver/CUDA_RESOURCE_DESC.html" title="class in jcuda.driver">CUDA_RESOURCE_DESC</A>&nbsp;pResDesc)</PRE>
<DL>
<DD>Creates a surface object.
 
 <pre>
 CUresult cuSurfObjectCreate (
      CUsurfObject* pSurfObject,
      const CUDA_RESOURCE_DESC* pResDesc )
 </pre>
 <div>
   <p>Creates a surface object.  Creates a
     surface object and returns it in <tt>pSurfObject</tt>. <tt>pResDesc</tt> describes the data to perform surface load/stores on.
     CUDA_RESOURCE_DESC::resType must be CU_RESOURCE_TYPE_ARRAY and
     CUDA_RESOURCE_DESC::res::array::hArray must be set to a valid CUDA
     array handle. CUDA_RESOURCE_DESC::flags must be set to zero.
   </p>
   <p>Surface objects are only supported on
     devices of compute capability 3.0 or higher.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pSurfObject</CODE> - Surface object to create<DD><CODE>pResDesc</CODE> - Resource descriptor
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuSurfObjectDestroy(jcuda.driver.CUsurfObject)"><CODE>cuSurfObjectDestroy(jcuda.driver.CUsurfObject)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuSurfObjectDestroy(jcuda.driver.CUsurfObject)"><!-- --></A><H3>
cuSurfObjectDestroy</H3>
<PRE>
public static int <B>cuSurfObjectDestroy</B>(<A HREF="../../jcuda/driver/CUsurfObject.html" title="class in jcuda.driver">CUsurfObject</A>&nbsp;surfObject)</PRE>
<DL>
<DD>Destroys a surface object.
 
 <pre>
 CUresult cuSurfObjectDestroy (
      CUsurfObject surfObject )
 </pre>
 <div>
   <p>Destroys a surface object.  Destroys the
     surface object specified by <tt>surfObject</tt>.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>surfObject</CODE> - Surface object to destroy
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuSurfObjectCreate(jcuda.driver.CUsurfObject, jcuda.driver.CUDA_RESOURCE_DESC)"><CODE>cuSurfObjectCreate(jcuda.driver.CUsurfObject, jcuda.driver.CUDA_RESOURCE_DESC)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuSurfObjectGetResourceDesc(jcuda.driver.CUDA_RESOURCE_DESC, jcuda.driver.CUsurfObject)"><!-- --></A><H3>
cuSurfObjectGetResourceDesc</H3>
<PRE>
public static int <B>cuSurfObjectGetResourceDesc</B>(<A HREF="../../jcuda/driver/CUDA_RESOURCE_DESC.html" title="class in jcuda.driver">CUDA_RESOURCE_DESC</A>&nbsp;pResDesc,
                                              <A HREF="../../jcuda/driver/CUsurfObject.html" title="class in jcuda.driver">CUsurfObject</A>&nbsp;surfObject)</PRE>
<DL>
<DD>Returns a surface object's resource descriptor.
 
 <pre>
 CUresult cuSurfObjectGetResourceDesc (
      CUDA_RESOURCE_DESC* pResDesc,
      CUsurfObject surfObject )
 </pre>
 <div>
   <p>Returns a surface object's resource
     descriptor.  Returns the resource descriptor for the surface object
     specified by <tt>surfObject</tt>.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pResDesc</CODE> - Resource descriptor<DD><CODE>surfObject</CODE> - Surface object
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuSurfObjectCreate(jcuda.driver.CUsurfObject, jcuda.driver.CUDA_RESOURCE_DESC)"><CODE>cuSurfObjectCreate(jcuda.driver.CUsurfObject, jcuda.driver.CUDA_RESOURCE_DESC)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuDeviceCanAccessPeer(int[], jcuda.driver.CUdevice, jcuda.driver.CUdevice)"><!-- --></A><H3>
cuDeviceCanAccessPeer</H3>
<PRE>
public static int <B>cuDeviceCanAccessPeer</B>(int[]&nbsp;canAccessPeer,
                                        <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev,
                                        <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;peerDev)</PRE>
<DL>
<DD>Queries if a device may directly access a peer device's memory.
 
 <pre>
 CUresult cuDeviceCanAccessPeer (
      int* canAccessPeer,
      CUdevice dev,
      CUdevice peerDev )
 </pre>
 <div>
   <p>Queries if a device may directly access
     a peer device's memory.  Returns in <tt>*canAccessPeer</tt> a value
     of 1 if contexts on <tt>dev</tt> are capable of directly accessing
     memory from contexts on <tt>peerDev</tt> and 0 otherwise. If direct
     access of <tt>peerDev</tt> from <tt>dev</tt> is possible, then access
     may be enabled on two specific contexts by calling
     cuCtxEnablePeerAccess().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>canAccessPeer</CODE> - Returned access capability<DD><CODE>dev</CODE> - Device from which allocations on peerDev are to be directly accessed.<DD><CODE>peerDev</CODE> - Device on which the allocations to be directly accessed by dev reside.
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_DEVICE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxEnablePeerAccess(jcuda.driver.CUcontext, int)"><CODE>cuCtxEnablePeerAccess(jcuda.driver.CUcontext, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDisablePeerAccess(jcuda.driver.CUcontext)"><CODE>cuCtxDisablePeerAccess(jcuda.driver.CUcontext)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxEnablePeerAccess(jcuda.driver.CUcontext, int)"><!-- --></A><H3>
cuCtxEnablePeerAccess</H3>
<PRE>
public static int <B>cuCtxEnablePeerAccess</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;peerContext,
                                        int&nbsp;Flags)</PRE>
<DL>
<DD>Enables direct access to memory allocations in a peer context.
 
 <pre>
 CUresult cuCtxEnablePeerAccess (
      CUcontext peerContext,
      unsigned int  Flags )
 </pre>
 <div>
   <p>Enables direct access to memory
     allocations in a peer context.  If both the current context and <tt>peerContext</tt> are on devices which support unified addressing (as
     may be queried using CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING) and same
     major compute capability, then on success all allocations from <tt>peerContext</tt> will immediately be accessible by the current context.
     See Unified Addressing for additional details.
   </p>
   <p>Note that access granted by this call
     is unidirectional and that in order to access memory from the current
     context in <tt>peerContext</tt>, a separate symmetric call to
     cuCtxEnablePeerAccess() is required.
   </p>
   <p>Returns CUDA_ERROR_PEER_ACCESS_UNSUPPORTED
     if cuDeviceCanAccessPeer() indicates that the CUdevice of the current
     context cannot directly access memory from the CUdevice of <tt>peerContext</tt>.
   </p>
   <p>Returns CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED
     if direct access of <tt>peerContext</tt> from the current context has
     already been enabled.
   </p>
   <p>Returns CUDA_ERROR_TOO_MANY_PEERS if
     direct peer access is not possible because hardware resources required
     for peer access have been exhausted.
   </p>
   <p>Returns CUDA_ERROR_INVALID_CONTEXT if
     there is no current context, <tt>peerContext</tt> is not a valid
     context, or if the current context is <tt>peerContext</tt>.
   </p>
   <p>Returns CUDA_ERROR_INVALID_VALUE if <tt>Flags</tt> is not 0.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>peerContext</CODE> - Peer context to enable direct access to from the current context<DD><CODE>Flags</CODE> - Reserved for future use and must be set to 0
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED, CUDA_ERROR_TOO_MANY_PEERS,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_PEER_ACCESS_UNSUPPORTED,
 CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceCanAccessPeer(int[], jcuda.driver.CUdevice, jcuda.driver.CUdevice)"><CODE>cuDeviceCanAccessPeer(int[], jcuda.driver.CUdevice, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDisablePeerAccess(jcuda.driver.CUcontext)"><CODE>cuCtxDisablePeerAccess(jcuda.driver.CUcontext)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxDisablePeerAccess(jcuda.driver.CUcontext)"><!-- --></A><H3>
cuCtxDisablePeerAccess</H3>
<PRE>
public static int <B>cuCtxDisablePeerAccess</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;peerContext)</PRE>
<DL>
<DD>Disables direct access to memory allocations in a peer context and unregisters any registered allocations.
 
 <pre>
 CUresult cuCtxDisablePeerAccess (
      CUcontext peerContext )
 </pre>
 <div>
   <p>Disables direct access to memory
     allocations in a peer context and unregisters any registered allocations.
     Returns CUDA_ERROR_PEER_ACCESS_NOT_ENABLED if direct peer access has
     not yet been enabled from <tt>peerContext</tt> to the current
     context.
   </p>
   <p>Returns CUDA_ERROR_INVALID_CONTEXT if
     there is no current context, or if <tt>peerContext</tt> is not a valid
     context.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>peerContext</CODE> - Peer context to disable direct access to
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_PEER_ACCESS_NOT_ENABLED, CUDA_ERROR_INVALID_CONTEXT,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceCanAccessPeer(int[], jcuda.driver.CUdevice, jcuda.driver.CUdevice)"><CODE>cuDeviceCanAccessPeer(int[], jcuda.driver.CUdevice, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxEnablePeerAccess(jcuda.driver.CUcontext, int)"><CODE>cuCtxEnablePeerAccess(jcuda.driver.CUcontext, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuParamSetSize(jcuda.driver.CUfunction, int)"><!-- --></A><H3>
cuParamSetSize</H3>
<PRE>
public static int <B>cuParamSetSize</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                                 int&nbsp;numbytes)</PRE>
<DL>
<DD>Sets the parameter size for the function.
 
 <pre>
 CUresult cuParamSetSize (
      CUfunction hfunc,
      unsigned int  numbytes )
 </pre>
 <div>
   <p>Sets the parameter size for the function.
     DeprecatedSets through <tt>numbytes</tt>
     the total size in bytes needed by the function parameters of the kernel
     corresponding to <tt>hfunc</tt>.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hfunc</CODE> - Kernel to set parameter size for<DD><CODE>numbytes</CODE> - Size of parameter list in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetSharedSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)"><CODE>cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)"><CODE>cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)"><CODE>cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuParamSeti(jcuda.driver.CUfunction, int, int)"><!-- --></A><H3>
cuParamSeti</H3>
<PRE>
public static int <B>cuParamSeti</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                              int&nbsp;offset,
                              int&nbsp;value)</PRE>
<DL>
<DD>Adds an integer parameter to the function's argument list.
 
 <pre>
 CUresult cuParamSeti (
      CUfunction hfunc,
      int  offset,
      unsigned int  value )
 </pre>
 <div>
   <p>Adds an integer parameter to the
     function's argument list.  
     DeprecatedSets an integer parameter that
     will be specified the next time the kernel corresponding to <tt>hfunc</tt> will be invoked. <tt>offset</tt> is a byte offset.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hfunc</CODE> - Kernel to add parameter to<DD><CODE>offset</CODE> - Offset to add parameter to argument list<DD><CODE>value</CODE> - Value of parameter
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetSharedSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)"><CODE>cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)"><CODE>cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)"><CODE>cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuParamSetf(jcuda.driver.CUfunction, int, float)"><!-- --></A><H3>
cuParamSetf</H3>
<PRE>
public static int <B>cuParamSetf</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                              int&nbsp;offset,
                              float&nbsp;value)</PRE>
<DL>
<DD>Adds a floating-point parameter to the function's argument list.
 
 <pre>
 CUresult cuParamSetf (
      CUfunction hfunc,
      int  offset,
      float  value )
 </pre>
 <div>
   <p>Adds a floating-point parameter to the
     function's argument list.  
     DeprecatedSets a floating-point parameter
     that will be specified the next time the kernel corresponding to <tt>hfunc</tt> will be invoked. <tt>offset</tt> is a byte offset.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hfunc</CODE> - Kernel to add parameter to<DD><CODE>offset</CODE> - Offset to add parameter to argument list<DD><CODE>value</CODE> - Value of parameter
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetSharedSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)"><CODE>cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)"><CODE>cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)"><CODE>cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><!-- --></A><H3>
cuParamSetv</H3>
<PRE>
public static int <B>cuParamSetv</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                              int&nbsp;offset,
                              <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr,
                              int&nbsp;numbytes)</PRE>
<DL>
<DD>Adds arbitrary data to the function's argument list.
 
 <pre>
 CUresult cuParamSetv (
      CUfunction hfunc,
      int  offset,
      void* ptr,
      unsigned int  numbytes )
 </pre>
 <div>
   <p>Adds arbitrary data to the function's
     argument list.  
     DeprecatedCopies an arbitrary amount of
     data (specified in <tt>numbytes</tt>) from <tt>ptr</tt> into the
     parameter space of the kernel corresponding to <tt>hfunc</tt>. <tt>offset</tt> is a byte offset.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hfunc</CODE> - Kernel to add data to<DD><CODE>offset</CODE> - Offset to add data to argument list<DD><CODE>ptr</CODE> - Pointer to arbitrary data<DD><CODE>numbytes</CODE> - Size of data to copy in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetSharedSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)"><CODE>cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)"><CODE>cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)"><CODE>cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)"><!-- --></A><H3>
cuParamSetTexRef</H3>
<PRE>
public static int <B>cuParamSetTexRef</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                                   int&nbsp;texunit,
                                   <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Adds a texture-reference to the function's argument list.
 
 <pre>
 CUresult cuParamSetTexRef (
      CUfunction hfunc,
      int  texunit,
      CUtexref hTexRef )
 </pre>
 <div>
   <p>Adds a texture-reference to the function's
     argument list.  
     DeprecatedMakes the CUDA array or linear
     memory bound to the texture reference <tt>hTexRef</tt> available to a
     device program as a texture. In this version of CUDA, the
     texture-reference must be obtained via cuModuleGetTexRef() and the <tt>texunit</tt> parameter must be set to CU_PARAM_TR_DEFAULT.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches. 
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hfunc</CODE> - Kernel to add texture-reference to<DD><CODE>texunit</CODE> - Texture unit (must be CU_PARAM_TR_DEFAULT)<DD><CODE>hTexRef</CODE> - Texture-reference to add to argument list
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE</DL>
</DD>
</DL>
<HR>

<A NAME="cuLaunch(jcuda.driver.CUfunction)"><!-- --></A><H3>
cuLaunch</H3>
<PRE>
public static int <B>cuLaunch</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;f)</PRE>
<DL>
<DD>Launches a CUDA function.
 
 <pre>
 CUresult cuLaunch (
      CUfunction f )
 </pre>
 <div>
   <p>Launches a CUDA function.  
     DeprecatedInvokes the kernel <tt>f</tt>
     on a 1 x 1 x 1 grid of blocks. The block contains the number of threads
     specified by a previous call to cuFuncSetBlockShape().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>f</CODE> - Kernel to launch
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_LAUNCH_FAILED, CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES,
 CUDA_ERROR_LAUNCH_TIMEOUT, CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,
 CUDA_ERROR_SHARED_OBJECT_INIT_FAILED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetSharedSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)"><CODE>cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)"><CODE>cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)"><CODE>cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><!-- --></A><H3>
cuLaunchGrid</H3>
<PRE>
public static int <B>cuLaunchGrid</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;f,
                               int&nbsp;grid_width,
                               int&nbsp;grid_height)</PRE>
<DL>
<DD>Launches a CUDA function.
 
 <pre>
 CUresult cuLaunchGrid (
      CUfunction f,
      int  grid_width,
      int  grid_height )
 </pre>
 <div>
   <p>Launches a CUDA function.  
     DeprecatedInvokes the kernel <tt>f</tt>
     on a <tt>grid_width</tt> x <tt>grid_height</tt> grid of blocks. Each
     block contains the number of threads specified by a previous call to
     cuFuncSetBlockShape().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>f</CODE> - Kernel to launch<DD><CODE>grid_width</CODE> - Width of grid in blocks<DD><CODE>grid_height</CODE> - Height of grid in blocks
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_LAUNCH_FAILED, CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES,
 CUDA_ERROR_LAUNCH_TIMEOUT, CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,
 CUDA_ERROR_SHARED_OBJECT_INIT_FAILED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetSharedSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)"><CODE>cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)"><CODE>cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)"><CODE>cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)"><!-- --></A><H3>
cuLaunchGridAsync</H3>
<PRE>
public static int <B>cuLaunchGridAsync</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;f,
                                    int&nbsp;grid_width,
                                    int&nbsp;grid_height,
                                    <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Launches a CUDA function.
 
 <pre>
 CUresult cuLaunchGridAsync (
      CUfunction f,
      int  grid_width,
      int  grid_height,
      CUstream hStream )
 </pre>
 <div>
   <p>Launches a CUDA function.  
     DeprecatedInvokes the kernel <tt>f</tt>
     on a <tt>grid_width</tt> x <tt>grid_height</tt> grid of blocks. Each
     block contains the number of threads specified by a previous call to
     cuFuncSetBlockShape().
   </p>
   <p>cuLaunchGridAsync() can optionally be
     associated to a stream by passing a non-zero <tt>hStream</tt>
     argument.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>f</CODE> - Kernel to launch<DD><CODE>grid_width</CODE> - Width of grid in blocks<DD><CODE>grid_height</CODE> - Height of grid in blocks<DD><CODE>hStream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_LAUNCH_FAILED,
 CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES, CUDA_ERROR_LAUNCH_TIMEOUT,
 CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,
 CUDA_ERROR_SHARED_OBJECT_INIT_FAILED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetSharedSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)"><CODE>cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)"><CODE>cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuEventCreate(jcuda.driver.CUevent, int)"><!-- --></A><H3>
cuEventCreate</H3>
<PRE>
public static int <B>cuEventCreate</B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;phEvent,
                                int&nbsp;Flags)</PRE>
<DL>
<DD>Creates an event.
 
 <pre>
 CUresult cuEventCreate (
      CUevent* phEvent,
      unsigned int  Flags )
 </pre>
 <div>
   <p>Creates an event.  Creates an event
     *phEvent with the flags specified via <tt>Flags</tt>. Valid flags
     include:
   <ul>
     <li>
       <p>CU_EVENT_DEFAULT: Default event
         creation flag.
       </p>
     </li>
     <li>
       <p>CU_EVENT_BLOCKING_SYNC:
         Specifies that the created event should use blocking synchronization.
         A CPU thread that uses cuEventSynchronize() to wait on an event created
         with this flag will block until the event has actually been recorded.
       </p>
     </li>
     <li>
       <p>CU_EVENT_DISABLE_TIMING:
         Specifies that the created event does not need to record timing data.
         Events created with this flag specified and the CU_EVENT_BLOCKING_SYNC
         flag not specified will provide the best performance when used with
         cuStreamWaitEvent() and cuEventQuery().
       </p>
     </li>
     <li>
       <p>CU_EVENT_INTERPROCESS: Specifies
         that the created event may be used as an interprocess event by
         cuIpcGetEventHandle(). CU_EVENT_INTERPROCESS must be specified along
         with CU_EVENT_DISABLE_TIMING.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>phEvent</CODE> - Returns newly created event<DD><CODE>Flags</CODE> - Event creation flags
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_OUT_OF_MEMORY<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)"><CODE>cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventQuery(jcuda.driver.CUevent)"><CODE>cuEventQuery(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventSynchronize(jcuda.driver.CUevent)"><CODE>cuEventSynchronize(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventDestroy(jcuda.driver.CUevent)"><CODE>cuEventDestroy(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)"><CODE>cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)"><!-- --></A><H3>
cuEventRecord</H3>
<PRE>
public static int <B>cuEventRecord</B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent,
                                <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Records an event.
 
 <pre>
 CUresult cuEventRecord (
      CUevent hEvent,
      CUstream hStream )
 </pre>
 <div>
   <p>Records an event.  Records an event. If
     <tt>hStream</tt> is non-zero, the event is recorded after all preceding
     operations in <tt>hStream</tt> have been completed; otherwise, it is
     recorded after all preceding operations in the CUDA context have been
     completed. Since
     operation is asynchronous, cuEventQuery
     and/or cuEventSynchronize() must be used to determine when the event
     has actually been recorded.
   </p>
   <p>If cuEventRecord() has previously been
     called on <tt>hEvent</tt>, then this call will overwrite any existing
     state in <tt>hEvent</tt>. Any subsequent calls which examine the
     status of <tt>hEvent</tt> will only examine the completion of this
     most recent call to cuEventRecord().
   </p>
   <p>It is necessary that <tt>hEvent</tt>
     and <tt>hStream</tt> be created on the same context.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hEvent</CODE> - Event to record<DD><CODE>hStream</CODE> - Stream to record event for
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventCreate(jcuda.driver.CUevent, int)"><CODE>cuEventCreate(jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventQuery(jcuda.driver.CUevent)"><CODE>cuEventQuery(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventSynchronize(jcuda.driver.CUevent)"><CODE>cuEventSynchronize(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)"><CODE>cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventDestroy(jcuda.driver.CUevent)"><CODE>cuEventDestroy(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)"><CODE>cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuEventQuery(jcuda.driver.CUevent)"><!-- --></A><H3>
cuEventQuery</H3>
<PRE>
public static int <B>cuEventQuery</B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent)</PRE>
<DL>
<DD>Queries an event's status.
 
 <pre>
 CUresult cuEventQuery (
      CUevent hEvent )
 </pre>
 <div>
   <p>Queries an event's status.  Query the
     status of all device work preceding the most recent call to
     cuEventRecord() (in the appropriate compute streams, as specified by
     the arguments to cuEventRecord()).
   </p>
   <p>If this work has successfully been
     completed by the device, or if cuEventRecord() has not been called on
     <tt>hEvent</tt>, then CUDA_SUCCESS is returned. If this work has not
     yet been completed by the device then CUDA_ERROR_NOT_READY is
     returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hEvent</CODE> - Event to query
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_HANDLE, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_NOT_READY<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventCreate(jcuda.driver.CUevent, int)"><CODE>cuEventCreate(jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)"><CODE>cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventSynchronize(jcuda.driver.CUevent)"><CODE>cuEventSynchronize(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventDestroy(jcuda.driver.CUevent)"><CODE>cuEventDestroy(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)"><CODE>cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuEventSynchronize(jcuda.driver.CUevent)"><!-- --></A><H3>
cuEventSynchronize</H3>
<PRE>
public static int <B>cuEventSynchronize</B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent)</PRE>
<DL>
<DD>Waits for an event to complete.
 
 <pre>
 CUresult cuEventSynchronize (
      CUevent hEvent )
 </pre>
 <div>
   <p>Waits for an event to complete.  Wait
     until the completion of all device work preceding the most recent call
     to cuEventRecord() (in the appropriate compute streams, as specified
     by the arguments to cuEventRecord()).
   </p>
   <p>If cuEventRecord() has not been called
     on <tt>hEvent</tt>, CUDA_SUCCESS is returned immediately.
   </p>
   <p>Waiting for an event that was created
     with the CU_EVENT_BLOCKING_SYNC flag will cause the calling CPU thread
     to block until the event has been completed by the device. If the
     CU_EVENT_BLOCKING_SYNC flag has not been set, then the CPU thread will
     busy-wait until the event has been completed by the device.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hEvent</CODE> - Event to wait for
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventCreate(jcuda.driver.CUevent, int)"><CODE>cuEventCreate(jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)"><CODE>cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventQuery(jcuda.driver.CUevent)"><CODE>cuEventQuery(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventDestroy(jcuda.driver.CUevent)"><CODE>cuEventDestroy(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)"><CODE>cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuEventDestroy(jcuda.driver.CUevent)"><!-- --></A><H3>
cuEventDestroy</H3>
<PRE>
public static int <B>cuEventDestroy</B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent)</PRE>
<DL>
<DD>Destroys an event.
 
 <pre>
 CUresult cuEventDestroy (
      CUevent hEvent )
 </pre>
 <div>
   <p>Destroys an event.  Destroys the event
     specified by <tt>hEvent</tt>.
   </p>
   <p>In case <tt>hEvent</tt> has been
     recorded but has not yet been completed when cuEventDestroy() is
     called, the function will return immediately and the resources
     associated with <tt>hEvent</tt> will be released automatically once
     the device has completed <tt>hEvent</tt>.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hEvent</CODE> - Event to destroy
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventCreate(jcuda.driver.CUevent, int)"><CODE>cuEventCreate(jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)"><CODE>cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventQuery(jcuda.driver.CUevent)"><CODE>cuEventQuery(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventSynchronize(jcuda.driver.CUevent)"><CODE>cuEventSynchronize(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)"><CODE>cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)"><!-- --></A><H3>
cuEventElapsedTime</H3>
<PRE>
public static int <B>cuEventElapsedTime</B>(float[]&nbsp;pMilliseconds,
                                     <A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hStart,
                                     <A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEnd)</PRE>
<DL>
<DD>Computes the elapsed time between two events.
 
 <pre>
 CUresult cuEventElapsedTime (
      float* pMilliseconds,
      CUevent hStart,
      CUevent hEnd )
 </pre>
 <div>
   <p>Computes the elapsed time between two
     events.  Computes the elapsed time between two events (in milliseconds
     with a resolution
     of around 0.5 microseconds).
   </p>
   <p>If either event was last recorded in a
     non-NULL stream, the resulting time may be greater than expected (even
     if both used
     the same stream handle). This happens
     because the cuEventRecord() operation takes place asynchronously and
     there is no guarantee that the measured latency is actually just
     between the two
     events. Any number of other different
     stream operations could execute in between the two measured events,
     thus altering the
     timing in a significant way.
   </p>
   <p>If cuEventRecord() has not been called
     on either event then CUDA_ERROR_INVALID_HANDLE is returned. If
     cuEventRecord() has been called on both events but one or both of them
     has not yet been completed (that is, cuEventQuery() would return
     CUDA_ERROR_NOT_READY on at least one of the events), CUDA_ERROR_NOT_READY
     is returned. If either event was created with the CU_EVENT_DISABLE_TIMING
     flag, then this function will return CUDA_ERROR_INVALID_HANDLE.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pMilliseconds</CODE> - Time between hStart and hEnd in ms<DD><CODE>hStart</CODE> - Starting event<DD><CODE>hEnd</CODE> - Ending event
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_NOT_READY<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventCreate(jcuda.driver.CUevent, int)"><CODE>cuEventCreate(jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)"><CODE>cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventQuery(jcuda.driver.CUevent)"><CODE>cuEventQuery(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventSynchronize(jcuda.driver.CUevent)"><CODE>cuEventSynchronize(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventDestroy(jcuda.driver.CUevent)"><CODE>cuEventDestroy(jcuda.driver.CUevent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuPointerGetAttribute(jcuda.Pointer, int, jcuda.driver.CUdeviceptr)"><!-- --></A><H3>
cuPointerGetAttribute</H3>
<PRE>
public static int <B>cuPointerGetAttribute</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;data,
                                        int&nbsp;attribute,
                                        <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;ptr)</PRE>
<DL>
<DD>Returns information about a pointer.
 
 <pre>
 CUresult cuPointerGetAttribute (
      void* data,
      CUpointer_attribute attribute,
      CUdeviceptr ptr )
 </pre>
 <div>
   <p>Returns information about a pointer. 
     The supported attributes are:
   </p>
   <ul>
     <li>
       <p>CU_POINTER_ATTRIBUTE_CONTEXT:
       </p>
     </li>
   </ul>
   </p>
   <p>Returns in <tt>*data</tt> the CUcontext
     in which <tt>ptr</tt> was allocated or registered. The type of <tt>data</tt> must be CUcontext *.
   </p>
   <p>If <tt>ptr</tt> was not allocated by,
     mapped by, or registered with a CUcontext which uses unified virtual
     addressing then CUDA_ERROR_INVALID_VALUE is returned.
   </p>
   <ul>
     <li>
       <p>CU_POINTER_ATTRIBUTE_MEMORY_TYPE:
       </p>
     </li>
   </ul>
   </p>
   <p>Returns in <tt>*data</tt> the physical
     memory type of the memory that <tt>ptr</tt> addresses as a CUmemorytype
     enumerated value. The type of <tt>data</tt> must be unsigned int.
   </p>
   <p>If <tt>ptr</tt> addresses device memory
     then <tt>*data</tt> is set to CU_MEMORYTYPE_DEVICE. The particular
     CUdevice on which the memory resides is the CUdevice of the CUcontext
     returned by the CU_POINTER_ATTRIBUTE_CONTEXT attribute of <tt>ptr</tt>.
   </p>
   <p>If <tt>ptr</tt> addresses host memory
     then <tt>*data</tt> is set to CU_MEMORYTYPE_HOST.
   </p>
   <p>If <tt>ptr</tt> was not allocated by,
     mapped by, or registered with a CUcontext which uses unified virtual
     addressing then CUDA_ERROR_INVALID_VALUE is returned.
   </p>
   <p>If the current CUcontext does not
     support unified virtual addressing then CUDA_ERROR_INVALID_CONTEXT is
     returned.
   </p>
   <ul>
     <li>
       <p>CU_POINTER_ATTRIBUTE_DEVICE_POINTER:
       </p>
     </li>
   </ul>
   </p>
   <p>Returns in <tt>*data</tt> the device
     pointer value through which <tt>ptr</tt> may be accessed by kernels
     running in the current CUcontext. The type of <tt>data</tt> must be
     CUdeviceptr *.
   </p>
   <p>If there exists no device pointer value
     through which kernels running in the current CUcontext may access <tt>ptr</tt> then CUDA_ERROR_INVALID_VALUE is returned.
   </p>
   <p>If there is no current CUcontext then
     CUDA_ERROR_INVALID_CONTEXT is returned.
   </p>
   <p>Except in the exceptional disjoint
     addressing cases discussed below, the value returned in <tt>*data</tt>
     will equal the input value <tt>ptr</tt>.
   </p>
   <ul>
     <li>
       <p>CU_POINTER_ATTRIBUTE_HOST_POINTER:
       </p>
     </li>
   </ul>
   </p>
   <p>Returns in <tt>*data</tt> the host
     pointer value through which <tt>ptr</tt> may be accessed by by the
     host program. The type of <tt>data</tt> must be void **. If there
     exists no host pointer value through which the host program may directly
     access <tt>ptr</tt> then CUDA_ERROR_INVALID_VALUE is returned.
   </p>
   <p>Except in the exceptional disjoint
     addressing cases discussed below, the value returned in <tt>*data</tt>
     will equal the input value <tt>ptr</tt>.
   </p>
   <ul>
     <li>
       <p>CU_POINTER_ATTRIBUTE_P2P_TOKENS:
       </p>
     </li>
   </ul>
   </p>
   <p>Returns in <tt>*data</tt> two tokens
     for use with the nv-p2p.h Linux kernel interface. <tt>data</tt> must
     be a struct of type CUDA_POINTER_ATTRIBUTE_P2P_TOKENS.
   </p>
   <p><tt>ptr</tt> must be a pointer to
     memory obtained from :cuMemAlloc(). Note that p2pToken and vaSpaceToken
     are only valid for the lifetime of the source allocation. A subsequent
     allocation at
     the same address may return completely
     different tokens.
   </p>
   <p>
     Note that for most allocations in the
     unified virtual address space the host and device pointer for accessing
     the allocation
     will be the same. The exceptions to this
     are
   <ul>
     <li>
       <p>user memory registered using
         cuMemHostRegister
       </p>
     </li>
     <li>
       <p>host memory allocated using
         cuMemHostAlloc with the CU_MEMHOSTALLOC_WRITECOMBINED flag For these
         types of allocation there will exist separate, disjoint host and device
         addresses for accessing the allocation.
         In particular
       </p>
     </li>
     <li>
       <p>The host address will correspond
         to an invalid unmapped device address (which will result in an exception
         if accessed from
         the device)
       </p>
     </li>
     <li>
       <p>The device address will
         correspond to an invalid unmapped host address (which will result in
         an exception if accessed from
         the host). For these types of
         allocations, querying CU_POINTER_ATTRIBUTE_HOST_POINTER and
         CU_POINTER_ATTRIBUTE_DEVICE_POINTER may be used to retrieve the host
         and device addresses from either address.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - Returned pointer attribute value<DD><CODE>attribute</CODE> - Pointer attribute to query<DD><CODE>ptr</CODE> - Pointer
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_INVALID_DEVICE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, long)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, long)"><CODE>cuMemAllocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostRegister(jcuda.Pointer, long, int)"><CODE>cuMemHostRegister(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostUnregister(jcuda.Pointer)"><CODE>cuMemHostUnregister(jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuStreamCreate(jcuda.driver.CUstream, int)"><!-- --></A><H3>
cuStreamCreate</H3>
<PRE>
public static int <B>cuStreamCreate</B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;phStream,
                                 int&nbsp;Flags)</PRE>
<DL>
<DD>Create a stream.
 
 <pre>
 CUresult cuStreamCreate (
      CUstream* phStream,
      unsigned int  Flags )
 </pre>
 <div>
   <p>Create a stream.  Creates a stream and
     returns a handle in <tt>phStream</tt>. The <tt>Flags</tt> argument
     determines behaviors of the stream. Valid values for <tt>Flags</tt>
     are:
   <ul>
     <li>
       <p>CU_STREAM_DEFAULT: Default
         stream creation flag.
       </p>
     </li>
     <li>
       <p>CU_STREAM_NON_BLOCKING:
         Specifies that work running in the created stream may run concurrently
         with work in stream 0 (the NULL stream), and that
         the created stream should
         perform no implicit synchronization with stream 0.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>phStream</CODE> - Returned newly created stream<DD><CODE>Flags</CODE> - Parameters for stream creation
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_OUT_OF_MEMORY<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamDestroy(jcuda.driver.CUstream)"><CODE>cuStreamDestroy(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)"><CODE>cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamQuery(jcuda.driver.CUstream)"><CODE>cuStreamQuery(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamSynchronize(jcuda.driver.CUstream)"><CODE>cuStreamSynchronize(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamAddCallback(jcuda.driver.CUstream, jcuda.driver.CUstreamCallback, java.lang.Object, int)"><CODE>cuStreamAddCallback(jcuda.driver.CUstream, jcuda.driver.CUstreamCallback, java.lang.Object, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)"><!-- --></A><H3>
cuStreamWaitEvent</H3>
<PRE>
public static int <B>cuStreamWaitEvent</B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream,
                                    <A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent,
                                    int&nbsp;Flags)</PRE>
<DL>
<DD>Make a compute stream wait on an event.
 
 <pre>
 CUresult cuStreamWaitEvent (
      CUstream hStream,
      CUevent hEvent,
      unsigned int  Flags )
 </pre>
 <div>
   <p>Make a compute stream wait on an event. 
     Makes all future work submitted to <tt>hStream</tt> wait until <tt>hEvent</tt> reports completion before beginning execution. This
     synchronization will be performed efficiently on the device. The event
     <tt>hEvent</tt> may be from a different
     context than <tt>hStream</tt>, in which case this function will
     perform cross-device synchronization.
   </p>
   <p>The stream <tt>hStream</tt> will wait
     only for the completion of the most recent host call to cuEventRecord()
     on <tt>hEvent</tt>. Once this call has returned, any functions
     (including cuEventRecord() and cuEventDestroy()) may be called on <tt>hEvent</tt> again, and subsequent calls will not have any effect on
     <tt>hStream</tt>.
   </p>
   <p>If <tt>hStream</tt> is 0 (the NULL
     stream) any future work submitted in any stream will wait for <tt>hEvent</tt> to complete before beginning execution. This effectively
     creates a barrier for all future work submitted to the context.
   </p>
   <p>If cuEventRecord() has not been called
     on <tt>hEvent</tt>, this call acts as if the record has already
     completed, and so is a functional no-op.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hStream</CODE> - Stream to wait<DD><CODE>hEvent</CODE> - Event to wait on (may not be NULL)<DD><CODE>Flags</CODE> - Parameters for the operation (must be 0)
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamCreate(jcuda.driver.CUstream, int)"><CODE>cuStreamCreate(jcuda.driver.CUstream, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)"><CODE>cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamQuery(jcuda.driver.CUstream)"><CODE>cuStreamQuery(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamSynchronize(jcuda.driver.CUstream)"><CODE>cuStreamSynchronize(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamAddCallback(jcuda.driver.CUstream, jcuda.driver.CUstreamCallback, java.lang.Object, int)"><CODE>cuStreamAddCallback(jcuda.driver.CUstream, jcuda.driver.CUstreamCallback, java.lang.Object, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamDestroy(jcuda.driver.CUstream)"><CODE>cuStreamDestroy(jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuStreamAddCallback(jcuda.driver.CUstream, jcuda.driver.CUstreamCallback, java.lang.Object, int)"><!-- --></A><H3>
cuStreamAddCallback</H3>
<PRE>
public static int <B>cuStreamAddCallback</B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream,
                                      <A HREF="../../jcuda/driver/CUstreamCallback.html" title="interface in jcuda.driver">CUstreamCallback</A>&nbsp;callback,
                                      java.lang.Object&nbsp;userData,
                                      int&nbsp;flags)</PRE>
<DL>
<DD>Add a callback to a compute stream.
 
 <pre>
 CUresult cuStreamAddCallback (
      CUstream hStream,
      CUstreamCallback callback,
      void* userData,
      unsigned int  flags )
 </pre>
 <div>
   <p>Add a callback to a compute stream.  Adds
     a callback to be called on the host after all currently enqueued items
     in the stream
     have completed. For each cuStreamAddCallback
     call, the callback will be executed exactly once. The callback will
     block later
     work in the stream until it is finished.
   </p>
   <p>The callback may be passed CUDA_SUCCESS
     or an error code. In the event of a device error, all subsequently
     executed callbacks will receive an appropriate CUresult.
   </p>
   <p>Callbacks must not make any CUDA API
     calls. Attempting to use a CUDA API will result in CUDA_ERROR_NOT_PERMITTED.
     Callbacks must not perform any synchronization that may depend on
     outstanding device work or other callbacks that are not
     mandated to run earlier. Callbacks
     without a mandated order (in independent streams) execute in undefined
     order and may be
     serialized.
   </p>
   <p>This API requires compute capability
     1.1 or greater. See cuDeviceGetAttribute or cuDeviceGetProperties to
     query compute capability. Attempting to use this API with earlier
     compute versions will return CUDA_ERROR_NOT_SUPPORTED.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hStream</CODE> - Stream to add callback to<DD><CODE>callback</CODE> - The function to call once preceding stream operations are complete<DD><CODE>userData</CODE> - User specified data to be passed to the callback function<DD><CODE>flags</CODE> - Reserved for future use, must be 0
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_NOT_SUPPORTED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamCreate(jcuda.driver.CUstream, int)"><CODE>cuStreamCreate(jcuda.driver.CUstream, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamQuery(jcuda.driver.CUstream)"><CODE>cuStreamQuery(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamSynchronize(jcuda.driver.CUstream)"><CODE>cuStreamSynchronize(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)"><CODE>cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamDestroy(jcuda.driver.CUstream)"><CODE>cuStreamDestroy(jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuStreamQuery(jcuda.driver.CUstream)"><!-- --></A><H3>
cuStreamQuery</H3>
<PRE>
public static int <B>cuStreamQuery</B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Determine status of a compute stream.
 
 <pre>
 CUresult cuStreamQuery (
      CUstream hStream )
 </pre>
 <div>
   <p>Determine status of a compute stream. 
     Returns CUDA_SUCCESS if all operations in the stream specified by <tt>hStream</tt> have completed, or CUDA_ERROR_NOT_READY if not.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hStream</CODE> - Stream to query status of
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_NOT_READY<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamCreate(jcuda.driver.CUstream, int)"><CODE>cuStreamCreate(jcuda.driver.CUstream, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)"><CODE>cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamDestroy(jcuda.driver.CUstream)"><CODE>cuStreamDestroy(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamSynchronize(jcuda.driver.CUstream)"><CODE>cuStreamSynchronize(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamAddCallback(jcuda.driver.CUstream, jcuda.driver.CUstreamCallback, java.lang.Object, int)"><CODE>cuStreamAddCallback(jcuda.driver.CUstream, jcuda.driver.CUstreamCallback, java.lang.Object, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuStreamSynchronize(jcuda.driver.CUstream)"><!-- --></A><H3>
cuStreamSynchronize</H3>
<PRE>
public static int <B>cuStreamSynchronize</B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Wait until a stream's tasks are completed.
 
 <pre>
 CUresult cuStreamSynchronize (
      CUstream hStream )
 </pre>
 <div>
   <p>Wait until a stream's tasks are completed.
     Waits until the device has completed all operations in the stream
     specified by
     <tt>hStream</tt>. If the context was
     created with the CU_CTX_SCHED_BLOCKING_SYNC flag, the CPU thread will
     block until the stream is finished with all of its tasks.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hStream</CODE> - Stream to wait for
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamCreate(jcuda.driver.CUstream, int)"><CODE>cuStreamCreate(jcuda.driver.CUstream, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamDestroy(jcuda.driver.CUstream)"><CODE>cuStreamDestroy(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)"><CODE>cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamQuery(jcuda.driver.CUstream)"><CODE>cuStreamQuery(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamAddCallback(jcuda.driver.CUstream, jcuda.driver.CUstreamCallback, java.lang.Object, int)"><CODE>cuStreamAddCallback(jcuda.driver.CUstream, jcuda.driver.CUstreamCallback, java.lang.Object, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuStreamDestroy(jcuda.driver.CUstream)"><!-- --></A><H3>
cuStreamDestroy</H3>
<PRE>
public static int <B>cuStreamDestroy</B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Destroys a stream.
 
 <pre>
 CUresult cuStreamDestroy (
      CUstream hStream )
 </pre>
 <div>
   <p>Destroys a stream.  Destroys the stream
     specified by <tt>hStream</tt>.
   </p>
   <p>In case the device is still doing work
     in the stream <tt>hStream</tt> when cuStreamDestroy() is called, the
     function will return immediately and the resources associated with <tt>hStream</tt> will be released automatically once the device has
     completed all work in <tt>hStream</tt>.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hStream</CODE> - Stream to destroy
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamCreate(jcuda.driver.CUstream, int)"><CODE>cuStreamCreate(jcuda.driver.CUstream, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)"><CODE>cuStreamWaitEvent(jcuda.driver.CUstream, jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamQuery(jcuda.driver.CUstream)"><CODE>cuStreamQuery(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamSynchronize(jcuda.driver.CUstream)"><CODE>cuStreamSynchronize(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamAddCallback(jcuda.driver.CUstream, jcuda.driver.CUstreamCallback, java.lang.Object, int)"><CODE>cuStreamAddCallback(jcuda.driver.CUstream, jcuda.driver.CUstreamCallback, java.lang.Object, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLInit()"><!-- --></A><H3>
cuGLInit</H3>
<PRE>
public static int <B>cuGLInit</B>()</PRE>
<DL>
<DD>Initializes OpenGL interoperability.
 
 <pre>
 CUresult cuGLInit (
      void )
 </pre>
 <div>
   <p>Initializes OpenGL interoperability. 
     Deprecated<span>This function is
     deprecated as of Cuda 3.0.</span>Initializes OpenGL interoperability.
     This function is deprecated and calling it is no longer required. It
     may fail if the
     needed OpenGL driver facilities are
     not available.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that
       this function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_UNKNOWN<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLMapBufferObject(jcuda.driver.CUdeviceptr, long[], int)"><CODE>cuGLMapBufferObject(jcuda.driver.CUdeviceptr, long[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLRegisterBufferObject(int)"><CODE>cuGLRegisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnmapBufferObject(int)"><CODE>cuGLUnmapBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnregisterBufferObject(int)"><CODE>cuGLUnregisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLMapBufferObjectAsync(jcuda.driver.CUdeviceptr, long[], int, jcuda.driver.CUstream)"><CODE>cuGLMapBufferObjectAsync(jcuda.driver.CUdeviceptr, long[], int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnmapBufferObjectAsync(int, jcuda.driver.CUstream)"><CODE>cuGLUnmapBufferObjectAsync(int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLSetBufferObjectMapFlags(int, int)"><CODE>cuGLSetBufferObjectMapFlags(int, int)</CODE></A>, 
<CODE>JCudaDriver#cuWGLGetDevice</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><!-- --></A><H3>
cuGLCtxCreate</H3>
<PRE>
public static int <B>cuGLCtxCreate</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pCtx,
                                int&nbsp;Flags,
                                <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;device)</PRE>
<DL>
<DD>Create a CUDA context for interoperability with OpenGL.
 
 <pre>
 CUresult cuGLCtxCreate (
      CUcontext* pCtx,
      unsigned int  Flags,
      CUdevice device )
 </pre>
 <div>
   <p>Create a CUDA context for
     interoperability with OpenGL.  
     Deprecated<span>This function is
     deprecated as of Cuda 5.0.</span>This function is deprecated and should
     no longer be used. It is no longer necessary to associate a CUDA
     context with an OpenGL
     context in order to achieve maximum
     interoperability performance.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that
       this function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCtx</CODE> - Returned CUDA context<DD><CODE>Flags</CODE> - Options for CUDA context creation<DD><CODE>device</CODE> - Device on which to create the context
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_OUT_OF_MEMORY<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLInit()"><CODE>cuGLInit()</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLMapBufferObject(jcuda.driver.CUdeviceptr, long[], int)"><CODE>cuGLMapBufferObject(jcuda.driver.CUdeviceptr, long[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLRegisterBufferObject(int)"><CODE>cuGLRegisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnmapBufferObject(int)"><CODE>cuGLUnmapBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnregisterBufferObject(int)"><CODE>cuGLUnregisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLMapBufferObjectAsync(jcuda.driver.CUdeviceptr, long[], int, jcuda.driver.CUstream)"><CODE>cuGLMapBufferObjectAsync(jcuda.driver.CUdeviceptr, long[], int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnmapBufferObjectAsync(int, jcuda.driver.CUstream)"><CODE>cuGLUnmapBufferObjectAsync(int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLSetBufferObjectMapFlags(int, int)"><CODE>cuGLSetBufferObjectMapFlags(int, int)</CODE></A>, 
<CODE>JCudaDriver#cuWGLGetDevice</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLGetDevices(int[], jcuda.driver.CUdevice[], int, int)"><!-- --></A><H3>
cuGLGetDevices</H3>
<PRE>
public static int <B>cuGLGetDevices</B>(int[]&nbsp;pCudaDeviceCount,
                                 <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>[]&nbsp;pCudaDevices,
                                 int&nbsp;cudaDeviceCount,
                                 int&nbsp;CUGLDeviceList_deviceList)</PRE>
<DL>
<DD>Gets the CUDA devices associated with the current OpenGL context.
 
 <pre>
 CUresult cuGLGetDevices (
      unsigned int* pCudaDeviceCount,
      CUdevice* pCudaDevices,
      unsigned int  cudaDeviceCount,
      CUGLDeviceList deviceList )
 </pre>
 <div>
   <p>Gets the CUDA devices associated with
     the current OpenGL context.  Returns in <tt>*pCudaDeviceCount</tt>
     the number of CUDA-compatible devices corresponding to the current
     OpenGL context. Also returns in <tt>*pCudaDevices</tt> at most
     cudaDeviceCount of the CUDA-compatible devices corresponding to the
     current OpenGL context. If any of the GPUs being
     used by the current OpenGL context are
     not CUDA capable then the call will return CUDA_ERROR_NO_DEVICE.
   </p>
   <p>The <tt>deviceList</tt> argument may
     be any of the following:
   <ul>
     <li>
       <p>CU_GL_DEVICE_LIST_ALL: Query
         all devices used by the current OpenGL context.
       </p>
     </li>
     <li>
       <p>CU_GL_DEVICE_LIST_CURRENT_FRAME:
         Query the devices used by the current OpenGL context to render the
         current frame (in SLI).
       </p>
     </li>
     <li>
       <p>CU_GL_DEVICE_LIST_NEXT_FRAME:
         Query the devices used by the current OpenGL context to render the next
         frame (in SLI). Note that this is a prediction,
         it can't be guaranteed that this
         is correct in all cases.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCudaDeviceCount</CODE> - Returned number of CUDA devices.<DD><CODE>pCudaDevices</CODE> - Returned CUDA devices.<DD><CODE>cudaDeviceCount</CODE> - The size of the output device array pCudaDevices.<DD><CODE>deviceList</CODE> - The set of devices to return.
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_NO_DEVICE,
 CUDA_ERROR_INVALID_VALUECUDA_ERROR_INVALID_CONTEXT<DT><B>See Also:</B><DD><CODE>JCudaDriver#cuWGLGetDevice</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="cuGraphicsGLRegisterBuffer(jcuda.driver.CUgraphicsResource, int, int)"><!-- --></A><H3>
cuGraphicsGLRegisterBuffer</H3>
<PRE>
public static int <B>cuGraphicsGLRegisterBuffer</B>(<A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;pCudaResource,
                                             int&nbsp;buffer,
                                             int&nbsp;Flags)</PRE>
<DL>
<DD>Registers an OpenGL buffer object.
 
 <pre>
 CUresult cuGraphicsGLRegisterBuffer (
      CUgraphicsResource* pCudaResource,
      GLuint buffer,
      unsigned int  Flags )
 </pre>
 <div>
   <p>Registers an OpenGL buffer object. 
     Registers the buffer object specified by <tt>buffer</tt> for access
     by CUDA. A handle to the registered object is returned as <tt>pCudaResource</tt>. The register flags <tt>Flags</tt> specify the
     intended usage, as follows:
   </p>
   <ul>
     <li>
       <p>CU_GRAPHICS_REGISTER_FLAGS_NONE:
         Specifies no hints about how this resource will be used. It is therefore
         assumed that this
         resource will be read from and
         written to by CUDA. This is the default value.
       </p>
     </li>
     <li>
       <p>CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY:
         Specifies that CUDA will not write to this resource.
       </p>
     </li>
     <li>
       <p>CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD: Specifies that CUDA will
         not read from this resource and will write over the entire
         contents of the resource, so
         none of the data previously stored in the resource will be preserved.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCudaResource</CODE> - Pointer to the returned object handle<DD><CODE>buffer</CODE> - name of buffer object to be registered<DD><CODE>Flags</CODE> - Register flags
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_HANDLE, CUDA_ERROR_ALREADY_MAPPED,
 CUDA_ERROR_INVALID_CONTEXT,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsUnregisterResource(jcuda.driver.CUgraphicsResource)"><CODE>cuGraphicsUnregisterResource(jcuda.driver.CUgraphicsResource)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><CODE>cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsResourceGetMappedPointer(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUgraphicsResource)"><CODE>cuGraphicsResourceGetMappedPointer(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUgraphicsResource)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGraphicsGLRegisterImage(jcuda.driver.CUgraphicsResource, int, int, int)"><!-- --></A><H3>
cuGraphicsGLRegisterImage</H3>
<PRE>
public static int <B>cuGraphicsGLRegisterImage</B>(<A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;pCudaResource,
                                            int&nbsp;image,
                                            int&nbsp;target,
                                            int&nbsp;Flags)</PRE>
<DL>
<DD>Register an OpenGL texture or renderbuffer object.
 
 <pre>
 CUresult cuGraphicsGLRegisterImage (
      CUgraphicsResource* pCudaResource,
      GLuint image,
      GLenum target,
      unsigned int  Flags )
 </pre>
 <div>
   <p>Register an OpenGL texture or renderbuffer
     object.  Registers the texture or renderbuffer object specified by <tt>image</tt> for access by CUDA. A handle to the registered object is
     returned as <tt>pCudaResource</tt>.
   </p>
   <p><tt>target</tt> must match the type of
     the object, and must be one of GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE,
     GL_TEXTURE_CUBE_MAP, GL_TEXTURE_3D,
     GL_TEXTURE_2D_ARRAY, or GL_RENDERBUFFER.
   </p>
   <p>The register flags <tt>Flags</tt>
     specify the intended usage, as follows:
   </p>
   <ul>
     <li>
       <p>CU_GRAPHICS_REGISTER_FLAGS_NONE:
         Specifies no hints about how this resource will be used. It is therefore
         assumed that this
         resource will be read from and
         written to by CUDA. This is the default value.
       </p>
     </li>
     <li>
       <p>CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY:
         Specifies that CUDA will not write to this resource.
       </p>
     </li>
     <li>
       <p>CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD: Specifies that CUDA will
         not read from this resource and will write over the entire
         contents of the resource, so
         none of the data previously stored in the resource will be preserved.
       </p>
     </li>
     <li>
       <p>CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST:
         Specifies that CUDA will bind this resource to a surface
         reference.
       </p>
     </li>
     <li>
       <p>CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER: Specifies that CUDA will
         perform texture gather operations on this resource.
       </p>
     </li>
   </ul>
   </p>
   <p>The following image formats are
     supported. For brevity's sake, the list is abbreviated. For ex., {GL_R,
     GL_RG} X {8, 16} would
     expand to the following 4 formats {GL_R8,
     GL_R16, GL_RG8, GL_RG16} :
   <ul>
     <li>
       <p>GL_RED, GL_RG, GL_RGBA,
         GL_LUMINANCE, GL_ALPHA, GL_LUMINANCE_ALPHA, GL_INTENSITY
       </p>
     </li>
     <li>
       <p>{GL_R, GL_RG, GL_RGBA} X {8,
         16, 16F, 32F, 8UI, 16UI, 32UI, 8I, 16I, 32I}
       </p>
     </li>
     <li>
       <p>{GL_LUMINANCE, GL_ALPHA,
         GL_LUMINANCE_ALPHA, GL_INTENSITY} X {8, 16, 16F_ARB, 32F_ARB, 8UI_EXT,
         16UI_EXT, 32UI_EXT, 8I_EXT,
         16I_EXT, 32I_EXT}
       </p>
     </li>
   </ul>
   </p>
   <p>The following image classes are currently
     disallowed:
   <ul>
     <li>
       <p>Textures with borders</p>
     </li>
     <li>
       <p>Multisampled renderbuffers</p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCudaResource</CODE> - Pointer to the returned object handle<DD><CODE>image</CODE> - name of texture or renderbuffer object to be registered<DD><CODE>target</CODE> - Identifies the type of object specified by image<DD><CODE>Flags</CODE> - Register flags
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_HANDLE, CUDA_ERROR_ALREADY_MAPPED,
 CUDA_ERROR_INVALID_CONTEXT,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsUnregisterResource(jcuda.driver.CUgraphicsResource)"><CODE>cuGraphicsUnregisterResource(jcuda.driver.CUgraphicsResource)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><CODE>cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsSubResourceGetMappedArray(jcuda.driver.CUarray, jcuda.driver.CUgraphicsResource, int, int)"><CODE>cuGraphicsSubResourceGetMappedArray(jcuda.driver.CUarray, jcuda.driver.CUgraphicsResource, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLRegisterBufferObject(int)"><!-- --></A><H3>
cuGLRegisterBufferObject</H3>
<PRE>
public static int <B>cuGLRegisterBufferObject</B>(int&nbsp;bufferobj)</PRE>
<DL>
<DD>Registers an OpenGL buffer object.
 
 <pre>
 CUresult cuGLRegisterBufferObject (
      GLuint buffer )
 </pre>
 <div>
   <p>Registers an OpenGL buffer object.  
     Deprecated<span>This function is
     deprecated as of Cuda 3.0.</span>Registers the buffer object specified
     by <tt>buffer</tt> for access by CUDA. This function must be called
     before CUDA can map the buffer object. There must be a valid OpenGL
     context
     bound to the current thread when this
     function is called, and the buffer name is resolved by that context.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that
       this function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - The name of the buffer object to register.
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_ALREADY_MAPPED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsGLRegisterBuffer(jcuda.driver.CUgraphicsResource, int, int)"><CODE>cuGraphicsGLRegisterBuffer(jcuda.driver.CUgraphicsResource, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLMapBufferObject(jcuda.driver.CUdeviceptr, long[], int)"><!-- --></A><H3>
cuGLMapBufferObject</H3>
<PRE>
public static int <B>cuGLMapBufferObject</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                                      long[]&nbsp;size,
                                      int&nbsp;bufferobj)</PRE>
<DL>
<DD>Maps an OpenGL buffer object.
 
 <pre>
 CUresult cuGLMapBufferObject (
      CUdeviceptr* dptr,
      size_t* size,
      GLuint buffer )
 </pre>
 <div>
   <p>Maps an OpenGL buffer object.  
     Deprecated<span>This function is
     deprecated as of Cuda 3.0.</span>Maps the buffer object specified by
     <tt>buffer</tt> into the address space of the current CUDA context
     and returns in <tt>*dptr</tt> and <tt>*size</tt> the base pointer
     and size of the resulting mapping.
   </p>
   <p>There must be a valid OpenGL context
     bound to the current thread when this function is called. This must be
     the same context,
     or a member of the same shareGroup,
     as the context that was bound when the buffer was registered.
   </p>
   <p>All streams in the current CUDA
     context are synchronized with the current GL context.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that
       this function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dptr</CODE> - Returned mapped base pointer<DD><CODE>size</CODE> - Returned size of mapping<DD><CODE>buffer</CODE> - The name of the buffer object to map
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_MAP_FAILED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><CODE>cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLUnmapBufferObject(int)"><!-- --></A><H3>
cuGLUnmapBufferObject</H3>
<PRE>
public static int <B>cuGLUnmapBufferObject</B>(int&nbsp;bufferobj)</PRE>
<DL>
<DD>Unmaps an OpenGL buffer object.
 
 <pre>
 CUresult cuGLUnmapBufferObject (
      GLuint buffer )
 </pre>
 <div>
   <p>Unmaps an OpenGL buffer object.  
     Deprecated<span>This function is
     deprecated as of Cuda 3.0.</span>Unmaps the buffer object specified by
     <tt>buffer</tt> for access by CUDA.
   </p>
   <p>There must be a valid OpenGL context
     bound to the current thread when this function is called. This must be
     the same context,
     or a member of the same shareGroup,
     as the context that was bound when the buffer was registered.
   </p>
   <p>All streams in the current CUDA
     context are synchronized with the current GL context.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that
       this function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - Buffer object to unmap
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsUnmapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><CODE>cuGraphicsUnmapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLUnregisterBufferObject(int)"><!-- --></A><H3>
cuGLUnregisterBufferObject</H3>
<PRE>
public static int <B>cuGLUnregisterBufferObject</B>(int&nbsp;bufferobj)</PRE>
<DL>
<DD>Unregister an OpenGL buffer object.
 
 <pre>
 CUresult cuGLUnregisterBufferObject (
      GLuint buffer )
 </pre>
 <div>
   <p>Unregister an OpenGL buffer object.  
     Deprecated<span>This function is
     deprecated as of Cuda 3.0.</span>Unregisters the buffer object specified
     by <tt>buffer</tt>. This releases any resources associated with the
     registered buffer. After this call, the buffer may no longer be mapped
     for
     access by CUDA.
   </p>
   <p>There must be a valid OpenGL context
     bound to the current thread when this function is called. This must be
     the same context,
     or a member of the same shareGroup,
     as the context that was bound when the buffer was registered.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that
       this function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - Name of the buffer object to unregister
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsUnregisterResource(jcuda.driver.CUgraphicsResource)"><CODE>cuGraphicsUnregisterResource(jcuda.driver.CUgraphicsResource)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLSetBufferObjectMapFlags(int, int)"><!-- --></A><H3>
cuGLSetBufferObjectMapFlags</H3>
<PRE>
public static int <B>cuGLSetBufferObjectMapFlags</B>(int&nbsp;buffer,
                                              int&nbsp;Flags)</PRE>
<DL>
<DD>Set the map flags for an OpenGL buffer object.
 
 <pre>
 CUresult cuGLSetBufferObjectMapFlags (
      GLuint buffer,
      unsigned int  Flags )
 </pre>
 <div>
   <p>Set the map flags for an OpenGL buffer
     object.  
     Deprecated<span>This function is
     deprecated as of Cuda 3.0.</span>Sets the map flags for the buffer
     object specified by <tt>buffer</tt>.
   </p>
   <p>Changes to <tt>Flags</tt> will take
     effect the next time <tt>buffer</tt> is mapped. The <tt>Flags</tt>
     argument may be any of the following:
   <ul>
     <li>
       <p>CU_GL_MAP_RESOURCE_FLAGS_NONE:
         Specifies no hints about how this resource will be used. It is therefore
         assumed that this
         resource will be read from
         and written to by CUDA kernels. This is the default value.
       </p>
     </li>
     <li>
       <p>CU_GL_MAP_RESOURCE_FLAGS_READ_ONLY:
         Specifies that CUDA kernels which access this resource will not write
         to this resource.
       </p>
     </li>
     <li>
       <p>CU_GL_MAP_RESOURCE_FLAGS_WRITE_DISCARD: Specifies that CUDA kernels
         which access this resource will not read from this resource
         and will write over the
         entire contents of the resource, so none of the data previously stored
         in the resource will be preserved.
       </p>
     </li>
   </ul>
   </p>
   <p>If <tt>buffer</tt> has not been
     registered for use with CUDA, then CUDA_ERROR_INVALID_HANDLE is
     returned. If <tt>buffer</tt> is presently mapped for access by CUDA,
     then CUDA_ERROR_ALREADY_MAPPED is returned.
   </p>
   <p>There must be a valid OpenGL context
     bound to the current thread when this function is called. This must be
     the same context,
     or a member of the same shareGroup,
     as the context that was bound when the buffer was registered.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that
       this function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - Buffer object to unmap<DD><CODE>Flags</CODE> - Map flags
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_ALREADY_MAPPED, CUDA_ERROR_INVALID_CONTEXT,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsResourceSetMapFlags(jcuda.driver.CUgraphicsResource, int)"><CODE>cuGraphicsResourceSetMapFlags(jcuda.driver.CUgraphicsResource, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLMapBufferObjectAsync(jcuda.driver.CUdeviceptr, long[], int, jcuda.driver.CUstream)"><!-- --></A><H3>
cuGLMapBufferObjectAsync</H3>
<PRE>
public static int <B>cuGLMapBufferObjectAsync</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                                           long[]&nbsp;size,
                                           int&nbsp;buffer,
                                           <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Maps an OpenGL buffer object.
 
 <pre>
 CUresult cuGLMapBufferObjectAsync (
      CUdeviceptr* dptr,
      size_t* size,
      GLuint buffer,
      CUstream hStream )
 </pre>
 <div>
   <p>Maps an OpenGL buffer object.  
     Deprecated<span>This function is
     deprecated as of Cuda 3.0.</span>Maps the buffer object specified by
     <tt>buffer</tt> into the address space of the current CUDA context
     and returns in <tt>*dptr</tt> and <tt>*size</tt> the base pointer
     and size of the resulting mapping.
   </p>
   <p>There must be a valid OpenGL context
     bound to the current thread when this function is called. This must be
     the same context,
     or a member of the same shareGroup,
     as the context that was bound when the buffer was registered.
   </p>
   <p>Stream <tt>hStream</tt> in the
     current CUDA context is synchronized with the current GL context.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that
       this function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dptr</CODE> - Returned mapped base pointer<DD><CODE>size</CODE> - Returned size of mapping<DD><CODE>buffer</CODE> - The name of the buffer object to map<DD><CODE>hStream</CODE> - Stream to synchronize
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_MAP_FAILED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><CODE>cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLUnmapBufferObjectAsync(int, jcuda.driver.CUstream)"><!-- --></A><H3>
cuGLUnmapBufferObjectAsync</H3>
<PRE>
public static int <B>cuGLUnmapBufferObjectAsync</B>(int&nbsp;buffer,
                                             <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Unmaps an OpenGL buffer object.
 
 <pre>
 CUresult cuGLUnmapBufferObjectAsync (
      GLuint buffer,
      CUstream hStream )
 </pre>
 <div>
   <p>Unmaps an OpenGL buffer object.  
     Deprecated<span>This function is
     deprecated as of Cuda 3.0.</span>Unmaps the buffer object specified by
     <tt>buffer</tt> for access by CUDA.
   </p>
   <p>There must be a valid OpenGL context
     bound to the current thread when this function is called. This must be
     the same context,
     or a member of the same shareGroup,
     as the context that was bound when the buffer was registered.
   </p>
   <p>Stream <tt>hStream</tt> in the
     current CUDA context is synchronized with the current GL context.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that
       this function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - Name of the buffer object to unmap<DD><CODE>hStream</CODE> - Stream to synchronize
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsUnmapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><CODE>cuGraphicsUnmapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGraphicsUnregisterResource(jcuda.driver.CUgraphicsResource)"><!-- --></A><H3>
cuGraphicsUnregisterResource</H3>
<PRE>
public static int <B>cuGraphicsUnregisterResource</B>(<A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource)</PRE>
<DL>
<DD>Unregisters a graphics resource for access by CUDA.
 
 <pre>
 CUresult cuGraphicsUnregisterResource (
      CUgraphicsResource resource )
 </pre>
 <div>
   <p>Unregisters a graphics resource for
     access by CUDA.  Unregisters the graphics resource <tt>resource</tt>
     so it is not accessible by CUDA unless registered again.
   </p>
   <p>If <tt>resource</tt> is invalid then
     CUDA_ERROR_INVALID_HANDLE is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>resource</CODE> - Resource to unregister
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_UNKNOWN<DT><B>See Also:</B><DD><CODE>JCudaDriver#cuGraphicsD3D9RegisterResource</CODE>, 
<CODE>JCudaDriver#cuGraphicsD3D10RegisterResource</CODE>, 
<CODE>JCudaDriver#cuGraphicsD3D11RegisterResource</CODE>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsGLRegisterBuffer(jcuda.driver.CUgraphicsResource, int, int)"><CODE>cuGraphicsGLRegisterBuffer(jcuda.driver.CUgraphicsResource, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsGLRegisterImage(jcuda.driver.CUgraphicsResource, int, int, int)"><CODE>cuGraphicsGLRegisterImage(jcuda.driver.CUgraphicsResource, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGraphicsSubResourceGetMappedArray(jcuda.driver.CUarray, jcuda.driver.CUgraphicsResource, int, int)"><!-- --></A><H3>
cuGraphicsSubResourceGetMappedArray</H3>
<PRE>
public static int <B>cuGraphicsSubResourceGetMappedArray</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;pArray,
                                                      <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource,
                                                      int&nbsp;arrayIndex,
                                                      int&nbsp;mipLevel)</PRE>
<DL>
<DD>Get an array through which to access a subresource of a mapped graphics resource.
 
 <pre>
 CUresult cuGraphicsSubResourceGetMappedArray (
      CUarray* pArray,
      CUgraphicsResource resource,
      unsigned int  arrayIndex,
      unsigned int  mipLevel )
 </pre>
 <div>
   <p>Get an array through which to access a
     subresource of a mapped graphics resource.  Returns in <tt>*pArray</tt>
     an array through which the subresource of the mapped graphics resource
     <tt>resource</tt> which corresponds to array index <tt>arrayIndex</tt>
     and mipmap level <tt>mipLevel</tt> may be accessed. The value set in
     <tt>*pArray</tt> may change every time that <tt>resource</tt> is
     mapped.
   </p>
   <p>If <tt>resource</tt> is not a texture
     then it cannot be accessed via an array and CUDA_ERROR_NOT_MAPPED_AS_ARRAY
     is returned. If <tt>arrayIndex</tt> is not a valid array index for
     <tt>resource</tt> then CUDA_ERROR_INVALID_VALUE is returned. If <tt>mipLevel</tt> is not a valid mipmap level for <tt>resource</tt> then
     CUDA_ERROR_INVALID_VALUE is returned. If <tt>resource</tt> is not
     mapped then CUDA_ERROR_NOT_MAPPED is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pArray</CODE> - Returned array through which a subresource of resource may be accessed<DD><CODE>resource</CODE> - Mapped resource to access<DD><CODE>arrayIndex</CODE> - Array index for array textures or cubemap face index as defined by CUarray_cubemap_face for cubemap textures for the subresource to access<DD><CODE>mipLevel</CODE> - Mipmap level for the subresource to access
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_NOT_MAPPEDCUDA_ERROR_NOT_MAPPED_AS_ARRAY<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsResourceGetMappedPointer(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUgraphicsResource)"><CODE>cuGraphicsResourceGetMappedPointer(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUgraphicsResource)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGraphicsResourceGetMappedMipmappedArray(jcuda.driver.CUmipmappedArray, jcuda.driver.CUgraphicsResource)"><!-- --></A><H3>
cuGraphicsResourceGetMappedMipmappedArray</H3>
<PRE>
public static int <B>cuGraphicsResourceGetMappedMipmappedArray</B>(<A HREF="../../jcuda/driver/CUmipmappedArray.html" title="class in jcuda.driver">CUmipmappedArray</A>&nbsp;pMipmappedArray,
                                                            <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource)</PRE>
<DL>
<DD>Get a mipmapped array through which to access a mapped graphics resource.
 
 <pre>
 CUresult cuGraphicsResourceGetMappedMipmappedArray (
      CUmipmappedArray* pMipmappedArray,
      CUgraphicsResource resource )
 </pre>
 <div>
   <p>Get a mipmapped array through which to
     access a mapped graphics resource.  Returns in <tt>*pMipmappedArray</tt>
     a mipmapped array through which the mapped graphics resource <tt>resource</tt>. The value set in <tt>*pMipmappedArray</tt> may change
     every time that <tt>resource</tt> is mapped.
   </p>
   <p>If <tt>resource</tt> is not a texture
     then it cannot be accessed via a mipmapped array and
     CUDA_ERROR_NOT_MAPPED_AS_ARRAY is returned. If <tt>resource</tt> is
     not mapped then CUDA_ERROR_NOT_MAPPED is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pMipmappedArray</CODE> - Returned mipmapped array through which resource may be accessed<DD><CODE>resource</CODE> - Mapped resource to access
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_NOT_MAPPEDCUDA_ERROR_NOT_MAPPED_AS_ARRAY<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsResourceGetMappedPointer(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUgraphicsResource)"><CODE>cuGraphicsResourceGetMappedPointer(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUgraphicsResource)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGraphicsResourceGetMappedPointer(jcuda.driver.CUdeviceptr, long[], jcuda.driver.CUgraphicsResource)"><!-- --></A><H3>
cuGraphicsResourceGetMappedPointer</H3>
<PRE>
public static int <B>cuGraphicsResourceGetMappedPointer</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;pDevPtr,
                                                     long[]&nbsp;pSize,
                                                     <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource)</PRE>
<DL>
<DD>Get a device pointer through which to access a mapped graphics resource.
 
 <pre>
 CUresult cuGraphicsResourceGetMappedPointer (
      CUdeviceptr* pDevPtr,
      size_t* pSize,
      CUgraphicsResource resource )
 </pre>
 <div>
   <p>Get a device pointer through which to
     access a mapped graphics resource.  Returns in <tt>*pDevPtr</tt> a
     pointer through which the mapped graphics resource <tt>resource</tt>
     may be accessed. Returns in <tt>pSize</tt> the size of the memory in
     bytes which may be accessed from that pointer. The value set in <tt>pPointer</tt> may change every time that <tt>resource</tt> is
     mapped.
   </p>
   <p>If <tt>resource</tt> is not a buffer
     then it cannot be accessed via a pointer and CUDA_ERROR_NOT_MAPPED_AS_POINTER
     is returned. If <tt>resource</tt> is not mapped then CUDA_ERROR_NOT_MAPPED
     is returned. * 
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pDevPtr</CODE> - Returned pointer through which resource may be accessed<DD><CODE>pSize</CODE> - Returned size of the buffer accessible starting at *pPointer<DD><CODE>resource</CODE> - Mapped resource to access
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_NOT_MAPPEDCUDA_ERROR_NOT_MAPPED_AS_POINTER<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><CODE>cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsSubResourceGetMappedArray(jcuda.driver.CUarray, jcuda.driver.CUgraphicsResource, int, int)"><CODE>cuGraphicsSubResourceGetMappedArray(jcuda.driver.CUarray, jcuda.driver.CUgraphicsResource, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGraphicsResourceSetMapFlags(jcuda.driver.CUgraphicsResource, int)"><!-- --></A><H3>
cuGraphicsResourceSetMapFlags</H3>
<PRE>
public static int <B>cuGraphicsResourceSetMapFlags</B>(<A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource,
                                                int&nbsp;flags)</PRE>
<DL>
<DD>Set usage flags for mapping a graphics resource.
 
 <pre>
 CUresult cuGraphicsResourceSetMapFlags (
      CUgraphicsResource resource,
      unsigned int  flags )
 </pre>
 <div>
   <p>Set usage flags for mapping a graphics
     resource.  Set <tt>flags</tt> for mapping the graphics resource <tt>resource</tt>.
   </p>
   <p>Changes to <tt>flags</tt> will take
     effect the next time <tt>resource</tt> is mapped. The <tt>flags</tt>
     argument may be any of the following:
   </p>
   <ul>
     <li>
       <p>CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE:
         Specifies no hints about how this resource will be used. It is therefore
         assumed that
         this resource will be read from
         and written to by CUDA kernels. This is the default value.
       </p>
     </li>
     <li>
       <p>CU_GRAPHICS_MAP_RESOURCE_FLAGS_READONLY:
         Specifies that CUDA kernels which access this resource will not write
         to this resource.
       </p>
     </li>
     <li>
       <p>CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITEDISCARD: Specifies that CUDA
         kernels which access this resource will not read from this
         resource and will write over
         the entire contents of the resource, so none of the data previously
         stored in the resource will
         be preserved.
       </p>
     </li>
   </ul>
   </p>
   <p>If <tt>resource</tt> is presently
     mapped for access by CUDA then CUDA_ERROR_ALREADY_MAPPED is returned.
     If <tt>flags</tt> is not one of the above values then
     CUDA_ERROR_INVALID_VALUE is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>resource</CODE> - Registered resource to set flags for<DD><CODE>flags</CODE> - Parameters for resource mapping
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_INVALID_HANDLE, CUDA_ERROR_ALREADY_MAPPED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><CODE>cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><!-- --></A><H3>
cuGraphicsMapResources</H3>
<PRE>
public static int <B>cuGraphicsMapResources</B>(int&nbsp;count,
                                         <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>[]&nbsp;resources,
                                         <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Map graphics resources for access by CUDA.
 
 <pre>
 CUresult cuGraphicsMapResources (
      unsigned int  count,
      CUgraphicsResource* resources,
      CUstream hStream )
 </pre>
 <div>
   <p>Map graphics resources for access by
     CUDA.  Maps the <tt>count</tt> graphics resources in <tt>resources</tt>
     for access by CUDA.
   </p>
   <p>The resources in <tt>resources</tt>
     may be accessed by CUDA until they are unmapped. The graphics API from
     which <tt>resources</tt> were registered should not access any
     resources while they are mapped by CUDA. If an application does so,
     the results are
     undefined.
   </p>
   <p>This function provides the synchronization
     guarantee that any graphics calls issued before cuGraphicsMapResources()
     will complete before any subsequent CUDA work issued in <tt>stream</tt>
     begins.
   </p>
   <p>If <tt>resources</tt> includes any
     duplicate entries then CUDA_ERROR_INVALID_HANDLE is returned. If any
     of <tt>resources</tt> are presently mapped for access by CUDA then
     CUDA_ERROR_ALREADY_MAPPED is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - Number of resources to map<DD><CODE>resources</CODE> - Resources to map for CUDA usage<DD><CODE>hStream</CODE> - Stream with which to synchronize
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_ALREADY_MAPPED, CUDA_ERROR_UNKNOWN<DT><B>See Also:</B><DD><CODE>JCudaDriver#cuGraphicsResourceGetMappedPointercuGraphicsSubResourceGetMappedArraycuGraphicsUnmapResources</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="cuGraphicsUnmapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><!-- --></A><H3>
cuGraphicsUnmapResources</H3>
<PRE>
public static int <B>cuGraphicsUnmapResources</B>(int&nbsp;count,
                                           <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>[]&nbsp;resources,
                                           <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Unmap graphics resources.
 
 <pre>
 CUresult cuGraphicsUnmapResources (
      unsigned int  count,
      CUgraphicsResource* resources,
      CUstream hStream )
 </pre>
 <div>
   <p>Unmap graphics resources.  Unmaps the
     <tt>count</tt> graphics resources in <tt>resources</tt>.
   </p>
   <p>Once unmapped, the resources in <tt>resources</tt> may not be accessed by CUDA until they are mapped
     again.
   </p>
   <p>This function provides the synchronization
     guarantee that any CUDA work issued in <tt>stream</tt> before
     cuGraphicsUnmapResources() will complete before any subsequently issued
     graphics work begins.
   </p>
   <p>If <tt>resources</tt> includes any
     duplicate entries then CUDA_ERROR_INVALID_HANDLE is returned. If any
     of <tt>resources</tt> are not presently mapped for access by CUDA then
     CUDA_ERROR_NOT_MAPPED is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - Number of resources to unmap<DD><CODE>resources</CODE> - Resources to unmap<DD><CODE>hStream</CODE> - Stream with which to synchronize
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_NOT_MAPPED, CUDA_ERROR_UNKNOWN<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><CODE>cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxSetLimit(int, long)"><!-- --></A><H3>
cuCtxSetLimit</H3>
<PRE>
public static int <B>cuCtxSetLimit</B>(int&nbsp;limit,
                                long&nbsp;value)</PRE>
<DL>
<DD>Set resource limits.
 
 <pre>
 CUresult cuCtxSetLimit (
      CUlimit limit,
      size_t value )
 </pre>
 <div>
   <p>Set resource limits.  Setting <tt>limit</tt> to <tt>value</tt> is a request by the application to
     update the current limit maintained by the context. The driver is free
     to modify the requested
     value to meet h/w requirements (this
     could be clamping to minimum or maximum values, rounding up to nearest
     element size,
     etc). The application can use
     cuCtxGetLimit() to find out exactly what the limit has been set to.
   </p>
   <p>Setting each CUlimit has its own specific
     restrictions, so each is discussed here.
   </p>
   <ul>
     <li>
       <p>CU_LIMIT_STACK_SIZE controls
         the stack size in bytes of each GPU thread. This limit is only
         applicable to devices of compute capability 2.0 and
         higher. Attempting to set this
         limit on devices of compute capability less than 2.0 will result in
         the error CUDA_ERROR_UNSUPPORTED_LIMIT being returned.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CU_LIMIT_PRINTF_FIFO_SIZE
         controls the size in bytes of the FIFO used by the printf() device
         system call. Setting CU_LIMIT_PRINTF_FIFO_SIZE must be performed before
         launching any kernel that uses the printf() device system call,
         otherwise CUDA_ERROR_INVALID_VALUE will be returned. This limit is only
         applicable to devices of compute capability 2.0 and higher. Attempting
         to set this limit
         on devices of compute capability
         less than 2.0 will result in the error CUDA_ERROR_UNSUPPORTED_LIMIT
         being returned.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CU_LIMIT_MALLOC_HEAP_SIZE
         controls the size in bytes of the heap used by the malloc() and free()
         device system calls. Setting CU_LIMIT_MALLOC_HEAP_SIZE must be performed
         before launching any kernel that uses the malloc() or free() device
         system calls, otherwise CUDA_ERROR_INVALID_VALUE will be returned. This
         limit is only applicable to devices of compute capability 2.0 and
         higher. Attempting to set this limit
         on devices of compute capability
         less than 2.0 will result in the error CUDA_ERROR_UNSUPPORTED_LIMIT
         being returned.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH
         controls the maximum nesting depth of a grid at which a thread can
         safely call cudaDeviceSynchronize(). Setting this limit
         must be performed before any
         launch of a kernel that uses the device runtime and calls
         cudaDeviceSynchronize() above the default
         sync depth, two levels of grids.
         Calls to cudaDeviceSynchronize() will fail with error code
         cudaErrorSyncDepthExceeded if
         the limitation is violated. This
         limit can be set smaller than the default or up the maximum launch
         depth of 24. When setting
         this limit, keep in mind that
         additional levels of sync depth require the driver to reserve large
         amounts of device memory
         which can no longer be used for
         user allocations. If these reservations of device memory fail,
         cuCtxSetLimit will return CUDA_ERROR_OUT_OF_MEMORY, and the limit can
         be reset to a lower value. This limit is only applicable to devices of
         compute capability 3.5 and higher.
         Attempting to set this limit on
         devices of compute capability less than 3.5 will result in the error
         CUDA_ERROR_UNSUPPORTED_LIMIT being returned.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT controls the maximum number
         of outstanding device runtime launches that can be made from the
         current context. A grid is outstanding
         from the point of launch up
         until the grid is known to have been completed. Device runtime launches
         which violate this limitation
         fail and return
         cudaErrorLaunchPendingCountExceeded when cudaGetLastError() is called
         after launch. If more pending launches
         than the default (2048 launches)
         are needed for a module using the device runtime, this limit can be
         increased. Keep in mind
         that being able to sustain
         additional pending launches will require the driver to reserve larger
         amounts of device memory
         upfront which can no longer be
         used for allocations. If these reservations fail, cuCtxSetLimit will
         return CUDA_ERROR_OUT_OF_MEMORY, and the limit can be reset to a lower
         value. This limit is only applicable to devices of compute capability
         3.5 and higher.
         Attempting to set this limit on
         devices of compute capability less than 3.5 will result in the error
         CUDA_ERROR_UNSUPPORTED_LIMIT being returned.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>limit</CODE> - Limit to set<DD><CODE>value</CODE> - Size of limit
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_UNSUPPORTED_LIMIT,
 CUDA_ERROR_OUT_OF_MEMORY<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])"><CODE>cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])"><CODE>cuCtxGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)"><CODE>cuCtxGetDevice(jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetLimit(long[], int)"><CODE>cuCtxGetLimit(long[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPushCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCacheConfig(int)"><CODE>cuCtxSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()"><CODE>cuCtxSynchronize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxGetCacheConfig(int[])"><!-- --></A><H3>
cuCtxGetCacheConfig</H3>
<PRE>
public static int <B>cuCtxGetCacheConfig</B>(int[]&nbsp;pconfig)</PRE>
<DL>
<DD>Returns the preferred cache configuration for the current context.
 
 <pre>
 CUresult cuCtxGetCacheConfig (
      CUfunc_cache* pconfig )
 </pre>
 <div>
   <p>Returns the preferred cache configuration
     for the current context.  On devices where the L1 cache and shared
     memory use the
     same hardware resources, this function
     returns through <tt>pconfig</tt> the preferred cache configuration
     for the current context. This is only a preference. The driver will
     use the requested configuration
     if possible, but it is free to choose a
     different configuration if required to execute functions.
   </p>
   <p>This will return a <tt>pconfig</tt> of
     CU_FUNC_CACHE_PREFER_NONE on devices where the size of the L1 cache
     and shared memory are fixed.
   </p>
   <p>The supported cache configurations are:
   <ul>
     <li>
       <p>CU_FUNC_CACHE_PREFER_NONE: no
         preference for shared memory or L1 (default)
       </p>
     </li>
     <li>
       <p>CU_FUNC_CACHE_PREFER_SHARED:
         prefer larger shared memory and smaller L1 cache
       </p>
     </li>
     <li>
       <p>CU_FUNC_CACHE_PREFER_L1: prefer
         larger L1 cache and smaller shared memory
       </p>
     </li>
     <li>
       <p>CU_FUNC_CACHE_PREFER_EQUAL:
         prefer equal sized L1 cache and shared memory
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pconfig</CODE> - Returned cache configuration
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])"><CODE>cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)"><CODE>cuCtxGetDevice(jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetLimit(long[], int)"><CODE>cuCtxGetLimit(long[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPushCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCacheConfig(int)"><CODE>cuCtxSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetLimit(int, long)"><CODE>cuCtxSetLimit(int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()"><CODE>cuCtxSynchronize()</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxSetCacheConfig(int)"><!-- --></A><H3>
cuCtxSetCacheConfig</H3>
<PRE>
public static int <B>cuCtxSetCacheConfig</B>(int&nbsp;config)</PRE>
<DL>
<DD>Sets the preferred cache configuration for the current context.
 
 <pre>
 CUresult cuCtxSetCacheConfig (
      CUfunc_cache config )
 </pre>
 <div>
   <p>Sets the preferred cache configuration
     for the current context.  On devices where the L1 cache and shared
     memory use the same
     hardware resources, this sets through
     <tt>config</tt> the preferred cache configuration for the current
     context. This is only a preference. The driver will use the requested
     configuration
     if possible, but it is free to choose a
     different configuration if required to execute the function. Any
     function preference
     set via cuFuncSetCacheConfig() will be
     preferred over this context-wide setting. Setting the context-wide
     cache configuration to CU_FUNC_CACHE_PREFER_NONE will cause subsequent
     kernel launches to prefer to not change the cache configuration unless
     required to launch the kernel.
   </p>
   <p>This setting does nothing on devices
     where the size of the L1 cache and shared memory are fixed.
   </p>
   <p>Launching a kernel with a different
     preference than the most recent preference setting may insert a
     device-side synchronization
     point.
   </p>
   <p>The supported cache configurations are:
   <ul>
     <li>
       <p>CU_FUNC_CACHE_PREFER_NONE: no
         preference for shared memory or L1 (default)
       </p>
     </li>
     <li>
       <p>CU_FUNC_CACHE_PREFER_SHARED:
         prefer larger shared memory and smaller L1 cache
       </p>
     </li>
     <li>
       <p>CU_FUNC_CACHE_PREFER_L1: prefer
         larger L1 cache and smaller shared memory
       </p>
     </li>
     <li>
       <p>CU_FUNC_CACHE_PREFER_EQUAL:
         prefer equal sized L1 cache and shared memory
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>config</CODE> - Requested cache configuration
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])"><CODE>cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])"><CODE>cuCtxGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)"><CODE>cuCtxGetDevice(jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetLimit(long[], int)"><CODE>cuCtxGetLimit(long[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPushCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetLimit(int, long)"><CODE>cuCtxSetLimit(int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()"><CODE>cuCtxSynchronize()</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxGetSharedMemConfig(int[])"><!-- --></A><H3>
cuCtxGetSharedMemConfig</H3>
<PRE>
public static int <B>cuCtxGetSharedMemConfig</B>(int[]&nbsp;pConfig)</PRE>
<DL>
<DD>Returns the current shared memory configuration for the current context.
 
 <pre>
 CUresult cuCtxGetSharedMemConfig (
      CUsharedconfig* pConfig )
 </pre>
 <div>
   <p>Returns the current shared memory
     configuration for the current context.  This function will return in
     <tt>pConfig</tt> the current size of shared memory banks in the
     current context. On devices with configurable shared memory banks,
     cuCtxSetSharedMemConfig can be used to change this setting, so that
     all subsequent kernel launches will by default use the new bank size.
     When cuCtxGetSharedMemConfig is called on devices without configurable
     shared memory, it will return the fixed bank size of the hardware.
   </p>
   <p>The returned bank configurations can be
     either:
   <ul>
     <li>
       <p>CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE: shared memory bank width is
         four bytes.
       </p>
     </li>
     <li>
       <p>CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE: shared memory bank width
         will eight bytes.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pConfig</CODE> - returned shared memory configuration
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])"><CODE>cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])"><CODE>cuCtxGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)"><CODE>cuCtxGetDevice(jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetLimit(long[], int)"><CODE>cuCtxGetLimit(long[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPushCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetLimit(int, long)"><CODE>cuCtxSetLimit(int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()"><CODE>cuCtxSynchronize()</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetSharedMemConfig(int[])"><CODE>cuCtxGetSharedMemConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxSetSharedMemConfig(int)"><!-- --></A><H3>
cuCtxSetSharedMemConfig</H3>
<PRE>
public static int <B>cuCtxSetSharedMemConfig</B>(int&nbsp;config)</PRE>
<DL>
<DD>Sets the shared memory configuration for the current context.
 
 <pre>
 CUresult cuCtxSetSharedMemConfig (
      CUsharedconfig config )
 </pre>
 <div>
   <p>Sets the shared memory configuration for
     the current context.  On devices with configurable shared memory banks,
     this function
     will set the context's shared memory bank
     size which is used for subsequent kernel launches.
   </p>
   <p>Changed the shared memory configuration
     between launches may insert a device side synchronization point between
     those launches.
   </p>
   <p>Changing the shared memory bank size
     will not increase shared memory usage or affect occupancy of kernels,
     but may have major
     effects on performance. Larger bank sizes
     will allow for greater potential bandwidth to shared memory, but will
     change what
     kinds of accesses to shared memory will
     result in bank conflicts.
   </p>
   <p>This function will do nothing on devices
     with fixed shared memory bank size.
   </p>
   <p>The supported bank configurations are:
   <ul>
     <li>
       <p>CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE:
         set bank width to the default initial setting (currently, four bytes).
       </p>
     </li>
     <li>
       <p>CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE: set shared memory bank width
         to be natively four bytes.
       </p>
     </li>
     <li>
       <p>CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE: set shared memory bank
         width to be natively eight bytes.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>config</CODE> - requested shared memory configuration
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])"><CODE>cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])"><CODE>cuCtxGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)"><CODE>cuCtxGetDevice(jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetLimit(long[], int)"><CODE>cuCtxGetLimit(long[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPushCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetLimit(int, long)"><CODE>cuCtxSetLimit(int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()"><CODE>cuCtxSynchronize()</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetSharedMemConfig(int[])"><CODE>cuCtxGetSharedMemConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])"><!-- --></A><H3>
cuCtxGetApiVersion</H3>
<PRE>
public static int <B>cuCtxGetApiVersion</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;ctx,
                                     int[]&nbsp;version)</PRE>
<DL>
<DD>Gets the context's API version.
 
 <pre>
 CUresult cuCtxGetApiVersion (
      CUcontext ctx,
      unsigned int* version )
 </pre>
 <div>
   <p>Gets the context's API version.  Returns
     a version number in <tt>version</tt> corresponding to the capabilities
     of the context (e.g. 3010 or 3020), which library developers can use
     to direct callers
     to a specific API version. If <tt>ctx</tt> is NULL, returns the API version used to create the currently
     bound context.
   </p>
   <p>Note that new API versions are only
     introduced when context capabilities are changed that break binary
     compatibility, so the
     API version and driver version may be
     different. For example, it is valid for the API version to be 3020
     while the driver
     version is 4020.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ctx</CODE> - Context to check<DD><CODE>version</CODE> - Pointer to version
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_UNKNOWN<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)"><CODE>cuCtxGetDevice(jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetLimit(long[], int)"><CODE>cuCtxGetLimit(long[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPushCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCacheConfig(int)"><CODE>cuCtxSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetLimit(int, long)"><CODE>cuCtxSetLimit(int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()"><CODE>cuCtxSynchronize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuLaunchKernel(jcuda.driver.CUfunction, int, int, int, int, int, int, int, jcuda.driver.CUstream, jcuda.Pointer, jcuda.Pointer)"><!-- --></A><H3>
cuLaunchKernel</H3>
<PRE>
public static int <B>cuLaunchKernel</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;f,
                                 int&nbsp;gridDimX,
                                 int&nbsp;gridDimY,
                                 int&nbsp;gridDimZ,
                                 int&nbsp;blockDimX,
                                 int&nbsp;blockDimY,
                                 int&nbsp;blockDimZ,
                                 int&nbsp;sharedMemBytes,
                                 <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream,
                                 <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;kernelParams,
                                 <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;extra)</PRE>
<DL>
<DD>Launches a CUDA function.
 
 <div>
   <div>
     <table>
       <tr>
         <td>CUresult cuLaunchKernel           </td>
         <td>(</td>
         <td>CUfunction&nbsp;</td>
         <td> <em>f</em>, </td>
       </tr>
       <tr>
         <td></td>
         <td></td>
         <td>unsigned int&nbsp;</td>
         <td> <em>gridDimX</em>, </td>
       </tr>
       <tr>
         <td></td>
         <td></td>
         <td>unsigned int&nbsp;</td>
         <td> <em>gridDimY</em>, </td>
       </tr>
       <tr>
         <td></td>
         <td></td>
         <td>unsigned int&nbsp;</td>
         <td> <em>gridDimZ</em>, </td>
       </tr>
       <tr>
         <td></td>
         <td></td>
         <td>unsigned int&nbsp;</td>
         <td> <em>blockDimX</em>, </td>
       </tr>
       <tr>
         <td></td>
         <td></td>
         <td>unsigned int&nbsp;</td>
         <td> <em>blockDimY</em>, </td>
       </tr>
       <tr>
         <td></td>
         <td></td>
         <td>unsigned int&nbsp;</td>
         <td> <em>blockDimZ</em>, </td>
       </tr>
       <tr>
         <td></td>
         <td></td>
         <td>unsigned int&nbsp;</td>
         <td> <em>sharedMemBytes</em>, </td>
       </tr>
       <tr>
         <td></td>
         <td></td>
         <td>CUstream&nbsp;</td>
         <td> <em>hStream</em>, </td>
       </tr>
       <tr>
         <td></td>
         <td></td>
         <td>void **&nbsp;</td>
         <td> <em>kernelParams</em>, </td>
       </tr>
       <tr>
         <td></td>
         <td></td>
         <td>void **&nbsp;</td>
         <td> <em>extra</em></td>
         <td>&nbsp;</td>
       </tr>
       <tr>
         <td></td>
         <td>)</td>
         <td></td>
         <td></td>
         <td></td>
       </tr>
     </table>
   </div>
   <div>
     <p>
       Invokes the kernel <code>f</code> on a <code>gridDimX</code> x
       <code>gridDimY</code> x <code>gridDimZ</code> grid of blocks. Each
       block contains <code>blockDimX</code> x <code>blockDimY</code> x
       <code>blockDimZ</code> threads.
     <p>
       <code>sharedMemBytes</code> sets the amount of dynamic shared memory
       that will be available to each thread block.
     <p>
       cuLaunchKernel() can optionally be associated to a stream by passing a
       non-zero <code>hStream</code> argument.
     <p>
       Kernel parameters to <code>f</code> can be specified in one of two
       ways:
     <p>
       1) Kernel parameters can be specified via <code>kernelParams</code>.
       If <code>f</code> has N parameters, then <code>kernelParams</code>
       needs to be an array of N pointers. Each of <code>kernelParams</code>[0]
       through <code>kernelParams</code>[N-1] must point to a region of memory
       from which the actual kernel parameter will be copied. The number of
       kernel parameters and their offsets and sizes do not need to be
       specified as that information is retrieved directly from the kernel's
       image.
     <p>
       2) Kernel parameters can also be packaged by the application into a
       single buffer that is passed in via the <code>extra</code> parameter.
       This places the burden on the application of knowing each kernel
       parameter's size and alignment/padding within the buffer. Here is an
       example of using the <code>extra</code> parameter in this manner: 
     <div>
       <pre>    <span>size_t</span> argBufferSize;
     <span>char</span> argBuffer[256];
 
     <span>// populate argBuffer and argBufferSize</span>
 
     <span>void</span> *config[] = {
         CU_LAUNCH_PARAM_BUFFER_POINTER, argBuffer,
         CU_LAUNCH_PARAM_BUFFER_SIZE,    &amp;argBufferSize,
         CU_LAUNCH_PARAM_END
     };
     status = cuLaunchKernel(f, gx, gy, gz, bx, by, bz, sh, s, NULL,
 config);
 </pre>
     </div>
     <p>
       The <code>extra</code> parameter exists to allow cuLaunchKernel to take
       additional less commonly used arguments. <code>extra</code> specifies
       a list of names of extra settings and their corresponding values. Each
       extra setting name is immediately followed by the corresponding value.
       The list must be terminated with either NULL or
       CU_LAUNCH_PARAM_END.
     <p>
     <ul>
       <li>CU_LAUNCH_PARAM_END, which indicates the end of the <code>extra</code>
         array;
       </li>
       <li>CU_LAUNCH_PARAM_BUFFER_POINTER, which specifies that
         the next value in <code>extra</code> will be a pointer to a buffer
         containing all the kernel parameters for launching kernel
         <code>f</code>;
       </li>
       <li>CU_LAUNCH_PARAM_BUFFER_SIZE, which specifies
         that the next value in <code>extra</code> will be a pointer to a size_t
         containing the size of the buffer specified with
         CU_LAUNCH_PARAM_BUFFER_POINTER;
       </li>
     </ul>
     <p>
       The error CUDA_ERROR_INVALID_VALUE will be returned if kernel parameters
       are specified with both <code>kernelParams</code> and <code>extra</code>
       (i.e. both <code>kernelParams</code> and <code>extra</code> are
       non-NULL).
     <p>
       Calling cuLaunchKernel() sets persistent function state that is the
       same as function state set through the following deprecated APIs:
     <p>
       cuFuncSetBlockShape() cuFuncSetSharedSize() cuParamSetSize()
       cuParamSeti() cuParamSetf() cuParamSetv()
     <p>
       When the kernel <code>f</code> is launched via cuLaunchKernel(), the
       previous block shape, shared size and parameter info associated with
       <code>f</code> is overwritten.
     <p>
       Note that to use cuLaunchKernel(), the kernel <code>f</code> must
       either have been compiled with toolchain version 3.2 or later so that
       it will contain kernel parameter information, or have no kernel
       parameters. If either of these conditions is not met, then
       cuLaunchKernel() will return CUDA_ERROR_INVALID_IMAGE.
     <p>
   </div>
 </div>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED,
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,
 CUDA_ERROR_INVALID_IMAGE, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_LAUNCH_FAILED, CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES,
 CUDA_ERROR_LAUNCH_TIMEOUT, CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,
 CUDA_ERROR_SHARED_OBJECT_INIT_FAILED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])"><CODE>cuCtxGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCacheConfig(int)"><CODE>cuCtxSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)"><CODE>cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxGetLimit(long[], int)"><!-- --></A><H3>
cuCtxGetLimit</H3>
<PRE>
public static int <B>cuCtxGetLimit</B>(long[]&nbsp;pvalue,
                                int&nbsp;limit)</PRE>
<DL>
<DD>Returns resource limits.
 
 <pre>
 CUresult cuCtxGetLimit (
      size_t* pvalue,
      CUlimit limit )
 </pre>
 <div>
   <p>Returns resource limits.  Returns in <tt>*pvalue</tt> the current size of <tt>limit</tt>. The supported
     CUlimit values are:
   <ul>
     <li>
       <p>CU_LIMIT_STACK_SIZE: stack size
         in bytes of each GPU thread.
       </p>
     </li>
     <li>
       <p>CU_LIMIT_PRINTF_FIFO_SIZE: size
         in bytes of the FIFO used by the printf() device system call.
       </p>
     </li>
     <li>
       <p>CU_LIMIT_MALLOC_HEAP_SIZE: size
         in bytes of the heap used by the malloc() and free() device system
         calls.
       </p>
     </li>
     <li>
       <p>CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH:
         maximum grid depth at which a thread can issue the device runtime call
         cudaDeviceSynchronize() to wait on child grid launches
         to complete.
       </p>
     </li>
     <li>
       <p>CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT: maximum number of
         outstanding device runtime launches that can be made from this
         context.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pvalue</CODE> - Returned size of limit<DD><CODE>limit</CODE> - Limit to query
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_UNSUPPORTED_LIMIT<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])"><CODE>cuCtxGetApiVersion(jcuda.driver.CUcontext, int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetCacheConfig(int[])"><CODE>cuCtxGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)"><CODE>cuCtxGetDevice(jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPushCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetCacheConfig(int)"><CODE>cuCtxSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSetLimit(int, long)"><CODE>cuCtxSetLimit(int, long)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()"><CODE>cuCtxSynchronize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuProfilerInitialize(java.lang.String, java.lang.String, int)"><!-- --></A><H3>
cuProfilerInitialize</H3>
<PRE>
public static int <B>cuProfilerInitialize</B>(java.lang.String&nbsp;configFile,
                                       java.lang.String&nbsp;outputFile,
                                       int&nbsp;outputMode)</PRE>
<DL>
<DD>Initialize the profiling.
 
 <pre>
 CUresult cuProfilerInitialize (
      const char* configFile,
      const char* outputFile,
      CUoutput_mode outputMode )
 </pre>
 <div>
   <p>Initialize the profiling.  Using this
     API user can initialize the CUDA profiler by specifying the configuration
     file, output
     file and output file format. This API is
     generally used to profile different set of counters by looping the
     kernel launch.
     The <tt>configFile</tt> parameter can
     be used to select profiling options including profiler counters. Refer
     to the "Compute Command Line Profiler
     User Guide" for supported profiler
     options and counters.
   </p>
   <p>Limitation: The CUDA profiler cannot be
     initialized with this API if another profiling tool is already active,
     as indicated
     by the CUDA_ERROR_PROFILER_DISABLED
     return code.
   </p>
   <p>Typical usage of the profiling APIs is
     as follows:
   </p>
   <p>for each set of counters/options
     {
     cuProfilerInitialize(); //Initialize
     profiling, set the counters or options in the config file 
     ...
     cuProfilerStart(); 
     // code to be profiled 
     cuProfilerStop(); 
     ...
     cuProfilerStart(); 
     // code to be profiled 
     cuProfilerStop(); 
     ...
     }
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>configFile</CODE> - Name of the config file that lists the counters/options for profiling.<DD><CODE>outputFile</CODE> - Name of the outputFile where the profiling results will be stored.<DD><CODE>outputMode</CODE> - outputMode, can be CU_OUT_KEY_VALUE_PAIR or CU_OUT_CSV.
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,
 CUDA_ERROR_PROFILER_DISABLED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuProfilerStart()"><CODE>cuProfilerStart()</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuProfilerStop()"><CODE>cuProfilerStop()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuProfilerStart()"><!-- --></A><H3>
cuProfilerStart</H3>
<PRE>
public static int <B>cuProfilerStart</B>()</PRE>
<DL>
<DD>Enable profiling.
 
 <pre>
 CUresult cuProfilerStart (
      void )
 </pre>
 <div>
   <p>Enable profiling.  Enables profile
     collection by the active profiling tool. If profiling is already
     enabled, then cuProfilerStart() has no effect.
   </p>
   <p>cuProfilerStart and cuProfilerStop APIs
     are used to programmatically control the profiling granularity by
     allowing profiling
     to be done only on selective pieces of
     code.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_CONTEXT<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuProfilerInitialize(java.lang.String, java.lang.String, int)"><CODE>cuProfilerInitialize(java.lang.String, java.lang.String, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuProfilerStop()"><CODE>cuProfilerStop()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuProfilerStop()"><!-- --></A><H3>
cuProfilerStop</H3>
<PRE>
public static int <B>cuProfilerStop</B>()</PRE>
<DL>
<DD>Disable profiling.
 
 <pre>
 CUresult cuProfilerStop (
      void )
 </pre>
 <div>
   <p>Disable profiling.  Disables profile
     collection by the active profiling tool. If profiling is already
     disabled, then cuProfilerStop() has no effect.
   </p>
   <p>cuProfilerStart and cuProfilerStop APIs
     are used to programmatically control the profiling granularity by
     allowing profiling
     to be done only on selective pieces of
     code.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_CONTEXT<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuProfilerInitialize(java.lang.String, java.lang.String, int)"><CODE>cuProfilerInitialize(java.lang.String, java.lang.String, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuProfilerStart()"><CODE>cuProfilerStart()</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JCudaDriver.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../jcuda/driver/JITOptions.html" title="class in jcuda.driver"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?jcuda/driver/JCudaDriver.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JCudaDriver.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
