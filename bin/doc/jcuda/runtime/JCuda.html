<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_10) on Wed Mar 20 21:46:01 CET 2013 -->
<TITLE>
JCuda (JCuda API Documentation)
</TITLE>

<META NAME="date" CONTENT="2013-03-20">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="JCuda (JCuda API Documentation)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JCuda.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../jcuda/runtime/dim3.html" title="class in jcuda.runtime"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../jcuda/runtime/surfaceReference.html" title="class in jcuda.runtime"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?jcuda/runtime/JCuda.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JCuda.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
jcuda.runtime</FONT>
<BR>
Class JCuda</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>jcuda.runtime.JCuda</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>JCuda</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Java bindings for the NVidia CUDA runtime API.<br />
 <br />
 Most comments are extracted from the CUDA online documentation
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaArrayCubemap">cudaArrayCubemap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Must be set in cudaMalloc3DArray to create a cubemap CUDA array</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaArrayDefault">cudaArrayDefault</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default CUDA array allocation flag</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaArrayLayered">cudaArrayLayered</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Must be set in cudaMalloc3DArray to create a layered CUDA array</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaArraySurfaceLoadStore">cudaArraySurfaceLoadStore</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Must be set in cudaMallocArray or cudaMalloc3DArray in order
 to bind surfaces to the CUDA array</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaArrayTextureGather">cudaArrayTextureGather</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Must be set in cudaMallocArray or cudaMalloc3DArray in order to
 perform texture gather operations on the CUDA array</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceBlockingSync">cudaDeviceBlockingSync</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of CUDA 4.0 and replaced by cudaDeviceScheduleBlockingSync</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceLmemResizeToMax">cudaDeviceLmemResizeToMax</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Device flag - Keep local memory allocation after launch</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceMapHost">cudaDeviceMapHost</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Device flag - Support mapped pinned allocations</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceMask">cudaDeviceMask</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Device flags mask</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceScheduleAuto">cudaDeviceScheduleAuto</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Device flag - Automatic scheduling</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceScheduleBlockingSync">cudaDeviceScheduleBlockingSync</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Device flag - Use blocking synchronization</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceScheduleMask">cudaDeviceScheduleMask</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Device schedule flags mask</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceScheduleSpin">cudaDeviceScheduleSpin</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Device flag - Spin default scheduling</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceScheduleYield">cudaDeviceScheduleYield</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Device flag - Yield default scheduling</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventBlockingSync">cudaEventBlockingSync</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event uses blocking synchronization</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventDefault">cudaEventDefault</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default event flag</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventDisableTiming">cudaEventDisableTiming</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event will not record timing data</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventInterprocess">cudaEventInterprocess</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event is suitable for interprocess use. cudaEventDisableTiming must be set</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaHostAllocDefault">cudaHostAllocDefault</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default page-locked allocation flag</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaHostAllocMapped">cudaHostAllocMapped</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map allocation into device space</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaHostAllocPortable">cudaHostAllocPortable</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pinned memory accessible by all CUDA contexts</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaHostAllocWriteCombined">cudaHostAllocWriteCombined</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write-combined memory</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaHostRegisterDefault">cudaHostRegisterDefault</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default host memory registration flag</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaHostRegisterMapped">cudaHostRegisterMapped</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map registered memory into device space</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaHostRegisterPortable">cudaHostRegisterPortable</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pinned memory accessible by all CUDA contexts</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaIpcMemLazyEnablePeerAccess">cudaIpcMemLazyEnablePeerAccess</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Automatically enable peer access between remote devices as needed</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaPeerAccessDefault">cudaPeerAccessDefault</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default peer addressing enable flag</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#CUDART_VERSION">CUDART_VERSION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CUDA runtime version</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCallbackBlocking">cudaStreamCallbackBlocking</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>This flag was only present in CUDA 5.0.25 (release candidate) 
 and may be removed (or added again) in future releases</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCallbackNonblocking">cudaStreamCallbackNonblocking</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>This flag was only present in CUDA 5.0.25 (release candidate) 
 and may be removed (or added again) in future releases</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamDefault">cudaStreamDefault</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default stream flag</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamNonBlocking">cudaStreamNonBlocking</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stream does not synchronize with stream 0 (the NULL stream)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaSurfaceType1D">cudaSurfaceType1D</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaSurfaceType1D</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaSurfaceType1DLayered">cudaSurfaceType1DLayered</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaSurfaceType1DLayered</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaSurfaceType2D">cudaSurfaceType2D</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaSurfaceType2D</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaSurfaceType2DLayered">cudaSurfaceType2DLayered</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaSurfaceType2DLayered</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaSurfaceType3D">cudaSurfaceType3D</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaSurfaceType3D</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaSurfaceTypeCubemap">cudaSurfaceTypeCubemap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaSurfaceTypeCubemap</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaSurfaceTypeCubemapLayered">cudaSurfaceTypeCubemapLayered</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaSurfaceTypeCubemapLayered</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaTextureType1D">cudaTextureType1D</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaTextureType1D</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaTextureType1DLayered">cudaTextureType1DLayered</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaTextureType1DLayered</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaTextureType2D">cudaTextureType2D</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaTextureType2D</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaTextureType2DLayered">cudaTextureType2DLayered</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaTextureType2DLayered</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaTextureType3D">cudaTextureType3D</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaTextureType3D</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaTextureTypeCubemap">cudaTextureTypeCubemap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaTextureTypeCubemap</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaTextureTypeCubemapLayered">cudaTextureTypeCubemapLayered</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cudaTextureTypeCubemapLayered</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaArrayGetInfo(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent, int[], jcuda.runtime.cudaArray)">cudaArrayGetInfo</A></B>(<A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                 <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent,
                 int[]&nbsp;flags,
                 <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets info about the specified cudaArray.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaBindSurfaceToArray(jcuda.runtime.surfaceReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)">cudaBindSurfaceToArray</A></B>(<A HREF="../../jcuda/runtime/surfaceReference.html" title="class in jcuda.runtime">surfaceReference</A>&nbsp;surfref,
                       <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array,
                       <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Binds an array to a surface
 
 
 template < class T, int dim > cudaError_t cudaBindSurfaceToArray (
      const surface < T,
      dim > & surf,
      cudaArray_const_t array,
      const cudaChannelFormatDesc& desc ) [inline]
 
 <div>
   [C++ API] Binds an array to a surface 
     Binds the CUDA array <tt>array</tt> to the surface reference <tt>surf</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)">cudaBindTexture</A></B>(long[]&nbsp;offset,
                <A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                long&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Binds a memory area to a texture
 
 
 template < class T, int dim, enum cudaTextureReadMode readMode >
 cudaError_t cudaBindTexture (
      size_t* offset,
      const texture < T,
      dim,
      readMode > & tex,
      const void* devPtr,
      const cudaChannelFormatDesc& desc,
      size_t size = UINT_MAX ) [inline]
 
 <div>
   [C++ API] Binds a memory area to a
     texture  Binds <tt>size</tt> bytes of the memory area pointed to by
     <tt>devPtr</tt> to texture reference <tt>tex</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)">cudaBindTexture2D</A></B>(long[]&nbsp;offset,
                  <A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                  <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                  <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                  long&nbsp;width,
                  long&nbsp;height,
                  long&nbsp;pitch)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Binds a 2D memory area to a texture
 
 
 template < class T, int dim, enum cudaTextureReadMode readMode >
 cudaError_t cudaBindTexture2D (
      size_t* offset,
      const texture < T,
      dim,
      readMode > & tex,
      const void* devPtr,
      const cudaChannelFormatDesc& desc,
      size_t width,
      size_t height,
      size_t pitch ) [inline]
 
 <div>
   [C++ API] Binds a 2D memory area to a
     texture  Binds the 2D memory area pointed to by <tt>devPtr</tt> to
     the texture reference <tt>tex</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)">cudaBindTextureToArray</A></B>(<A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                       <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array,
                       <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Binds an array to a texture
 
 
 template < class T, int dim, enum cudaTextureReadMode readMode >
 cudaError_t cudaBindTextureToArray (
      const texture < T,
      dim,
      readMode > & tex,
      cudaArray_const_t array,
      const cudaChannelFormatDesc& desc ) [inline]
 
 <div>
   [C++ API] Binds an array to a texture 
     Binds the CUDA array <tt>array</tt> to the texture reference <tt>tex</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToMipmappedArray(jcuda.runtime.textureReference, jcuda.runtime.cudaMipmappedArray, jcuda.runtime.cudaChannelFormatDesc)">cudaBindTextureToMipmappedArray</A></B>(<A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                                <A HREF="../../jcuda/runtime/cudaMipmappedArray.html" title="class in jcuda.runtime">cudaMipmappedArray</A>&nbsp;mipmappedArray,
                                <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Binds a mipmapped array to a texture
 
 
 template < class T, int dim, enum cudaTextureReadMode readMode >
 cudaError_t cudaBindTextureToMipmappedArray (
      const texture < T,
      dim,
      readMode > & tex,
      cudaMipmappedArray_const_t mipmappedArray,
      const cudaChannelFormatDesc& desc ) [inline]
 
 <div>
   [C++ API] Binds a mipmapped array to a
     texture  Binds the CUDA mipmapped array <tt>mipmappedArray</tt> to
     the texture reference <tt>tex</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)">cudaChooseDevice</A></B>(int[]&nbsp;device,
                 <A HREF="../../jcuda/runtime/cudaDeviceProp.html" title="class in jcuda.runtime">cudaDeviceProp</A>&nbsp;prop)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select compute-device which best matches criteria.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaConfigureCall(jcuda.runtime.dim3, jcuda.runtime.dim3, long, jcuda.runtime.cudaStream_t)">cudaConfigureCall</A></B>(<A HREF="../../jcuda/runtime/dim3.html" title="class in jcuda.runtime">dim3</A>&nbsp;gridDim,
                  <A HREF="../../jcuda/runtime/dim3.html" title="class in jcuda.runtime">dim3</A>&nbsp;blockDim,
                  long&nbsp;sharedMem,
                  <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Configure a device-launch.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateChannelDesc(int, int, int, int, int)">cudaCreateChannelDesc</A></B>(int&nbsp;x,
                      int&nbsp;y,
                      int&nbsp;z,
                      int&nbsp;w,
                      int&nbsp;cudaChannelFormatKind_f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Returns a channel descriptor using the specified format
 
 
 template < class T > cudaChannelFormatDesc cudaCreateChannelDesc (
      void ) [inline]
 
 <div>
   [C++ API] Returns a channel descriptor
     using the specified format  Returns a channel descriptor with format
     <tt>f</tt> and number of bits of each component <tt>x</tt>, <tt>y</tt>, <tt>z</tt>, and <tt>w</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateSurfaceObject(jcuda.runtime.cudaSurfaceObject, jcuda.runtime.cudaResourceDesc)">cudaCreateSurfaceObject</A></B>(<A HREF="../../jcuda/runtime/cudaSurfaceObject.html" title="class in jcuda.runtime">cudaSurfaceObject</A>&nbsp;pSurfObject,
                        <A HREF="../../jcuda/runtime/cudaResourceDesc.html" title="class in jcuda.runtime">cudaResourceDesc</A>&nbsp;pResDesc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a surface object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateTextureObject(jcuda.runtime.cudaTextureObject, jcuda.runtime.cudaResourceDesc, jcuda.runtime.cudaTextureDesc, jcuda.runtime.cudaResourceViewDesc)">cudaCreateTextureObject</A></B>(<A HREF="../../jcuda/runtime/cudaTextureObject.html" title="class in jcuda.runtime">cudaTextureObject</A>&nbsp;pTexObject,
                        <A HREF="../../jcuda/runtime/cudaResourceDesc.html" title="class in jcuda.runtime">cudaResourceDesc</A>&nbsp;pResDesc,
                        <A HREF="../../jcuda/runtime/cudaTextureDesc.html" title="class in jcuda.runtime">cudaTextureDesc</A>&nbsp;pTexDesc,
                        <A HREF="../../jcuda/runtime/cudaResourceViewDesc.html" title="class in jcuda.runtime">cudaResourceViewDesc</A>&nbsp;pResViewDesc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a texture object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDestroySurfaceObject(jcuda.runtime.cudaSurfaceObject)">cudaDestroySurfaceObject</A></B>(<A HREF="../../jcuda/runtime/cudaSurfaceObject.html" title="class in jcuda.runtime">cudaSurfaceObject</A>&nbsp;surfObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroys a surface object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDestroyTextureObject(jcuda.runtime.cudaTextureObject)">cudaDestroyTextureObject</A></B>(<A HREF="../../jcuda/runtime/cudaTextureObject.html" title="class in jcuda.runtime">cudaTextureObject</A>&nbsp;texObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroys a texture object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceCanAccessPeer(int[], int, int)">cudaDeviceCanAccessPeer</A></B>(int[]&nbsp;canAccessPeer,
                        int&nbsp;device,
                        int&nbsp;peerDevice)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queries if a device may directly access a peer device's memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceDisablePeerAccess(int)">cudaDeviceDisablePeerAccess</A></B>(int&nbsp;peerDevice)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disables direct access to memory allocations on a peer device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceEnablePeerAccess(int, int)">cudaDeviceEnablePeerAccess</A></B>(int&nbsp;peerDevice,
                           int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables direct access to memory allocations on a peer device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceGetAttribute(int[], int, int)">cudaDeviceGetAttribute</A></B>(int[]&nbsp;value,
                       int&nbsp;cudaDeviceAttr_attr,
                       int&nbsp;device)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns information about the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceGetByPCIBusId(int[], java.lang.String)">cudaDeviceGetByPCIBusId</A></B>(int[]&nbsp;device,
                        java.lang.String&nbsp;pciBusId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a handle to a compute device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceGetCacheConfig(int[])">cudaDeviceGetCacheConfig</A></B>(int[]&nbsp;pCacheConfig)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the preferred cache configuration for the current device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceGetLimit(long[], int)">cudaDeviceGetLimit</A></B>(long[]&nbsp;pValue,
                   int&nbsp;limit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns resource limits.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceGetPCIBusId(java.lang.String[], int, int)">cudaDeviceGetPCIBusId</A></B>(java.lang.String[]&nbsp;pciBusId,
                      int&nbsp;len,
                      int&nbsp;device)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a PCI Bus Id string for the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceGetSharedMemConfig(int[])">cudaDeviceGetSharedMemConfig</A></B>(int[]&nbsp;pConfig)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the shared memory configuration for the current device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceReset()">cudaDeviceReset</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroy all allocations and reset all state on the current device in the current process.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetCacheConfig(int)">cudaDeviceSetCacheConfig</A></B>(int&nbsp;cacheConfig)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the preferred cache configuration for the current device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetLimit(int, long)">cudaDeviceSetLimit</A></B>(int&nbsp;limit,
                   long&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set resource limits.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetSharedMemConfig(int)">cudaDeviceSetSharedMemConfig</A></B>(int&nbsp;config)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the shared memory configuration for the current device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSynchronize()">cudaDeviceSynchronize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wait for compute device to finish.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDriverGetVersion(int[])">cudaDriverGetVersion</A></B>(int[]&nbsp;driverVersion)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the CUDA driver version.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreate(jcuda.runtime.cudaEvent_t)">cudaEventCreate</A></B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Creates an event object with the specified flags
 
 
 cudaError_t cudaEventCreate (
      cudaEvent_t* event,
      unsigned int  flags )
 
 <div>
   [C++ API] Creates an event object with
     the specified flags  Creates an event object with the specified flags.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)">cudaEventCreateWithFlags</A></B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event,
                         int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an event object with the specified flags.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventDestroy(jcuda.runtime.cudaEvent_t)">cudaEventDestroy</A></B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroys an event object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)">cudaEventElapsedTime</A></B>(float[]&nbsp;ms,
                     <A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;start,
                     <A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the elapsed time between events.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventQuery(jcuda.runtime.cudaEvent_t)">cudaEventQuery</A></B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queries an event's status.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)">cudaEventRecord</A></B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event,
                <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Records an event.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventSynchronize(jcuda.runtime.cudaEvent_t)">cudaEventSynchronize</A></B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Waits for an event to complete.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)">cudaFree</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frees memory on the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)">cudaFreeArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frees an array on the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)">cudaFreeHost</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frees page-locked memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaFreeMipmappedArray(jcuda.runtime.cudaMipmappedArray)">cudaFreeMipmappedArray</A></B>(<A HREF="../../jcuda/runtime/cudaMipmappedArray.html" title="class in jcuda.runtime">cudaMipmappedArray</A>&nbsp;mipmappedArray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frees a mipmapped array on the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaFuncGetAttributes(jcuda.runtime.cudaFuncAttributes, java.lang.String)">cudaFuncGetAttributes</A></B>(<A HREF="../../jcuda/runtime/cudaFuncAttributes.html" title="class in jcuda.runtime">cudaFuncAttributes</A>&nbsp;attr,
                      java.lang.String&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Find out attributes for a given function
 
 
 template < class T > cudaError_t cudaFuncGetAttributes (
      cudaFuncAttributes* attr,
      T* entry ) [inline]
 
 <div>
   [C++ API] Find out attributes for a given
     function  This function obtains the attributes of a function specified
     via <tt>entry</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)">cudaGetChannelDesc</A></B>(<A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                   <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the channel descriptor of an array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDevice(int[])">cudaGetDevice</A></B>(int[]&nbsp;device)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns which device is currently being used.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceCount(int[])">cudaGetDeviceCount</A></B>(int[]&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of compute-capable devices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)">cudaGetDeviceProperties</A></B>(<A HREF="../../jcuda/runtime/cudaDeviceProp.html" title="class in jcuda.runtime">cudaDeviceProp</A>&nbsp;prop,
                        int&nbsp;device)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns information about the compute-device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetErrorString(int)">cudaGetErrorString</A></B>(int&nbsp;error)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the message string from an error code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetLastError()">cudaGetLastError</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the last error from a runtime call.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetMipmappedArrayLevel(jcuda.runtime.cudaArray, jcuda.runtime.cudaMipmappedArray, int)">cudaGetMipmappedArrayLevel</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;levelArray,
                           <A HREF="../../jcuda/runtime/cudaMipmappedArray.html" title="class in jcuda.runtime">cudaMipmappedArray</A>&nbsp;mipmappedArray,
                           int&nbsp;level)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets a mipmap level of a CUDA mipmapped array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetSurfaceObjectResourceDesc(jcuda.runtime.cudaResourceDesc, jcuda.runtime.cudaSurfaceObject)">cudaGetSurfaceObjectResourceDesc</A></B>(<A HREF="../../jcuda/runtime/cudaResourceDesc.html" title="class in jcuda.runtime">cudaResourceDesc</A>&nbsp;pResDesc,
                                 <A HREF="../../jcuda/runtime/cudaSurfaceObject.html" title="class in jcuda.runtime">cudaSurfaceObject</A>&nbsp;surfObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a surface object's resource descriptor Returns the resource descriptor for the surface object specified by surfObject.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetSurfaceReference(jcuda.runtime.surfaceReference, java.lang.String)">cudaGetSurfaceReference</A></B>(<A HREF="../../jcuda/runtime/surfaceReference.html" title="class in jcuda.runtime">surfaceReference</A>&nbsp;surfref,
                        java.lang.String&nbsp;symbol)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the surface reference associated with a symbol.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetSymbolAddress(jcuda.Pointer, java.lang.String)">cudaGetSymbolAddress</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                     java.lang.String&nbsp;symbol)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Finds the address associated with a CUDA symbol
 
 
 template < class T > cudaError_t cudaGetSymbolAddress (
      void** devPtr,
      const T& symbol ) [inline]
 
 <div>
   [C++ API] Finds the address associated
     with a CUDA symbol  Returns in <tt>*devPtr</tt> the address of symbol
     <tt>symbol</tt> on the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetSymbolSize(long[], java.lang.String)">cudaGetSymbolSize</A></B>(long[]&nbsp;size,
                  java.lang.String&nbsp;symbol)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Finds the size of the object associated with a CUDA symbol
 
 
 template < class T > cudaError_t cudaGetSymbolSize (
      size_t* size,
      const T& symbol ) [inline]
 
 <div>
   [C++ API] Finds the size of the object
     associated with a CUDA symbol  Returns in <tt>*size</tt> the size of
     symbol <tt>symbol</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)">cudaGetTextureAlignmentOffset</A></B>(long[]&nbsp;offset,
                              <A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Get the alignment offset of a texture
 
 
 template < class T, int dim, enum cudaTextureReadMode readMode >
 cudaError_t cudaGetTextureAlignmentOffset (
      size_t* offset,
      const texture < T,
      dim,
      readMode > & tex ) [inline]
 
 <div>
   [C++ API] Get the alignment offset of a
     texture  Returns in <tt>*offset</tt> the offset that was returned when
     texture reference <tt>tex</tt> was bound.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureObjectResourceDesc(jcuda.runtime.cudaResourceDesc, jcuda.runtime.cudaTextureObject)">cudaGetTextureObjectResourceDesc</A></B>(<A HREF="../../jcuda/runtime/cudaResourceDesc.html" title="class in jcuda.runtime">cudaResourceDesc</A>&nbsp;pResDesc,
                                 <A HREF="../../jcuda/runtime/cudaTextureObject.html" title="class in jcuda.runtime">cudaTextureObject</A>&nbsp;texObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a texture object's resource descriptor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureObjectResourceViewDesc(jcuda.runtime.cudaResourceViewDesc, jcuda.runtime.cudaTextureObject)">cudaGetTextureObjectResourceViewDesc</A></B>(<A HREF="../../jcuda/runtime/cudaResourceViewDesc.html" title="class in jcuda.runtime">cudaResourceViewDesc</A>&nbsp;pResViewDesc,
                                     <A HREF="../../jcuda/runtime/cudaTextureObject.html" title="class in jcuda.runtime">cudaTextureObject</A>&nbsp;texObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a texture object's resource view descriptor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureObjectTextureDesc(jcuda.runtime.cudaTextureDesc, jcuda.runtime.cudaTextureObject)">cudaGetTextureObjectTextureDesc</A></B>(<A HREF="../../jcuda/runtime/cudaTextureDesc.html" title="class in jcuda.runtime">cudaTextureDesc</A>&nbsp;pTexDesc,
                                <A HREF="../../jcuda/runtime/cudaTextureObject.html" title="class in jcuda.runtime">cudaTextureObject</A>&nbsp;texObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a texture object's texture descriptor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)">cudaGetTextureReference</A></B>(<A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                        java.lang.String&nbsp;symbol)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the texture reference associated with a symbol.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGLGetDevices(int[], int[], int, int)">cudaGLGetDevices</A></B>(int[]&nbsp;pCudaDeviceCount,
                 int[]&nbsp;pCudaDevices,
                 int&nbsp;cudaDeviceCount,
                 int&nbsp;cudaGLDeviceList_deviceList)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the CUDA devices associated with the current OpenGL context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGLMapBufferObject(jcuda.Pointer, int)">cudaGLMapBufferObject</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                      int&nbsp;bufObj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maps a buffer object for access by CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGLMapBufferObjectAsync(jcuda.Pointer, int, jcuda.runtime.cudaStream_t)">cudaGLMapBufferObjectAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                           int&nbsp;bufObj,
                           <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maps a buffer object for access by CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGLRegisterBufferObject(int)">cudaGLRegisterBufferObject</A></B>(int&nbsp;bufObj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers a buffer object for access by CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGLSetBufferObjectMapFlags(int, int)">cudaGLSetBufferObjectMapFlags</A></B>(int&nbsp;bufObj,
                              int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set usage flags for mapping an OpenGL buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGLSetGLDevice(int)">cudaGLSetGLDevice</A></B>(int&nbsp;device)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a CUDA device to use OpenGL interoperability.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGLUnmapBufferObject(int)">cudaGLUnmapBufferObject</A></B>(int&nbsp;bufObj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unmaps a buffer object for access by CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGLUnmapBufferObjectAsync(int, jcuda.runtime.cudaStream_t)">cudaGLUnmapBufferObjectAsync</A></B>(int&nbsp;bufObj,
                             <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unmaps a buffer object for access by CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGLUnregisterBufferObject(int)">cudaGLUnregisterBufferObject</A></B>(int&nbsp;bufObj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unregisters a buffer object for access by CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsGLRegisterBuffer(jcuda.runtime.cudaGraphicsResource, int, int)">cudaGraphicsGLRegisterBuffer</A></B>(<A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource,
                             int&nbsp;buffer,
                             int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers an OpenGL buffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsGLRegisterImage(jcuda.runtime.cudaGraphicsResource, int, int, int)">cudaGraphicsGLRegisterImage</A></B>(<A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource,
                            int&nbsp;image,
                            int&nbsp;target,
                            int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register an OpenGL texture or renderbuffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)">cudaGraphicsMapResources</A></B>(int&nbsp;count,
                         <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>[]&nbsp;resources,
                         <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map graphics resources for access by CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsResourceGetMappedMipmappedArray(jcuda.runtime.cudaMipmappedArray, jcuda.runtime.cudaGraphicsResource)">cudaGraphicsResourceGetMappedMipmappedArray</A></B>(<A HREF="../../jcuda/runtime/cudaMipmappedArray.html" title="class in jcuda.runtime">cudaMipmappedArray</A>&nbsp;mipmappedArray,
                                            <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a mipmapped array through which to access a mapped graphics resource.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)">cudaGraphicsResourceGetMappedPointer</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                     long[]&nbsp;size,
                                     <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get an device pointer through which to access a mapped graphics resource.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsResourceSetMapFlags(jcuda.runtime.cudaGraphicsResource, int)">cudaGraphicsResourceSetMapFlags</A></B>(<A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource,
                                int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set usage flags for mapping a graphics resource.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)">cudaGraphicsSubResourceGetMappedArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;arrayPtr,
                                      <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource,
                                      int&nbsp;arrayIndex,
                                      int&nbsp;mipLevel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get an array through which to access a subresource of a mapped graphics resource.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsUnmapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)">cudaGraphicsUnmapResources</A></B>(int&nbsp;count,
                           <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>[]&nbsp;resources,
                           <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unmap graphics resources.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsUnregisterResource(jcuda.runtime.cudaGraphicsResource)">cudaGraphicsUnregisterResource</A></B>(<A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unregisters a graphics resource for access by CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaHostAlloc(jcuda.Pointer, long, int)">cudaHostAlloc</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr,
              long&nbsp;size,
              int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates page-locked memory on the host.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaHostGetDevicePointer(jcuda.Pointer, jcuda.Pointer, int)">cudaHostGetDevicePointer</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pDevice,
                         <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pHost,
                         int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Passes back device pointer of mapped host memory allocated by cudaHostAlloc or registered by cudaHostRegister.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaHostRegister(jcuda.Pointer, long, int)">cudaHostRegister</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr,
                 long&nbsp;size,
                 int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers an existing host memory range for use by CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaHostUnregister(jcuda.Pointer)">cudaHostUnregister</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unregisters a memory range that was registered with cudaHostRegister.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaIpcCloseMemHandle(jcuda.Pointer)">cudaIpcCloseMemHandle</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Close memory mapped with cudaIpcOpenMemHandle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaIpcGetEventHandle(jcuda.runtime.cudaIpcEventHandle, jcuda.runtime.cudaEvent_t)">cudaIpcGetEventHandle</A></B>(<A HREF="../../jcuda/runtime/cudaIpcEventHandle.html" title="class in jcuda.runtime">cudaIpcEventHandle</A>&nbsp;handle,
                      <A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets an interprocess handle for a previously allocated event.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaIpcGetMemHandle(jcuda.runtime.cudaIpcMemHandle, jcuda.Pointer)">cudaIpcGetMemHandle</A></B>(<A HREF="../../jcuda/runtime/cudaIpcMemHandle.html" title="class in jcuda.runtime">cudaIpcMemHandle</A>&nbsp;handle,
                    <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 cudaError_t cudaIpcGetMemHandle (
      cudaIpcMemHandle_t* handle,
      void* devPtr )
 
 <div>
    /brief Gets an interprocess memory
     handle for an existing device memory allocation
   
   Takes a pointer to the base of an
     existing device memory allocation created with cudaMalloc and exports
     it for use in another process.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaIpcOpenEventHandle(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaIpcEventHandle)">cudaIpcOpenEventHandle</A></B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event,
                       <A HREF="../../jcuda/runtime/cudaIpcEventHandle.html" title="class in jcuda.runtime">cudaIpcEventHandle</A>&nbsp;handle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Opens an interprocess event handle for use in the current process.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaIpcOpenMemHandle(jcuda.Pointer, jcuda.runtime.cudaIpcMemHandle, int)">cudaIpcOpenMemHandle</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                     <A HREF="../../jcuda/runtime/cudaIpcMemHandle.html" title="class in jcuda.runtime">cudaIpcMemHandle</A>&nbsp;handle,
                     int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 cudaError_t cudaIpcOpenMemHandle (
      void** devPtr,
      cudaIpcMemHandle_t handle,
      unsigned int  flags )
 
 <div>
    /brief Opens an interprocess memory
     handle exported from another process and returns a device pointer
     usable in the local
     process.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaLaunch(java.lang.String)">cudaLaunch</A></B>(java.lang.String&nbsp;symbol)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Launches a device function
 
 
 template < class T > cudaError_t cudaLaunch (
      T* func ) [inline]
 
 <div>
   [C++ API] Launches a device function 
     Launches the function <tt>entry</tt> on the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)">cudaMalloc</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
           long&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocate memory on the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)">cudaMalloc3D</A></B>(<A HREF="../../jcuda/runtime/cudaPitchedPtr.html" title="class in jcuda.runtime">cudaPitchedPtr</A>&nbsp;pitchDevPtr,
             <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates logical 1D, 2D, or 3D memory objects on the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)">cudaMalloc3DArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;arrayPtr,
                  <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                  <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocate an array on the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent, int)">cudaMalloc3DArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;arrayPtr,
                  <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                  <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent,
                  int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocate an array on the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)">cudaMallocArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array,
                <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                long&nbsp;width,
                long&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocate an array on the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long, int)">cudaMallocArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array,
                <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                long&nbsp;width,
                long&nbsp;height,
                int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocate an array on the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)">cudaMallocHost</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr,
               long&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Allocates page-locked memory on the host
 
 
 cudaError_t cudaMallocHost (
      void** ptr,
      size_t size,
      unsigned int  flags )
 
 <div>
   [C++ API] Allocates page-locked memory
     on the host  Allocates <tt>size</tt> bytes of host memory that is
     page-locked and accessible to the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMallocMipmappedArray(jcuda.runtime.cudaMipmappedArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent, int, int)">cudaMallocMipmappedArray</A></B>(<A HREF="../../jcuda/runtime/cudaMipmappedArray.html" title="class in jcuda.runtime">cudaMipmappedArray</A>&nbsp;mipmappedArray,
                         <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                         <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent,
                         int&nbsp;numLevels,
                         int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocate a mipmapped array on the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)">cudaMallocPitch</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                long[]&nbsp;pitch,
                long&nbsp;width,
                long&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates pitched memory on the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)">cudaMemcpy</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
           <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
           long&nbsp;count,
           int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)">cudaMemcpy2D</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
             long&nbsp;dpitch,
             <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
             long&nbsp;spitch,
             long&nbsp;width,
             long&nbsp;height,
             int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)">cudaMemcpy2DArrayToArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                         long&nbsp;wOffsetDst,
                         long&nbsp;hOffsetDst,
                         <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                         long&nbsp;wOffsetSrc,
                         long&nbsp;hOffsetSrc,
                         long&nbsp;width,
                         long&nbsp;height,
                         int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)">cudaMemcpy2DAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                  long&nbsp;dpitch,
                  <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                  long&nbsp;spitch,
                  long&nbsp;width,
                  long&nbsp;height,
                  int&nbsp;cudaMemcpyKind_kind,
                  <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)">cudaMemcpy2DFromArray</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                      long&nbsp;dpitch,
                      <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                      long&nbsp;wOffset,
                      long&nbsp;hOffset,
                      long&nbsp;width,
                      long&nbsp;height,
                      int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)">cudaMemcpy2DFromArrayAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                           long&nbsp;dpitch,
                           <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                           long&nbsp;wOffset,
                           long&nbsp;hOffset,
                           long&nbsp;width,
                           long&nbsp;height,
                           int&nbsp;cudaMemcpyKind_kind,
                           <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)">cudaMemcpy2DToArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                    long&nbsp;wOffset,
                    long&nbsp;hOffset,
                    <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                    long&nbsp;spitch,
                    long&nbsp;width,
                    long&nbsp;height,
                    int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)">cudaMemcpy2DToArrayAsync</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                         long&nbsp;wOffset,
                         long&nbsp;hOffset,
                         <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                         long&nbsp;spitch,
                         long&nbsp;width,
                         long&nbsp;height,
                         int&nbsp;cudaMemcpyKind_kind,
                         <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy3D(jcuda.runtime.cudaMemcpy3DParms)">cudaMemcpy3D</A></B>(<A HREF="../../jcuda/runtime/cudaMemcpy3DParms.html" title="class in jcuda.runtime">cudaMemcpy3DParms</A>&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between 3D objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy3DAsync(jcuda.runtime.cudaMemcpy3DParms, jcuda.runtime.cudaStream_t)">cudaMemcpy3DAsync</A></B>(<A HREF="../../jcuda/runtime/cudaMemcpy3DParms.html" title="class in jcuda.runtime">cudaMemcpy3DParms</A>&nbsp;p,
                  <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between 3D objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy3DPeer(jcuda.runtime.cudaMemcpy3DPeerParms)">cudaMemcpy3DPeer</A></B>(<A HREF="../../jcuda/runtime/cudaMemcpy3DPeerParms.html" title="class in jcuda.runtime">cudaMemcpy3DPeerParms</A>&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory between devices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy3DPeerAsync(jcuda.runtime.cudaMemcpy3DPeerParms, jcuda.runtime.cudaStream_t)">cudaMemcpy3DPeerAsync</A></B>(<A HREF="../../jcuda/runtime/cudaMemcpy3DPeerParms.html" title="class in jcuda.runtime">cudaMemcpy3DPeerParms</A>&nbsp;p,
                      <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory between devices asynchronously.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)">cudaMemcpyArrayToArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                       long&nbsp;wOffsetDst,
                       long&nbsp;hOffsetDst,
                       <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                       long&nbsp;wOffsetSrc,
                       long&nbsp;hOffsetSrc,
                       long&nbsp;count,
                       int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)">cudaMemcpyAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                long&nbsp;count,
                int&nbsp;cudaMemcpyKind_kind,
                <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)">cudaMemcpyFromArray</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                    <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                    long&nbsp;wOffset,
                    long&nbsp;hOffset,
                    long&nbsp;count,
                    int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)">cudaMemcpyFromArrayAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                         <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                         long&nbsp;wOffset,
                         long&nbsp;hOffset,
                         long&nbsp;count,
                         int&nbsp;cudaMemcpyKind_kind,
                         <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)">cudaMemcpyFromSymbol</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                     java.lang.String&nbsp;symbol,
                     long&nbsp;count,
                     long&nbsp;offset,
                     int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Copies data from the given symbol on the device
 
 
 template < class T > cudaError_t cudaMemcpyFromSymbol (
      void* dst,
      const T& symbol,
      size_t count,
      size_t offset = 0,
      cudaMemcpyKind kind = cudaMemcpyDeviceToHost ) [inline]
 
 <div>
   [C++ API] Copies data from the given
     symbol on the device  Copies <tt>count</tt> bytes from the memory area
     <tt>offset</tt> bytes from the start of symbol <tt>symbol</tt> to
     the memory area pointed to by <tt>dst</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)">cudaMemcpyFromSymbolAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                          java.lang.String&nbsp;symbol,
                          long&nbsp;count,
                          long&nbsp;offset,
                          int&nbsp;cudaMemcpyKind_kind,
                          <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Copies data from the given symbol on the device
 
 
 template < class T > cudaError_t cudaMemcpyFromSymbolAsync (
      void* dst,
      const T& symbol,
      size_t count,
      size_t offset = 0,
      cudaMemcpyKind kind = cudaMemcpyDeviceToHost,
      cudaStream_t stream = 0 ) [inline]
 
 <div>
   [C++ API] Copies data from the given
     symbol on the device  Copies <tt>count</tt> bytes from the memory area
     <tt>offset</tt> bytes from the start of symbol <tt>symbol</tt> to
     the memory area pointed to by <tt>dst</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyPeer(jcuda.Pointer, int, jcuda.Pointer, int, long)">cudaMemcpyPeer</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
               int&nbsp;dstDevice,
               <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
               int&nbsp;srcDevice,
               long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory between two devices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyPeerAsync(jcuda.Pointer, int, jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)">cudaMemcpyPeerAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                    int&nbsp;dstDevice,
                    <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                    int&nbsp;srcDevice,
                    long&nbsp;count,
                    <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory between two devices asynchronously.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)">cudaMemcpyToArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                  long&nbsp;wOffset,
                  long&nbsp;hOffset,
                  <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                  long&nbsp;count,
                  int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)">cudaMemcpyToArrayAsync</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                       long&nbsp;wOffset,
                       long&nbsp;hOffset,
                       <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                       long&nbsp;count,
                       int&nbsp;cudaMemcpyKind_kind,
                       <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)">cudaMemcpyToSymbol</A></B>(java.lang.String&nbsp;symbol,
                   <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                   long&nbsp;count,
                   long&nbsp;offset,
                   int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Copies data to the given symbol on the device
 
 
 template < class T > cudaError_t cudaMemcpyToSymbol (
      const T& symbol,
      const void* src,
      size_t count,
      size_t offset = 0,
      cudaMemcpyKind kind = cudaMemcpyHostToDevice ) [inline]
 
 <div>
   [C++ API] Copies data to the given symbol
     on the device  Copies <tt>count</tt> bytes from the memory area
     pointed to by <tt>src</tt> to the memory area <tt>offset</tt> bytes
     from the start of symbol <tt>symbol</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)">cudaMemcpyToSymbolAsync</A></B>(java.lang.String&nbsp;symbol,
                        <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                        long&nbsp;count,
                        long&nbsp;offset,
                        int&nbsp;cudaMemcpyKind_kind,
                        <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Copies data to the given symbol on the device
 
 
 template < class T > cudaError_t cudaMemcpyToSymbolAsync (
      const T& symbol,
      const void* src,
      size_t count,
      size_t offset = 0,
      cudaMemcpyKind kind = cudaMemcpyHostToDevice,
      cudaStream_t stream = 0 ) [inline]
 
 <div>
   [C++ API] Copies data to the given symbol
     on the device  Copies <tt>count</tt> bytes from the memory area
     pointed to by <tt>src</tt> to the memory area <tt>offset</tt> bytes
     from the start of symbol <tt>symbol</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemGetInfo(long[], long[])">cudaMemGetInfo</A></B>(long[]&nbsp;free,
               long[]&nbsp;total)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets free and total device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemset(jcuda.Pointer, int, long)">cudaMemset</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;mem,
           int&nbsp;c,
           long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes or sets device memory to a value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemset2D(jcuda.Pointer, long, int, long, long)">cudaMemset2D</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;mem,
             long&nbsp;pitch,
             int&nbsp;c,
             long&nbsp;width,
             long&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes or sets device memory to a value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemset2DAsync(jcuda.Pointer, long, int, long, long, jcuda.runtime.cudaStream_t)">cudaMemset2DAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                  long&nbsp;pitch,
                  int&nbsp;value,
                  long&nbsp;width,
                  long&nbsp;height,
                  <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes or sets device memory to a value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)">cudaMemset3D</A></B>(<A HREF="../../jcuda/runtime/cudaPitchedPtr.html" title="class in jcuda.runtime">cudaPitchedPtr</A>&nbsp;pitchDevPtr,
             int&nbsp;value,
             <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes or sets device memory to a value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3DAsync(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent, jcuda.runtime.cudaStream_t)">cudaMemset3DAsync</A></B>(<A HREF="../../jcuda/runtime/cudaPitchedPtr.html" title="class in jcuda.runtime">cudaPitchedPtr</A>&nbsp;pitchedDevPtr,
                  int&nbsp;value,
                  <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent,
                  <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes or sets device memory to a value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemsetAsync(jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)">cudaMemsetAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                int&nbsp;value,
                long&nbsp;count,
                <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes or sets device memory to a value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaPeekAtLastError()">cudaPeekAtLastError</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the last error from a runtime call.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaPointerGetAttributes(jcuda.runtime.cudaPointerAttributes, jcuda.Pointer)">cudaPointerGetAttributes</A></B>(<A HREF="../../jcuda/runtime/cudaPointerAttributes.html" title="class in jcuda.runtime">cudaPointerAttributes</A>&nbsp;attributes,
                         <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns attributes about a specified pointer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaProfilerInitialize(java.lang.String, java.lang.String, int)">cudaProfilerInitialize</A></B>(java.lang.String&nbsp;configFile,
                       java.lang.String&nbsp;outputFile,
                       int&nbsp;outputMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initialize the CUDA profiler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaProfilerStart()">cudaProfilerStart</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable profiling.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaProfilerStop()">cudaProfilerStop</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disable profiling.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaRuntimeGetVersion(int[])">cudaRuntimeGetVersion</A></B>(int[]&nbsp;runtimeVersion)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the CUDA Runtime version.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaSetDevice(int)">cudaSetDevice</A></B>(int&nbsp;device)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set device to be used for GPU executions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaSetDeviceFlags(int)">cudaSetDeviceFlags</A></B>(int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets flags to be used for device executions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaSetupArgument(jcuda.Pointer, long, long)">cudaSetupArgument</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;arg,
                  long&nbsp;size,
                  long&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Configure a device launch
 
 
 template < class T > cudaError_t cudaSetupArgument (
      T arg,
      size_t offset ) [inline]
 
 <div>
   [C++ API] Configure a device launch 
     Pushes <tt>size</tt> bytes of the argument pointed to by <tt>arg</tt>
     at <tt>offset</tt> bytes from the start of the parameter passing area,
     which starts at offset 0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaSetValidDevices(int[], int)">cudaSetValidDevices</A></B>(int[]&nbsp;device_arr,
                    int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set a list of devices that can be used for CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamAddCallback(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaStreamCallback, java.lang.Object, int)">cudaStreamAddCallback</A></B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream,
                      <A HREF="../../jcuda/runtime/cudaStreamCallback.html" title="interface in jcuda.runtime">cudaStreamCallback</A>&nbsp;callback,
                      java.lang.Object&nbsp;userData,
                      int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a callback to a compute stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreate(jcuda.runtime.cudaStream_t)">cudaStreamCreate</A></B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an asynchronous stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreateWithFlags(jcuda.runtime.cudaStream_t, int)">cudaStreamCreateWithFlags</A></B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;pStream,
                          int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an asynchronous stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamDestroy(jcuda.runtime.cudaStream_t)">cudaStreamDestroy</A></B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroys and cleans up an asynchronous stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamQuery(jcuda.runtime.cudaStream_t)">cudaStreamQuery</A></B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queries an asynchronous stream for completion status.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamSynchronize(jcuda.runtime.cudaStream_t)">cudaStreamSynchronize</A></B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Waits for stream tasks to complete.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)">cudaStreamWaitEvent</A></B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream,
                    <A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event,
                    int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a compute stream wait on an event.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaThreadExit()">cudaThreadExit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exit and clean up from CUDA launches.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaThreadGetCacheConfig(int[])">cudaThreadGetCacheConfig</A></B>(int[]&nbsp;pCacheConfig)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the preferred cache configuration for the current device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaThreadGetLimit(long[], int)">cudaThreadGetLimit</A></B>(long[]&nbsp;pValue,
                   int&nbsp;limit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns resource limits.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaThreadSetCacheConfig(int)">cudaThreadSetCacheConfig</A></B>(int&nbsp;cacheConfig)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the preferred cache configuration for the current device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaThreadSetLimit(int, long)">cudaThreadSetLimit</A></B>(int&nbsp;limit,
                   long&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set resource limits.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaThreadSynchronize()">cudaThreadSynchronize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wait for compute device to finish.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaUnbindTexture(jcuda.runtime.textureReference)">cudaUnbindTexture</A></B>(<A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[C++ API] Unbinds a texture
 
 
 template < class T, int dim, enum cudaTextureReadMode readMode >
 cudaError_t cudaUnbindTexture (
      const texture < T,
      dim,
      readMode > & tex ) [inline]
 
 <div>
   [C++ API] Unbinds a texture  Unbinds the
     texture bound to <tt>tex</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#initialize()">initialize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes the native library.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#setExceptionsEnabled(boolean)">setExceptionsEnabled</A></B>(boolean&nbsp;enabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables or disables exceptions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#setLogLevel(jcuda.LogLevel)">setLogLevel</A></B>(<A HREF="../../jcuda/LogLevel.html" title="enum in jcuda">LogLevel</A>&nbsp;logLevel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the specified log level for the JCuda runtime library.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="CUDART_VERSION"><!-- --></A><H3>
CUDART_VERSION</H3>
<PRE>
public static final int <B>CUDART_VERSION</B></PRE>
<DL>
<DD>CUDA runtime version
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.CUDART_VERSION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaHostAllocDefault"><!-- --></A><H3>
cudaHostAllocDefault</H3>
<PRE>
public static final int <B>cudaHostAllocDefault</B></PRE>
<DL>
<DD>Default page-locked allocation flag
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaHostAllocDefault">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaHostAllocPortable"><!-- --></A><H3>
cudaHostAllocPortable</H3>
<PRE>
public static final int <B>cudaHostAllocPortable</B></PRE>
<DL>
<DD>Pinned memory accessible by all CUDA contexts
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaHostAllocPortable">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaHostAllocMapped"><!-- --></A><H3>
cudaHostAllocMapped</H3>
<PRE>
public static final int <B>cudaHostAllocMapped</B></PRE>
<DL>
<DD>Map allocation into device space
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaHostAllocMapped">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaHostAllocWriteCombined"><!-- --></A><H3>
cudaHostAllocWriteCombined</H3>
<PRE>
public static final int <B>cudaHostAllocWriteCombined</B></PRE>
<DL>
<DD>Write-combined memory
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaHostAllocWriteCombined">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaHostRegisterDefault"><!-- --></A><H3>
cudaHostRegisterDefault</H3>
<PRE>
public static final int <B>cudaHostRegisterDefault</B></PRE>
<DL>
<DD>Default host memory registration flag
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaHostRegisterDefault">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaHostRegisterPortable"><!-- --></A><H3>
cudaHostRegisterPortable</H3>
<PRE>
public static final int <B>cudaHostRegisterPortable</B></PRE>
<DL>
<DD>Pinned memory accessible by all CUDA contexts
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaHostRegisterPortable">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaHostRegisterMapped"><!-- --></A><H3>
cudaHostRegisterMapped</H3>
<PRE>
public static final int <B>cudaHostRegisterMapped</B></PRE>
<DL>
<DD>Map registered memory into device space
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaHostRegisterMapped">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaPeerAccessDefault"><!-- --></A><H3>
cudaPeerAccessDefault</H3>
<PRE>
public static final int <B>cudaPeerAccessDefault</B></PRE>
<DL>
<DD>Default peer addressing enable flag
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaPeerAccessDefault">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaStreamDefault"><!-- --></A><H3>
cudaStreamDefault</H3>
<PRE>
public static final int <B>cudaStreamDefault</B></PRE>
<DL>
<DD>Default stream flag
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaStreamDefault">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaStreamNonBlocking"><!-- --></A><H3>
cudaStreamNonBlocking</H3>
<PRE>
public static final int <B>cudaStreamNonBlocking</B></PRE>
<DL>
<DD>Stream does not synchronize with stream 0 (the NULL stream)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaStreamNonBlocking">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaEventDefault"><!-- --></A><H3>
cudaEventDefault</H3>
<PRE>
public static final int <B>cudaEventDefault</B></PRE>
<DL>
<DD>Default event flag
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaEventDefault">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaEventBlockingSync"><!-- --></A><H3>
cudaEventBlockingSync</H3>
<PRE>
public static final int <B>cudaEventBlockingSync</B></PRE>
<DL>
<DD>Event uses blocking synchronization
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaEventBlockingSync">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaEventDisableTiming"><!-- --></A><H3>
cudaEventDisableTiming</H3>
<PRE>
public static final int <B>cudaEventDisableTiming</B></PRE>
<DL>
<DD>Event will not record timing data
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaEventDisableTiming">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaEventInterprocess"><!-- --></A><H3>
cudaEventInterprocess</H3>
<PRE>
public static final int <B>cudaEventInterprocess</B></PRE>
<DL>
<DD>Event is suitable for interprocess use. cudaEventDisableTiming must be set
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaEventInterprocess">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaDeviceScheduleAuto"><!-- --></A><H3>
cudaDeviceScheduleAuto</H3>
<PRE>
public static final int <B>cudaDeviceScheduleAuto</B></PRE>
<DL>
<DD>Device flag - Automatic scheduling
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaDeviceScheduleAuto">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaDeviceScheduleSpin"><!-- --></A><H3>
cudaDeviceScheduleSpin</H3>
<PRE>
public static final int <B>cudaDeviceScheduleSpin</B></PRE>
<DL>
<DD>Device flag - Spin default scheduling
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaDeviceScheduleSpin">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaDeviceScheduleYield"><!-- --></A><H3>
cudaDeviceScheduleYield</H3>
<PRE>
public static final int <B>cudaDeviceScheduleYield</B></PRE>
<DL>
<DD>Device flag - Yield default scheduling
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaDeviceScheduleYield">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaDeviceScheduleBlockingSync"><!-- --></A><H3>
cudaDeviceScheduleBlockingSync</H3>
<PRE>
public static final int <B>cudaDeviceScheduleBlockingSync</B></PRE>
<DL>
<DD>Device flag - Use blocking synchronization
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaDeviceScheduleBlockingSync">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaDeviceBlockingSync"><!-- --></A><H3>
cudaDeviceBlockingSync</H3>
<PRE>
public static final int <B>cudaDeviceBlockingSync</B></PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of CUDA 4.0 and replaced by cudaDeviceScheduleBlockingSync</I><DD>Device flag - Use blocking synchronization
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaDeviceBlockingSync">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaDeviceScheduleMask"><!-- --></A><H3>
cudaDeviceScheduleMask</H3>
<PRE>
public static final int <B>cudaDeviceScheduleMask</B></PRE>
<DL>
<DD>Device schedule flags mask
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaDeviceScheduleMask">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaDeviceMapHost"><!-- --></A><H3>
cudaDeviceMapHost</H3>
<PRE>
public static final int <B>cudaDeviceMapHost</B></PRE>
<DL>
<DD>Device flag - Support mapped pinned allocations
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaDeviceMapHost">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaDeviceLmemResizeToMax"><!-- --></A><H3>
cudaDeviceLmemResizeToMax</H3>
<PRE>
public static final int <B>cudaDeviceLmemResizeToMax</B></PRE>
<DL>
<DD>Device flag - Keep local memory allocation after launch
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaDeviceLmemResizeToMax">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaDeviceMask"><!-- --></A><H3>
cudaDeviceMask</H3>
<PRE>
public static final int <B>cudaDeviceMask</B></PRE>
<DL>
<DD>Device flags mask
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaDeviceMask">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaArrayDefault"><!-- --></A><H3>
cudaArrayDefault</H3>
<PRE>
public static final int <B>cudaArrayDefault</B></PRE>
<DL>
<DD>Default CUDA array allocation flag
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaArrayDefault">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaArrayLayered"><!-- --></A><H3>
cudaArrayLayered</H3>
<PRE>
public static final int <B>cudaArrayLayered</B></PRE>
<DL>
<DD>Must be set in cudaMalloc3DArray to create a layered CUDA array
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaArrayLayered">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaArraySurfaceLoadStore"><!-- --></A><H3>
cudaArraySurfaceLoadStore</H3>
<PRE>
public static final int <B>cudaArraySurfaceLoadStore</B></PRE>
<DL>
<DD>Must be set in cudaMallocArray or cudaMalloc3DArray in order
 to bind surfaces to the CUDA array
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaArraySurfaceLoadStore">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaArrayCubemap"><!-- --></A><H3>
cudaArrayCubemap</H3>
<PRE>
public static final int <B>cudaArrayCubemap</B></PRE>
<DL>
<DD>Must be set in cudaMalloc3DArray to create a cubemap CUDA array
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaArrayCubemap">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaArrayTextureGather"><!-- --></A><H3>
cudaArrayTextureGather</H3>
<PRE>
public static final int <B>cudaArrayTextureGather</B></PRE>
<DL>
<DD>Must be set in cudaMallocArray or cudaMalloc3DArray in order to
 perform texture gather operations on the CUDA array
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaArrayTextureGather">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaIpcMemLazyEnablePeerAccess"><!-- --></A><H3>
cudaIpcMemLazyEnablePeerAccess</H3>
<PRE>
public static final int <B>cudaIpcMemLazyEnablePeerAccess</B></PRE>
<DL>
<DD>Automatically enable peer access between remote devices as needed
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaIpcMemLazyEnablePeerAccess">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaStreamCallbackNonblocking"><!-- --></A><H3>
cudaStreamCallbackNonblocking</H3>
<PRE>
public static final int <B>cudaStreamCallbackNonblocking</B></PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>This flag was only present in CUDA 5.0.25 (release candidate) 
 and may be removed (or added again) in future releases</I><DD>Stream callback flag - stream does not block on callback execution (default)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaStreamCallbackNonblocking">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaStreamCallbackBlocking"><!-- --></A><H3>
cudaStreamCallbackBlocking</H3>
<PRE>
public static final int <B>cudaStreamCallbackBlocking</B></PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>This flag was only present in CUDA 5.0.25 (release candidate) 
 and may be removed (or added again) in future releases</I><DD>Stream callback flag - stream blocks on callback execution
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaStreamCallbackBlocking">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaSurfaceType1D"><!-- --></A><H3>
cudaSurfaceType1D</H3>
<PRE>
public static final int <B>cudaSurfaceType1D</B></PRE>
<DL>
<DD>cudaSurfaceType1D
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaSurfaceType1D">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaSurfaceType2D"><!-- --></A><H3>
cudaSurfaceType2D</H3>
<PRE>
public static final int <B>cudaSurfaceType2D</B></PRE>
<DL>
<DD>cudaSurfaceType2D
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaSurfaceType2D">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaSurfaceType3D"><!-- --></A><H3>
cudaSurfaceType3D</H3>
<PRE>
public static final int <B>cudaSurfaceType3D</B></PRE>
<DL>
<DD>cudaSurfaceType3D
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaSurfaceType3D">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaSurfaceTypeCubemap"><!-- --></A><H3>
cudaSurfaceTypeCubemap</H3>
<PRE>
public static final int <B>cudaSurfaceTypeCubemap</B></PRE>
<DL>
<DD>cudaSurfaceTypeCubemap
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaSurfaceTypeCubemap">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaSurfaceType1DLayered"><!-- --></A><H3>
cudaSurfaceType1DLayered</H3>
<PRE>
public static final int <B>cudaSurfaceType1DLayered</B></PRE>
<DL>
<DD>cudaSurfaceType1DLayered
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaSurfaceType1DLayered">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaSurfaceType2DLayered"><!-- --></A><H3>
cudaSurfaceType2DLayered</H3>
<PRE>
public static final int <B>cudaSurfaceType2DLayered</B></PRE>
<DL>
<DD>cudaSurfaceType2DLayered
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaSurfaceType2DLayered">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaSurfaceTypeCubemapLayered"><!-- --></A><H3>
cudaSurfaceTypeCubemapLayered</H3>
<PRE>
public static final int <B>cudaSurfaceTypeCubemapLayered</B></PRE>
<DL>
<DD>cudaSurfaceTypeCubemapLayered
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaSurfaceTypeCubemapLayered">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaTextureType1D"><!-- --></A><H3>
cudaTextureType1D</H3>
<PRE>
public static final int <B>cudaTextureType1D</B></PRE>
<DL>
<DD>cudaTextureType1D
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaTextureType1D">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaTextureType2D"><!-- --></A><H3>
cudaTextureType2D</H3>
<PRE>
public static final int <B>cudaTextureType2D</B></PRE>
<DL>
<DD>cudaTextureType2D
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaTextureType2D">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaTextureType3D"><!-- --></A><H3>
cudaTextureType3D</H3>
<PRE>
public static final int <B>cudaTextureType3D</B></PRE>
<DL>
<DD>cudaTextureType3D
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaTextureType3D">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaTextureTypeCubemap"><!-- --></A><H3>
cudaTextureTypeCubemap</H3>
<PRE>
public static final int <B>cudaTextureTypeCubemap</B></PRE>
<DL>
<DD>cudaTextureTypeCubemap
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaTextureTypeCubemap">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaTextureType1DLayered"><!-- --></A><H3>
cudaTextureType1DLayered</H3>
<PRE>
public static final int <B>cudaTextureType1DLayered</B></PRE>
<DL>
<DD>cudaTextureType1DLayered
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaTextureType1DLayered">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaTextureType2DLayered"><!-- --></A><H3>
cudaTextureType2DLayered</H3>
<PRE>
public static final int <B>cudaTextureType2DLayered</B></PRE>
<DL>
<DD>cudaTextureType2DLayered
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaTextureType2DLayered">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaTextureTypeCubemapLayered"><!-- --></A><H3>
cudaTextureTypeCubemapLayered</H3>
<PRE>
public static final int <B>cudaTextureTypeCubemapLayered</B></PRE>
<DL>
<DD>cudaTextureTypeCubemapLayered
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaTextureTypeCubemapLayered">Constant Field Values</A></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="initialize()"><!-- --></A><H3>
initialize</H3>
<PRE>
public static void <B>initialize</B>()</PRE>
<DL>
<DD>Initializes the native library. Note that this method
 does not have to be called explicitly by the user of
 the library: The library will automatically be
 initialized when this class is loaded.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setLogLevel(jcuda.LogLevel)"><!-- --></A><H3>
setLogLevel</H3>
<PRE>
public static void <B>setLogLevel</B>(<A HREF="../../jcuda/LogLevel.html" title="enum in jcuda">LogLevel</A>&nbsp;logLevel)</PRE>
<DL>
<DD>Set the specified log level for the JCuda runtime library.<br />
 <br />
 Currently supported log levels:
 <br />
 LOG_QUIET: Never print anything <br />
 LOG_ERROR: Print error messages <br />
 LOG_TRACE: Print a trace of all native function calls <br />
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>logLevel</CODE> - The log level to use.</DL>
</DD>
</DL>
<HR>

<A NAME="setExceptionsEnabled(boolean)"><!-- --></A><H3>
setExceptionsEnabled</H3>
<PRE>
public static void <B>setExceptionsEnabled</B>(boolean&nbsp;enabled)</PRE>
<DL>
<DD>Enables or disables exceptions. By default, the methods of this class
 only return the cudaError error code from the underlying CUDA function.
 If exceptions are enabled, a CudaException with a detailed error
 message will be thrown if a method is about to return a result code
 that is not cudaError.cudaSuccess
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enabled</CODE> - Whether exceptions are enabled</DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetDeviceCount(int[])"><!-- --></A><H3>
cudaGetDeviceCount</H3>
<PRE>
public static int <B>cudaGetDeviceCount</B>(int[]&nbsp;count)</PRE>
<DL>
<DD>Returns the number of compute-capable devices.
 
 <pre>
 cudaError_t cudaGetDeviceCount (
      int* count )
 </pre>
 <div>
   <p>Returns the number of compute-capable
     devices.  Returns in <tt>*count</tt> the number of devices with
     compute capability greater or equal to 1.0 that are available for
     execution. If there is no such
     device then cudaGetDeviceCount() will
     return cudaErrorNoDevice. If no driver can be loaded to determine if
     any such devices exist then cudaGetDeviceCount() will return
     cudaErrorInsufficientDriver.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - Returns the number of devices with compute capability greater or equal to 1.0
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorNoDevice, cudaErrorInsufficientDriver<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDevice(int[])"><CODE>cudaGetDevice(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetDevice(int)"><CODE>cudaSetDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)"><CODE>cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)"><CODE>cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaSetDevice(int)"><!-- --></A><H3>
cudaSetDevice</H3>
<PRE>
public static int <B>cudaSetDevice</B>(int&nbsp;device)</PRE>
<DL>
<DD>Set device to be used for GPU executions.
 
 <pre>
 cudaError_t cudaSetDevice (
      int  device )
 </pre>
 <div>
   <p>Set device to be used for GPU executions.
     Sets <tt>device</tt> as the current device for the calling host
     thread.
   </p>
   <p>Any device memory subsequently allocated
     from this host thread using cudaMalloc(), cudaMallocPitch() or
     cudaMallocArray() will be physically resident on <tt>device</tt>. Any
     host memory allocated from this host thread using cudaMallocHost() or
     cudaHostAlloc() or cudaHostRegister() will have its lifetime associated
     with <tt>device</tt>. Any streams or events created from this host
     thread will be associated with <tt>device</tt>. Any kernels launched
     from this host thread using the &lt;&lt;&lt;&gt;&gt;&gt; operator or
     cudaLaunch() will be executed on <tt>device</tt>.
   </p>
   <p>This call may be made from any host
     thread, to any device, and at any time. This function will do no
     synchronization with
     the previous or new device, and should
     be considered a very low overhead call.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>device</CODE> - Device on which the active host thread should execute the device code.
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevice,
 cudaErrorDeviceAlreadyInUse<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceCount(int[])"><CODE>cudaGetDeviceCount(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDevice(int[])"><CODE>cudaGetDevice(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)"><CODE>cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)"><CODE>cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaSetDeviceFlags(int)"><!-- --></A><H3>
cudaSetDeviceFlags</H3>
<PRE>
public static int <B>cudaSetDeviceFlags</B>(int&nbsp;flags)</PRE>
<DL>
<DD>Sets flags to be used for device executions.
 
 <pre>
 cudaError_t cudaSetDeviceFlags (
      unsigned int  flags )
 </pre>
 <div>
   <p>Sets flags to be used for device
     executions.  Records <tt>flags</tt> as the flags to use when
     initializing the current device. If no device has been made current to
     the calling thread then <tt>flags</tt> will be applied to the
     initialization of any device initialized by the calling host thread,
     unless that device has had its
     initialization flags set explicitly by
     this or any host thread.
   </p>
   <p>If the current device has been set and
     that device has already been initialized then this call will fail with
     the error cudaErrorSetOnActiveProcess. In this case it is necessary to
     reset <tt>device</tt> using cudaDeviceReset() before the device's
     initialization flags may be set.
   </p>
   <p>The two LSBs of the <tt>flags</tt>
     parameter can be used to control how the CPU thread interacts with the
     OS scheduler when waiting for results from the device.
   </p>
   <ul>
     <li>
       <p>cudaDeviceScheduleAuto: The
         default value if the <tt>flags</tt> parameter is zero, uses a heuristic
         based on the number of active CUDA contexts in the process <tt>C</tt>
         and the number of logical processors in the system <tt>P</tt>. If <tt>C</tt> &gt; <tt>P</tt>, then CUDA will yield to other OS threads when
         waiting for the device, otherwise CUDA will not yield while waiting
         for results
         and actively spin on the
         processor.
       </p>
     </li>
     <li>
       <p>cudaDeviceScheduleSpin: Instruct
         CUDA to actively spin when waiting for results from the device. This
         can decrease latency when waiting for the
         device, but may lower the
         performance of CPU threads if they are performing work in parallel with
         the CUDA thread.
       </p>
     </li>
     <li>
       <p>cudaDeviceScheduleYield:
         Instruct CUDA to yield its thread when waiting for results from the
         device. This can increase latency when waiting for the
         device, but can increase the
         performance of CPU threads performing work in parallel with the
         device.
       </p>
     </li>
     <li>
       <p>cudaDeviceScheduleBlockingSync:
         Instruct CUDA to block the CPU thread on a synchronization primitive
         when waiting for the device to finish work.
       </p>
     </li>
     <li>
       <p>cudaDeviceBlockingSync: Instruct
         CUDA to block the CPU thread on a synchronization primitive when
         waiting for the device to finish work. 
       </p>
       <p>Deprecated: This flag was
         deprecated as of CUDA 4.0 and replaced with
         cudaDeviceScheduleBlockingSync.
       </p>
     </li>
     <li>
       <p>cudaDeviceMapHost: This flag
         must be set in order to allocate pinned host memory that is accessible
         to the device. If this flag is not set,
         cudaHostGetDevicePointer() will
         always return a failure code.
       </p>
     </li>
     <li>
       <p>cudaDeviceLmemResizeToMax:
         Instruct CUDA to not reduce local memory after resizing local memory
         for a kernel. This can prevent thrashing by local memory
         allocations when launching many
         kernels with high local memory usage at the cost of potentially
         increased memory usage.
       </p>
     </li>
   </ul>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>flags</CODE> - Parameters for device operation
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevice,
 cudaErrorSetOnActiveProcess<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceCount(int[])"><CODE>cudaGetDeviceCount(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDevice(int[])"><CODE>cudaGetDevice(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)"><CODE>cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetDevice(int)"><CODE>cudaSetDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetValidDevices(int[], int)"><CODE>cudaSetValidDevices(int[], int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)"><CODE>cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaSetValidDevices(int[], int)"><!-- --></A><H3>
cudaSetValidDevices</H3>
<PRE>
public static int <B>cudaSetValidDevices</B>(int[]&nbsp;device_arr,
                                      int&nbsp;len)</PRE>
<DL>
<DD>Set a list of devices that can be used for CUDA.
 
 <pre>
 cudaError_t cudaSetValidDevices (
      int* device_arr,
      int  len )
 </pre>
 <div>
   <p>Set a list of devices that can be used
     for CUDA.  Sets a list of devices for CUDA execution in priority order
     using <tt>device_arr</tt>. The parameter <tt>len</tt> specifies the
     number of elements in the list. CUDA will try devices from the list
     sequentially until it finds one that works.
     If this function is not called, or if it
     is called with a <tt>len</tt> of 0, then CUDA will go back to its
     default behavior of trying devices sequentially from a default list
     containing all of
     the available CUDA devices in the system.
     If a specified device ID in the list does not exist, this function will
     return cudaErrorInvalidDevice. If <tt>len</tt> is not 0 and <tt>device_arr</tt> is NULL or if <tt>len</tt> exceeds the number of
     devices in the system, then cudaErrorInvalidValue is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>device_arr</CODE> - List of devices to try<DD><CODE>len</CODE> - Number of devices in specified list
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevice<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceCount(int[])"><CODE>cudaGetDeviceCount(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetDevice(int)"><CODE>cudaSetDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)"><CODE>cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetDeviceFlags(int)"><CODE>cudaSetDeviceFlags(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)"><CODE>cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetDevice(int[])"><!-- --></A><H3>
cudaGetDevice</H3>
<PRE>
public static int <B>cudaGetDevice</B>(int[]&nbsp;device)</PRE>
<DL>
<DD>Returns which device is currently being used.
 
 <pre>
 cudaError_t cudaGetDevice (
      int* device )
 </pre>
 <div>
   <p>Returns which device is currently being
     used.  Returns in <tt>*device</tt> the current device for the calling
     host thread.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>device</CODE> - Returns the device on which the active host thread executes the device code.
<DT><B>Returns:</B><DD>cudaSuccess<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceCount(int[])"><CODE>cudaGetDeviceCount(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetDevice(int)"><CODE>cudaSetDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)"><CODE>cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)"><CODE>cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)"><!-- --></A><H3>
cudaGetDeviceProperties</H3>
<PRE>
public static int <B>cudaGetDeviceProperties</B>(<A HREF="../../jcuda/runtime/cudaDeviceProp.html" title="class in jcuda.runtime">cudaDeviceProp</A>&nbsp;prop,
                                          int&nbsp;device)</PRE>
<DL>
<DD>Returns information about the compute-device.
 
 <pre>
 cudaError_t cudaGetDeviceProperties (
      cudaDeviceProp* prop,
      int  device )
 </pre>
 <div>
   <p>Returns information about the
     compute-device.  Returns in <tt>*prop</tt> the properties of device
     <tt>dev</tt>. The cudaDeviceProp structure is defined as: 
   <pre>   
 struct cudaDeviceProp {
         char name[256];
         size_t totalGlobalMem;
         size_t sharedMemPerBlock;
         int regsPerBlock;
         int warpSize;
         size_t memPitch;
         int maxThreadsPerBlock;
         int maxThreadsDim[3];
         int maxGridSize[3];
         int clockRate;
         size_t totalConstMem;
         int major;
         int minor;
         size_t textureAlignment;
         size_t texturePitchAlignment;
         int deviceOverlap;
         int multiProcessorCount;
         int kernelExecTimeoutEnabled;
         int integrated;
         int canMapHostMemory;
         int computeMode;
         int maxTexture1D;
         int maxTexture1DMipmap;
         int maxTexture1DLinear;
         int maxTexture2D[2];
         int maxTexture2DMipmap[2];
         int maxTexture2DLinear[3];
         int maxTexture2DGather[2];
         int maxTexture3D[3];
         int maxTextureCubemap;
         int maxTexture1DLayered[2];
         int maxTexture2DLayered[3];
         int maxTextureCubemapLayered[2];
         int maxSurface1D;
         int maxSurface2D[2];
         int maxSurface3D[3];
         int maxSurface1DLayered[2];
         int maxSurface2DLayered[3];
         int maxSurfaceCubemap;
         int maxSurfaceCubemapLayered[2];
         size_t surfaceAlignment;
         int concurrentKernels;
         int ECCEnabled;
         int pciBusID;
         int pciDeviceID;
         int pciDomainID;
         int tccDriver;
         int asyncEngineCount;
         int unifiedAddressing;
         int memoryClockRate;
         int memoryBusWidth;
         int l2CacheSize;
         int maxThreadsPerMultiProcessor;
     }</pre>
   where:
   <ul>
     <li>
       <p>name[256] is an ASCII string
         identifying the device;
       </p>
     </li>
     <li>
       <p>totalGlobalMem is the total
         amount of global memory available on the device in bytes;
       </p>
     </li>
     <li>
       <p>sharedMemPerBlock is the
         maximum amount of shared memory available to a thread block in bytes;
         this amount is shared by all thread blocks simultaneously
         resident on a multiprocessor;
       </p>
     </li>
     <li>
       <p>regsPerBlock is the maximum
         number of 32-bit registers available to a thread block; this number is
         shared by all thread blocks simultaneously
         resident on a multiprocessor;
       </p>
     </li>
     <li>
       <p>warpSize is the warp size in
         threads;
       </p>
     </li>
     <li>
       <p>memPitch is the maximum pitch
         in bytes allowed by the memory copy functions that involve memory
         regions allocated through cudaMallocPitch();
       </p>
     </li>
     <li>
       <p>maxThreadsPerBlock is the
         maximum number of threads per block;
       </p>
     </li>
     <li>
       <p>maxThreadsDim[3] contains the
         maximum size of each dimension of a block;
       </p>
     </li>
     <li>
       <p>maxGridSize[3] contains the
         maximum size of each dimension of a grid;
       </p>
     </li>
     <li>
       <p>clockRate is the clock frequency
         in kilohertz;
       </p>
     </li>
     <li>
       <p>totalConstMem is the total
         amount of constant memory available on the device in bytes;
       </p>
     </li>
     <li>
       <p>major, minor are the major and
         minor revision numbers defining the device's compute capability;
       </p>
     </li>
     <li>
       <p>textureAlignment is the
         alignment requirement; texture base addresses that are aligned to
         textureAlignment bytes do not need an offset applied to texture
         fetches;
       </p>
     </li>
     <li>
       <p>texturePitchAlignment is the
         pitch alignment requirement for 2D texture references that are bound
         to pitched memory;
       </p>
     </li>
     <li>
       <p>deviceOverlap is 1 if the
         device can concurrently copy memory between host and device while
         executing a kernel, or 0 if not. Deprecated,
         use instead asyncEngineCount.
       </p>
     </li>
     <li>
       <p>multiProcessorCount is the
         number of multiprocessors on the device;
       </p>
     </li>
     <li>
       <p>kernelExecTimeoutEnabled is 1
         if there is a run time limit for kernels executed on the device, or 0
         if not.
       </p>
     </li>
     <li>
       <p>integrated is 1 if the device
         is an integrated (motherboard) GPU and 0 if it is a discrete (card)
         component.
       </p>
     </li>
     <li>
       <p>canMapHostMemory is 1 if the
         device can map host memory into the CUDA address space for use with
         cudaHostAlloc()/cudaHostGetDevicePointer(), or 0 if not;
       </p>
     </li>
     <li>
       <div>
         computeMode is the compute
         mode that the device is currently in. Available modes are as follows:
         <ul>
           <li>
             <p>cudaComputeModeDefault:
               Default mode - Device is not restricted and multiple threads can use
               cudaSetDevice() with this device.
             </p>
           </li>
           <li>
             <p>cudaComputeModeExclusive:
               Compute-exclusive mode - Only one thread will be able to use
               cudaSetDevice() with this device.
             </p>
           </li>
           <li>
             <p>cudaComputeModeProhibited:
               Compute-prohibited mode - No threads can use cudaSetDevice() with this
               device.
             </p>
           </li>
           <li>
             <p>cudaComputeModeExclusiveProcess: Compute-exclusive-process mode - Many
               threads in one process will be able to use cudaSetDevice() with this
               device. 
             </p>
             <p>
               If cudaSetDevice() is
               called on an already occupied <tt>device</tt> with computeMode
               cudaComputeModeExclusive, cudaErrorDeviceAlreadyInUse will be
               immediately returned indicating the device cannot be used. When an
               occupied exclusive mode device is chosen with
               cudaSetDevice, all
               subsequent non-device management runtime functions will return
               cudaErrorDevicesUnavailable.
             </p>
           </li>
         </ul>
       </div>
     </li>
     <li>
       <p>maxTexture1D is the maximum 1D
         texture size.
       </p>
     </li>
     <li>
       <p>maxTexture1DMipmap is the
         maximum 1D mipmapped texture texture size.
       </p>
     </li>
     <li>
       <p>maxTexture1DLinear is the
         maximum 1D texture size for textures bound to linear memory.
       </p>
     </li>
     <li>
       <p>maxTexture2D[2] contains the
         maximum 2D texture dimensions.
       </p>
     </li>
     <li>
       <p>maxTexture2DMipmap[2] contains
         the maximum 2D mipmapped texture dimensions.
       </p>
     </li>
     <li>
       <p>maxTexture2DLinear[3] contains
         the maximum 2D texture dimensions for 2D textures bound to pitch linear
         memory.
       </p>
     </li>
     <li>
       <p>maxTexture2DGather[2] contains
         the maximum 2D texture dimensions if texture gather operations have to
         be performed.
       </p>
     </li>
     <li>
       <p>maxTexture3D[3] contains the
         maximum 3D texture dimensions.
       </p>
     </li>
     <li>
       <p>maxTextureCubemap is the
         maximum cubemap texture width or height.
       </p>
     </li>
     <li>
       <p>maxTexture1DLayered[2] contains
         the maximum 1D layered texture dimensions.
       </p>
     </li>
     <li>
       <p>maxTexture2DLayered[3] contains
         the maximum 2D layered texture dimensions.
       </p>
     </li>
     <li>
       <p>maxTextureCubemapLayered[2]
         contains the maximum cubemap layered texture dimensions.
       </p>
     </li>
     <li>
       <p>maxSurface1D is the maximum 1D
         surface size.
       </p>
     </li>
     <li>
       <p>maxSurface2D[2] contains the
         maximum 2D surface dimensions.
       </p>
     </li>
     <li>
       <p>maxSurface3D[3] contains the
         maximum 3D surface dimensions.
       </p>
     </li>
     <li>
       <p>maxSurface1DLayered[2] contains
         the maximum 1D layered surface dimensions.
       </p>
     </li>
     <li>
       <p>maxSurface2DLayered[3] contains
         the maximum 2D layered surface dimensions.
       </p>
     </li>
     <li>
       <p>maxSurfaceCubemap is the
         maximum cubemap surface width or height.
       </p>
     </li>
     <li>
       <p>maxSurfaceCubemapLayered[2]
         contains the maximum cubemap layered surface dimensions.
       </p>
     </li>
     <li>
       <p>surfaceAlignment specifies the
         alignment requirements for surfaces.
       </p>
     </li>
     <li>
       <p>concurrentKernels is 1 if the
         device supports executing multiple kernels within the same context
         simultaneously, or 0 if not. It is not guaranteed
         that multiple kernels will be
         resident on the device concurrently so this feature should not be
         relied upon for correctness;
       </p>
     </li>
     <li>
       <p>ECCEnabled is 1 if the device
         has ECC support turned on, or 0 if not.
       </p>
     </li>
     <li>
       <p>pciBusID is the PCI bus
         identifier of the device.
       </p>
     </li>
     <li>
       <p>pciDeviceID is the PCI device
         (sometimes called slot) identifier of the device.
       </p>
     </li>
     <li>
       <p>pciDomainID is the PCI domain
         identifier of the device.
       </p>
     </li>
     <li>
       <p>tccDriver is 1 if the device
         is using a TCC driver or 0 if not.
       </p>
     </li>
     <li>
       <p>asyncEngineCount is 1 when the
         device can concurrently copy memory between host and device while
         executing a kernel. It is 2 when the device
         can concurrently copy memory
         between host and device in both directions and execute a kernel at the
         same time. It is 0 if
         neither of these is supported.
       </p>
     </li>
     <li>
       <p>unifiedAddressing is 1 if the
         device shares a unified address space with the host and 0 otherwise.
       </p>
     </li>
     <li>
       <p>memoryClockRate is the peak
         memory clock frequency in kilohertz.
       </p>
     </li>
     <li>
       <p>memoryBusWidth is the memory
         bus width in bits.
       </p>
     </li>
     <li>
       <p>l2CacheSize is L2 cache size
         in bytes.
       </p>
     </li>
     <li>
       <p>maxThreadsPerMultiProcessor is
         the number of maximum resident threads per multiprocessor.
       </p>
     </li>
   </ul>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>prop</CODE> - Properties for the specified device<DD><CODE>device</CODE> - Device number to get properties for
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevice<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceCount(int[])"><CODE>cudaGetDeviceCount(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDevice(int[])"><CODE>cudaGetDevice(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetDevice(int)"><CODE>cudaSetDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)"><CODE>cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceGetAttribute(int[], int, int)"><CODE>cudaDeviceGetAttribute(int[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDeviceGetAttribute(int[], int, int)"><!-- --></A><H3>
cudaDeviceGetAttribute</H3>
<PRE>
public static int <B>cudaDeviceGetAttribute</B>(int[]&nbsp;value,
                                         int&nbsp;cudaDeviceAttr_attr,
                                         int&nbsp;device)</PRE>
<DL>
<DD>Returns information about the device.
 
 <pre>
 cudaError_t cudaDeviceGetAttribute (
      int* value,
      cudaDeviceAttr attr,
      int  device )
 </pre>
 <div>
   <p>Returns information about the device. 
     Returns in <tt>*value</tt> the integer value of the attribute <tt>attr</tt> on device <tt>device</tt>. The supported attributes are:
   <ul>
     <li>
       <p>cudaDevAttrMaxThreadsPerBlock:
         Maximum number of threads per block;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxBlockDimX:
         Maximum x-dimension of a block;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxBlockDimY:
         Maximum y-dimension of a block;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxBlockDimZ:
         Maximum z-dimension of a block;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxGridDimX: Maximum
         x-dimension of a grid;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxGridDimY: Maximum
         y-dimension of a grid;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxGridDimZ: Maximum
         z-dimension of a grid;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxSharedMemoryPerBlock:
         Maximum amount of shared memory available to a thread block in bytes;
         this amount is shared by all thread blocks simultaneously
         resident on a multiprocessor;
       </p>
     </li>
     <li>
       <p>cudaDevAttrTotalConstantMemory:
         Memory available on device for __constant__ variables in a CUDA C
         kernel in bytes;
       </p>
     </li>
     <li>
       <p>cudaDevAttrWarpSize: Warp size
         in threads;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxPitch: Maximum
         pitch in bytes allowed by the memory copy functions that involve memory
         regions allocated through cudaMallocPitch();
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture1DWidth:
         Maximum 1D texture width;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture1DLinearWidth:
         Maximum width for a 1D texture bound to linear memory;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture1DMipmappedWidth:
         Maximum mipmapped 1D texture width;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture2DWidth:
         Maximum 2D texture width;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture2DHeight:
         Maximum 2D texture height;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture2DLinearWidth:
         Maximum width for a 2D texture bound to linear memory;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture2DLinearHeight:
         Maximum height for a 2D texture bound to linear memory;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture2DLinearPitch:
         Maximum pitch in bytes for a 2D texture bound to linear memory;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture2DMipmappedWidth:
         Maximum mipmapped 2D texture width;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture2DMipmappedHeight:
         Maximum mipmapped 2D texture height;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture3DWidth:
         Maximum 3D texture width;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture3DHeight:
         Maximum 3D texture height;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture3DDepth:
         Maximum 3D texture depth;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture3DWidthAlt:
         Alternate maximum 3D texture width, 0 if no alternate maximum 3D
         texture size is supported;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture3DHeightAlt:
         Alternate maximum 3D texture height, 0 if no alternate maximum 3D
         texture size is supported;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture3DDepthAlt:
         Alternate maximum 3D texture depth, 0 if no alternate maximum 3D
         texture size is supported;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTextureCubemapWidth:
         Maximum cubemap texture width or height;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture1DLayeredWidth:
         Maximum 1D layered texture width;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture1DLayeredLayers:
         Maximum layers in a 1D layered texture;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture2DLayeredWidth:
         Maximum 2D layered texture width;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture2DLayeredHeight:
         Maximum 2D layered texture height;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTexture2DLayeredLayers:
         Maximum layers in a 2D layered texture;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTextureCubemapLayeredWidth: Maximum cubemap layered
         texture width or height;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxTextureCubemapLayeredLayers: Maximum layers in a cubemap
         layered texture;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxSurface1DWidth:
         Maximum 1D surface width;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxSurface2DWidth:
         Maximum 2D surface width;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxSurface2DHeight:
         Maximum 2D surface height;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxSurface3DWidth:
         Maximum 3D surface width;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxSurface3DHeight:
         Maximum 3D surface height;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxSurface3DDepth:
         Maximum 3D surface depth;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxSurface1DLayeredWidth:
         Maximum 1D layered surface width;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxSurface1DLayeredLayers:
         Maximum layers in a 1D layered surface;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxSurface2DLayeredWidth:
         Maximum 2D layered surface width;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxSurface2DLayeredHeight:
         Maximum 2D layered surface height;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxSurface2DLayeredLayers:
         Maximum layers in a 2D layered surface;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxSurfaceCubemapWidth:
         Maximum cubemap surface width;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxSurfaceCubemapLayeredWidth: Maximum cubemap layered
         surface width;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxSurfaceCubemapLayeredLayers: Maximum layers in a cubemap
         layered surface;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxRegistersPerBlock:
         Maximum number of 32-bit registers available to a thread block; this
         number is shared by all thread blocks simultaneously
         resident on a multiprocessor;
       </p>
     </li>
     <li>
       <p>cudaDevAttrClockRate: Peak
         clock frequency in kilohertz;
       </p>
     </li>
     <li>
       <p>cudaDevAttrTextureAlignment:
         Alignment requirement; texture base addresses aligned to textureAlign
         bytes do not need an offset applied to texture fetches;
       </p>
     </li>
     <li>
       <p>cudaDevAttrTexturePitchAlignment:
         Pitch alignment requirement for 2D texture references bound to pitched
         memory;
       </p>
     </li>
     <li>
       <p>cudaDevAttrGpuOverlap: 1 if
         the device can concurrently copy memory between host and device while
         executing a kernel, or 0 if not;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMultiProcessorCount:
         Number of multiprocessors on the device;
       </p>
     </li>
     <li>
       <p>cudaDevAttrKernelExecTimeout:
         1 if there is a run time limit for kernels executed on the device, or
         0 if not;
       </p>
     </li>
     <li>
       <p>cudaDevAttrIntegrated: 1 if
         the device is integrated with the memory subsystem, or 0 if not;
       </p>
     </li>
     <li>
       <p>cudaDevAttrCanMapHostMemory: 1
         if the device can map host memory into the CUDA address space, or 0 if
         not;
       </p>
     </li>
     <li>
       <div>
         cudaDevAttrComputeMode:
         Compute mode is the compute mode that the device is currently in.
         Available modes are as follows:
         <ul>
           <li>
             <p>cudaComputeModeDefault:
               Default mode - Device is not restricted and multiple threads can use
               cudaSetDevice() with this device.
             </p>
           </li>
           <li>
             <p>cudaComputeModeExclusive:
               Compute-exclusive mode - Only one thread will be able to use
               cudaSetDevice() with this device.
             </p>
           </li>
           <li>
             <p>cudaComputeModeProhibited:
               Compute-prohibited mode - No threads can use cudaSetDevice() with this
               device.
             </p>
           </li>
           <li>
             <p>cudaComputeModeExclusiveProcess: Compute-exclusive-process mode - Many
               threads in one process will be able to use cudaSetDevice() with this
               device.
             </p>
           </li>
         </ul>
       </div>
     </li>
     <li>
       <p>cudaDevAttrConcurrentKernels:
         1 if the device supports executing multiple kernels within the same
         context simultaneously, or 0 if not. It is not guaranteed
         that multiple kernels will be
         resident on the device concurrently so this feature should not be
         relied upon for correctness;
       </p>
     </li>
     <li>
       <p>cudaDevAttrEccEnabled: 1 if
         error correction is enabled on the device, 0 if error correction is
         disabled or not supported by the device;
       </p>
     </li>
     <li>
       <p>cudaDevAttrPciBusId: PCI bus
         identifier of the device;
       </p>
     </li>
     <li>
       <p>cudaDevAttrPciDeviceId: PCI
         device (also known as slot) identifier of the device;
       </p>
     </li>
     <li>
       <p>cudaDevAttrTccDriver: 1 if the
         device is using a TCC driver. TCC is only available on Tesla hardware
         running Windows Vista or later;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMemoryClockRate:
         Peak memory clock frequency in kilohertz;
       </p>
     </li>
     <li>
       <p>cudaDevAttrGlobalMemoryBusWidth:
         Global memory bus width in bits;
       </p>
     </li>
     <li>
       <p>cudaDevAttrL2CacheSize: Size
         of L2 cache in bytes. 0 if the device doesn't have L2 cache;
       </p>
     </li>
     <li>
       <p>cudaDevAttrMaxThreadsPerMultiProcessor:
         Maximum resident threads per multiprocessor;
       </p>
     </li>
     <li>
       <p>cudaDevAttrUnifiedAddressing:
         1 if the device shares a unified address space with the host, or 0 if
         not;
       </p>
     </li>
     <li>
       <p>cudaDevAttrComputeCapabilityMajor:
         Major compute capability version number;
       </p>
     </li>
     <li>
       <p>cudaDevAttrComputeCapabilityMinor:
         Minor compute capability version number;
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - Returned device attribute value<DD><CODE>attr</CODE> - Device attribute to query<DD><CODE>device</CODE> - Device number to query
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevice, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceCount(int[])"><CODE>cudaGetDeviceCount(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDevice(int[])"><CODE>cudaGetDevice(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetDevice(int)"><CODE>cudaSetDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)"><CODE>cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)"><CODE>cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)"><!-- --></A><H3>
cudaChooseDevice</H3>
<PRE>
public static int <B>cudaChooseDevice</B>(int[]&nbsp;device,
                                   <A HREF="../../jcuda/runtime/cudaDeviceProp.html" title="class in jcuda.runtime">cudaDeviceProp</A>&nbsp;prop)</PRE>
<DL>
<DD>Select compute-device which best matches criteria.
 
 <pre>
 cudaError_t cudaChooseDevice (
      int* device,
      const cudaDeviceProp* prop )
 </pre>
 <div>
   <p>Select compute-device which best matches
     criteria.  Returns in <tt>*device</tt> the device which has properties
     that best match <tt>*prop</tt>.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>device</CODE> - Device with best match<DD><CODE>prop</CODE> - Desired device properties
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceCount(int[])"><CODE>cudaGetDeviceCount(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDevice(int[])"><CODE>cudaGetDevice(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetDevice(int)"><CODE>cudaSetDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)"><CODE>cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><!-- --></A><H3>
cudaMalloc3D</H3>
<PRE>
public static int <B>cudaMalloc3D</B>(<A HREF="../../jcuda/runtime/cudaPitchedPtr.html" title="class in jcuda.runtime">cudaPitchedPtr</A>&nbsp;pitchDevPtr,
                               <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent)</PRE>
<DL>
<DD>Allocates logical 1D, 2D, or 3D memory objects on the device.
 
 <pre>
 cudaError_t cudaMalloc3D (
      cudaPitchedPtr* pitchedDevPtr,
      cudaExtent extent )
 </pre>
 <div>
   <p>Allocates logical 1D, 2D, or 3D memory
     objects on the device.  Allocates at least <tt>width</tt> * <tt>height</tt> * <tt>depth</tt> bytes of linear memory on the device
     and returns a cudaPitchedPtr in which <tt>ptr</tt> is a pointer to
     the allocated memory. The function may pad the allocation to ensure
     hardware alignment requirements are met.
     The pitch returned in the <tt>pitch</tt>
     field of <tt>pitchedDevPtr</tt> is the width in bytes of the
     allocation.
   </p>
   <p>The returned cudaPitchedPtr contains
     additional fields <tt>xsize</tt> and <tt>ysize</tt>, the logical
     width and height of the allocation, which are equivalent to the <tt>width</tt> and <tt>height</tt><tt>extent</tt> parameters provided
     by the programmer during allocation.
   </p>
   <p>For allocations of 2D and 3D objects,
     it is highly recommended that programmers perform allocations using
     cudaMalloc3D() or cudaMallocPitch(). Due to alignment restrictions in
     the hardware, this is especially true if the application will be
     performing memory copies
     involving 2D or 3D objects (whether
     linear memory or CUDA arrays).
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pitchedDevPtr</CODE> - Pointer to allocated pitched device memory<DD><CODE>extent</CODE> - Requested allocation size (width field in bytes)
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMemoryAllocation<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy3D(jcuda.runtime.cudaMemcpy3DParms)"><CODE>cudaMemcpy3D(jcuda.runtime.cudaMemcpy3DParms)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)"><CODE>cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)"><CODE>cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaHostAlloc(jcuda.Pointer, long, int)"><CODE>cudaHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/cudaPitchedPtr.html" title="class in jcuda.runtime"><CODE>cudaPitchedPtr</CODE></A>, 
<A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime"><CODE>cudaExtent</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)"><!-- --></A><H3>
cudaMalloc3DArray</H3>
<PRE>
public static int <B>cudaMalloc3DArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;arrayPtr,
                                    <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                                    <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent)</PRE>
<DL>
<DD>Allocate an array on the device.
 
 <pre>
 cudaError_t cudaMalloc3DArray (
      cudaArray_t* array,
      const cudaChannelFormatDesc* desc,
      cudaExtent extent,
      unsigned int  flags = 0 )
 </pre>
 <div>
   <p>Allocate an array on the device. 
     Allocates a CUDA array according to the cudaChannelFormatDesc structure
     <tt>desc</tt> and returns a handle to the new CUDA array in <tt>*array</tt>.
   </p>
   <p>The cudaChannelFormatDesc is defined
     as: 
   <pre>    struct cudaChannelFormatDesc {
         int x, y, z, w;
         enum cudaChannelFormatKind 
                   f;
     };</pre>
   where cudaChannelFormatKind is one of
   cudaChannelFormatKindSigned, cudaChannelFormatKindUnsigned, or
   cudaChannelFormatKindFloat.
   </p>
   <p>cudaMalloc3DArray() can allocate the
     following:
   </p>
   <ul>
     <li>
       <p>A 1D array is allocated if the
         height and depth extents are both zero.
       </p>
     </li>
     <li>
       <p>A 2D array is allocated if only
         the depth extent is zero.
       </p>
     </li>
     <li>
       <p>A 3D array is allocated if all
         three extents are non-zero.
       </p>
     </li>
     <li>
       <p>A 1D layered CUDA array is
         allocated if only the height extent is zero and the cudaArrayLayered
         flag is set. Each layer is
         a 1D array. The number of layers
         is determined by the depth extent.
       </p>
     </li>
     <li>
       <p>A 2D layered CUDA array is
         allocated if all three extents are non-zero and the cudaArrayLayered
         flag is set. Each layer is
         a 2D array. The number of layers
         is determined by the depth extent.
       </p>
     </li>
     <li>
       <p>A cubemap CUDA array is
         allocated if all three extents are non-zero and the cudaArrayCubemap
         flag is set. Width must be equal
         to height, and depth must be
         six. A cubemap is a special type of 2D layered CUDA array, where the
         six layers represent the
         six faces of a cube. The order
         of the six layers in memory is the same as that listed in
         cudaGraphicsCubeFace.
       </p>
     </li>
     <li>
       <p>A cubemap layered CUDA array
         is allocated if all three extents are non-zero, and both, cudaArrayCubemap
         and cudaArrayLayered
         flags are set. Width must be
         equal to height, and depth must be a multiple of six. A cubemap layered
         CUDA array is a special
         type of 2D layered CUDA array
         that consists of a collection of cubemaps. The first six layers
         represent the first cubemap,
         the next six layers form the
         second cubemap, and so on.
       </p>
     </li>
   </ul>
   </p>
   <p>The <tt>flags</tt> parameter enables
     different options to be specified that affect the allocation, as
     follows.
   <ul>
     <li>
       <p>cudaArrayDefault: This flag's
         value is defined to be 0 and provides default array allocation
       </p>
     </li>
     <li>
       <p>cudaArrayLayered: Allocates a
         layered CUDA array, with the depth extent indicating the number of
         layers
       </p>
     </li>
     <li>
       <p>cudaArrayCubemap: Allocates a
         cubemap CUDA array. Width must be equal to height, and depth must be
         six. If the cudaArrayLayered flag is also
         set, depth must be a multiple
         of six.
       </p>
     </li>
     <li>
       <p>cudaArraySurfaceLoadStore:
         Allocates a CUDA array that could be read from or written to using a
         surface reference.
       </p>
     </li>
     <li>
       <p>cudaArrayTextureGather: This
         flag indicates that texture gather operations will be performed on the
         CUDA array. Texture gather can only be performed
         on 2D CUDA arrays.
       </p>
     </li>
   </ul>
   </p>
   <p>The width, height and depth extents must
     meet certain size requirements as listed in the following table. All
     values are specified
     in elements.
   </p>
   <p>Note that 2D CUDA arrays have different
     size requirements if the cudaArrayTextureGather flag is set. In that
     case, the valid range for (width, height, depth) is
     ((1,maxTexture2DGather[0]), (1,maxTexture2DGather[1]),
     0).
   </p>
   <div>
     <table cellpadding="4" cellspacing="0" summary="" frame="border" border="1" rules="all">
       <tbody>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p><strong>CUDA array
               type</strong>
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p><strong>Valid extents
               that must always be met
               {(width range in
               elements), (height range), (depth range)}</strong>
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p><strong>Valid extents
               with cudaArraySurfaceLoadStore set
               {(width range in
               elements), (height range), (depth range)}</strong>
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>1D </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxTexture1D),
               0, 0 } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxSurface1D),
               0, 0 } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>2D </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxTexture2D[0]),
               (1,maxTexture2D[1]), 0 } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxSurface2D[0]),
               (1,maxSurface2D[1]), 0 } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>3D </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxTexture3D[0]),
               (1,maxTexture3D[1]), (1,maxTexture3D[2]) } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxSurface3D[0]),
               (1,maxSurface3D[1]), (1,maxSurface3D[2]) } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>1D Layered </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,maxTexture1DLayered[0]), 0, (1,maxTexture1DLayered[1]) } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,maxSurface1DLayered[0]), 0, (1,maxSurface1DLayered[1]) } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>2D Layered </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,maxTexture2DLayered[0]), (1,maxTexture2DLayered[1]),
               (1,maxTexture2DLayered[2]) } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,maxSurface2DLayered[0]), (1,maxSurface2DLayered[1]),
               (1,maxSurface2DLayered[2]) } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>Cubemap </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxTextureCubemap),
               (1,maxTextureCubemap), 6 } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxSurfaceCubemap),
               (1,maxSurfaceCubemap), 6 } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>Cubemap Layered </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,maxTextureCubemapLayered[0]), (1,maxTextureCubemapLayered[0]),
               (1,maxTextureCubemapLayered[1]) } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,maxSurfaceCubemapLayered[0]), (1,maxSurfaceCubemapLayered[0]),
               (1,maxSurfaceCubemapLayered[1]) } 
             </p>
           </td>
         </tr>
       </tbody>
     </table>
   </div>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Pointer to allocated array in device memory<DD><CODE>desc</CODE> - Requested channel format<DD><CODE>extent</CODE> - Requested allocation size (width field in elements)<DD><CODE>flags</CODE> - Flags for extensions
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMemoryAllocation<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaHostAlloc(jcuda.Pointer, long, int)"><CODE>cudaHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime"><CODE>cudaExtent</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent, int)"><!-- --></A><H3>
cudaMalloc3DArray</H3>
<PRE>
public static int <B>cudaMalloc3DArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;arrayPtr,
                                    <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                                    <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent,
                                    int&nbsp;flags)</PRE>
<DL>
<DD>Allocate an array on the device.
 
 <pre>
 cudaError_t cudaMalloc3DArray (
      cudaArray_t* array,
      const cudaChannelFormatDesc* desc,
      cudaExtent extent,
      unsigned int  flags = 0 )
 </pre>
 <div>
   <p>Allocate an array on the device. 
     Allocates a CUDA array according to the cudaChannelFormatDesc structure
     <tt>desc</tt> and returns a handle to the new CUDA array in <tt>*array</tt>.
   </p>
   <p>The cudaChannelFormatDesc is defined
     as: 
   <pre>    struct cudaChannelFormatDesc {
         int x, y, z, w;
         enum cudaChannelFormatKind 
                   f;
     };</pre>
   where cudaChannelFormatKind is one of
   cudaChannelFormatKindSigned, cudaChannelFormatKindUnsigned, or
   cudaChannelFormatKindFloat.
   </p>
   <p>cudaMalloc3DArray() can allocate the
     following:
   </p>
   <ul>
     <li>
       <p>A 1D array is allocated if the
         height and depth extents are both zero.
       </p>
     </li>
     <li>
       <p>A 2D array is allocated if only
         the depth extent is zero.
       </p>
     </li>
     <li>
       <p>A 3D array is allocated if all
         three extents are non-zero.
       </p>
     </li>
     <li>
       <p>A 1D layered CUDA array is
         allocated if only the height extent is zero and the cudaArrayLayered
         flag is set. Each layer is
         a 1D array. The number of layers
         is determined by the depth extent.
       </p>
     </li>
     <li>
       <p>A 2D layered CUDA array is
         allocated if all three extents are non-zero and the cudaArrayLayered
         flag is set. Each layer is
         a 2D array. The number of layers
         is determined by the depth extent.
       </p>
     </li>
     <li>
       <p>A cubemap CUDA array is
         allocated if all three extents are non-zero and the cudaArrayCubemap
         flag is set. Width must be equal
         to height, and depth must be
         six. A cubemap is a special type of 2D layered CUDA array, where the
         six layers represent the
         six faces of a cube. The order
         of the six layers in memory is the same as that listed in
         cudaGraphicsCubeFace.
       </p>
     </li>
     <li>
       <p>A cubemap layered CUDA array
         is allocated if all three extents are non-zero, and both, cudaArrayCubemap
         and cudaArrayLayered
         flags are set. Width must be
         equal to height, and depth must be a multiple of six. A cubemap layered
         CUDA array is a special
         type of 2D layered CUDA array
         that consists of a collection of cubemaps. The first six layers
         represent the first cubemap,
         the next six layers form the
         second cubemap, and so on.
       </p>
     </li>
   </ul>
   </p>
   <p>The <tt>flags</tt> parameter enables
     different options to be specified that affect the allocation, as
     follows.
   <ul>
     <li>
       <p>cudaArrayDefault: This flag's
         value is defined to be 0 and provides default array allocation
       </p>
     </li>
     <li>
       <p>cudaArrayLayered: Allocates a
         layered CUDA array, with the depth extent indicating the number of
         layers
       </p>
     </li>
     <li>
       <p>cudaArrayCubemap: Allocates a
         cubemap CUDA array. Width must be equal to height, and depth must be
         six. If the cudaArrayLayered flag is also
         set, depth must be a multiple
         of six.
       </p>
     </li>
     <li>
       <p>cudaArraySurfaceLoadStore:
         Allocates a CUDA array that could be read from or written to using a
         surface reference.
       </p>
     </li>
     <li>
       <p>cudaArrayTextureGather: This
         flag indicates that texture gather operations will be performed on the
         CUDA array. Texture gather can only be performed
         on 2D CUDA arrays.
       </p>
     </li>
   </ul>
   </p>
   <p>The width, height and depth extents must
     meet certain size requirements as listed in the following table. All
     values are specified
     in elements.
   </p>
   <p>Note that 2D CUDA arrays have different
     size requirements if the cudaArrayTextureGather flag is set. In that
     case, the valid range for (width, height, depth) is
     ((1,maxTexture2DGather[0]), (1,maxTexture2DGather[1]),
     0).
   </p>
   <div>
     <table cellpadding="4" cellspacing="0" summary="" frame="border" border="1" rules="all">
       <tbody>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p><strong>CUDA array
               type</strong>
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p><strong>Valid extents
               that must always be met
               {(width range in
               elements), (height range), (depth range)}</strong>
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p><strong>Valid extents
               with cudaArraySurfaceLoadStore set
               {(width range in
               elements), (height range), (depth range)}</strong>
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>1D </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxTexture1D),
               0, 0 } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxSurface1D),
               0, 0 } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>2D </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxTexture2D[0]),
               (1,maxTexture2D[1]), 0 } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxSurface2D[0]),
               (1,maxSurface2D[1]), 0 } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>3D </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxTexture3D[0]),
               (1,maxTexture3D[1]), (1,maxTexture3D[2]) } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxSurface3D[0]),
               (1,maxSurface3D[1]), (1,maxSurface3D[2]) } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>1D Layered </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,maxTexture1DLayered[0]), 0, (1,maxTexture1DLayered[1]) } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,maxSurface1DLayered[0]), 0, (1,maxSurface1DLayered[1]) } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>2D Layered </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,maxTexture2DLayered[0]), (1,maxTexture2DLayered[1]),
               (1,maxTexture2DLayered[2]) } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,maxSurface2DLayered[0]), (1,maxSurface2DLayered[1]),
               (1,maxSurface2DLayered[2]) } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>Cubemap </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxTextureCubemap),
               (1,maxTextureCubemap), 6 } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxSurfaceCubemap),
               (1,maxSurfaceCubemap), 6 } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>Cubemap Layered </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,maxTextureCubemapLayered[0]), (1,maxTextureCubemapLayered[0]),
               (1,maxTextureCubemapLayered[1]) } 
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,maxSurfaceCubemapLayered[0]), (1,maxSurfaceCubemapLayered[0]),
               (1,maxSurfaceCubemapLayered[1]) } 
             </p>
           </td>
         </tr>
       </tbody>
     </table>
   </div>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Pointer to allocated array in device memory<DD><CODE>desc</CODE> - Requested channel format<DD><CODE>extent</CODE> - Requested allocation size (width field in elements)<DD><CODE>flags</CODE> - Flags for extensions
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMemoryAllocation<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaHostAlloc(jcuda.Pointer, long, int)"><CODE>cudaHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime"><CODE>cudaExtent</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMallocMipmappedArray(jcuda.runtime.cudaMipmappedArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent, int, int)"><!-- --></A><H3>
cudaMallocMipmappedArray</H3>
<PRE>
public static int <B>cudaMallocMipmappedArray</B>(<A HREF="../../jcuda/runtime/cudaMipmappedArray.html" title="class in jcuda.runtime">cudaMipmappedArray</A>&nbsp;mipmappedArray,
                                           <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                                           <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent,
                                           int&nbsp;numLevels,
                                           int&nbsp;flags)</PRE>
<DL>
<DD>Allocate a mipmapped array on the device.
 
 <pre>
 cudaError_t cudaMallocMipmappedArray (
      cudaMipmappedArray_t* mipmappedArray,
      const cudaChannelFormatDesc* desc,
      cudaExtent extent,
      unsigned int  numLevels,
      unsigned int  flags = 0 )
 </pre>
 <div>
   <p>Allocate a mipmapped array on the device.
     Allocates a CUDA mipmapped array according to the cudaChannelFormatDesc
     structure <tt>desc</tt> and returns a handle to the new CUDA mipmapped
     array in <tt>*mipmappedArray</tt>. <tt>numLevels</tt> specifies the
     number of mipmap levels to be allocated. This value is clamped to the
     range [1, 1 + floor(log2(max(width, height,
     depth)))].
   </p>
   <p>The cudaChannelFormatDesc is defined
     as: 
   <pre>    struct cudaChannelFormatDesc {
         int x, y, z, w;
         enum cudaChannelFormatKind 
                   f;
     };</pre>
   where cudaChannelFormatKind is one of
   cudaChannelFormatKindSigned, cudaChannelFormatKindUnsigned, or
   cudaChannelFormatKindFloat.
   </p>
   <p>cudaMallocMipmappedArray() can allocate
     the following:
   </p>
   <ul>
     <li>
       <p>A 1D mipmapped array is
         allocated if the height and depth extents are both zero.
       </p>
     </li>
     <li>
       <p>A 2D mipmapped array is
         allocated if only the depth extent is zero.
       </p>
     </li>
     <li>
       <p>A 3D mipmapped array is
         allocated if all three extents are non-zero.
       </p>
     </li>
     <li>
       <p>A 1D layered CUDA mipmapped
         array is allocated if only the height extent is zero and the
         cudaArrayLayered flag is set. Each
         layer is a 1D mipmapped array.
         The number of layers is determined by the depth extent.
       </p>
     </li>
     <li>
       <p>A 2D layered CUDA mipmapped
         array is allocated if all three extents are non-zero and the
         cudaArrayLayered flag is set. Each
         layer is a 2D mipmapped array.
         The number of layers is determined by the depth extent.
       </p>
     </li>
     <li>
       <p>A cubemap CUDA mipmapped array
         is allocated if all three extents are non-zero and the cudaArrayCubemap
         flag is set. Width
         must be equal to height, and
         depth must be six. The order of the six layers in memory is the same
         as that listed in cudaGraphicsCubeFace.
       </p>
     </li>
     <li>
       <p>A cubemap layered CUDA mipmapped
         array is allocated if all three extents are non-zero, and both,
         cudaArrayCubemap and cudaArrayLayered
         flags are set. Width must be
         equal to height, and depth must be a multiple of six. A cubemap layered
         CUDA mipmapped array
         is a special type of 2D layered
         CUDA mipmapped array that consists of a collection of cubemap mipmapped
         arrays. The first
         six layers represent the first
         cubemap mipmapped array, the next six layers form the second cubemap
         mipmapped array, and so
         on.
       </p>
     </li>
   </ul>
   </p>
   <p>The <tt>flags</tt> parameter enables
     different options to be specified that affect the allocation, as
     follows.
   <ul>
     <li>
       <p>cudaArrayDefault: This flag's
         value is defined to be 0 and provides default mipmapped array
         allocation
       </p>
     </li>
     <li>
       <p>cudaArrayLayered: Allocates a
         layered CUDA mipmapped array, with the depth extent indicating the
         number of layers
       </p>
     </li>
     <li>
       <p>cudaArrayCubemap: Allocates a
         cubemap CUDA mipmapped array. Width must be equal to height, and depth
         must be six. If the cudaArrayLayered
         flag is also set, depth must be
         a multiple of six.
       </p>
     </li>
     <li>
       <p>cudaArraySurfaceLoadStore: This
         flag indicates that individual mipmap levels of the CUDA mipmapped
         array will be read from or written to using a surface
         reference.
       </p>
     </li>
     <li>
       <p>cudaArrayTextureGather: This
         flag indicates that texture gather operations will be performed on the
         CUDA array. Texture gather can only be performed
         on 2D CUDA mipmapped arrays,
         and the gather operations are performed only on the most detailed
         mipmap level.
       </p>
     </li>
   </ul>
   </p>
   <p>The width, height and depth extents must
     meet certain size requirements as listed in the following table. All
     values are specified
     in elements.
   </p>
   <div>
     <table cellpadding="4" cellspacing="0" summary="" frame="border" border="1" rules="all">
       <tbody>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p><strong>CUDA array
               type</strong>
             </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p><strong>Valid
               extents
               {(width range in
               elements), (height range), (depth range)}</strong>
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>1D </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxTexture1DMipmap),
               0, 0 } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>2D </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,maxTexture2DMipmap[0]), (1,maxTexture2DMipmap[1]), 0 } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>3D </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxTexture3D[0]),
               (1,maxTexture3D[1]), (1,maxTexture3D[2]) } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>1D Layered </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,maxTexture1DLayered[0]), 0, (1,maxTexture1DLayered[1]) } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>2D Layered </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,maxTexture2DLayered[0]), (1,maxTexture2DLayered[1]),
               (1,maxTexture2DLayered[2]) } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>Cubemap </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{ (1,maxTextureCubemap),
               (1,maxTextureCubemap), 6 } 
             </p>
           </td>
         </tr>
         <tr>
           <td valign="top" rowspan="1" colspan="1">
             <p>Cubemap Layered </p>
           </td>
           <td valign="top" rowspan="1" colspan="1">
             <p>{
               (1,maxTextureCubemapLayered[0]), (1,maxTextureCubemapLayered[0]),
               (1,maxTextureCubemapLayered[1]) } 
             </p>
           </td>
         </tr>
       </tbody>
     </table>
   </div>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mipmappedArray</CODE> - Pointer to allocated mipmapped array in device memory<DD><CODE>desc</CODE> - Requested channel format<DD><CODE>extent</CODE> - Requested allocation size (width field in elements)<DD><CODE>numLevels</CODE> - Number of mipmap levels to allocate<DD><CODE>flags</CODE> - Flags for extensions
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMemoryAllocation<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaHostAlloc(jcuda.Pointer, long, int)"><CODE>cudaHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime"><CODE>cudaExtent</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetMipmappedArrayLevel(jcuda.runtime.cudaArray, jcuda.runtime.cudaMipmappedArray, int)"><!-- --></A><H3>
cudaGetMipmappedArrayLevel</H3>
<PRE>
public static int <B>cudaGetMipmappedArrayLevel</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;levelArray,
                                             <A HREF="../../jcuda/runtime/cudaMipmappedArray.html" title="class in jcuda.runtime">cudaMipmappedArray</A>&nbsp;mipmappedArray,
                                             int&nbsp;level)</PRE>
<DL>
<DD>Gets a mipmap level of a CUDA mipmapped array.
 
 <pre>
 cudaError_t cudaGetMipmappedArrayLevel (
      cudaArray_t* levelArray,
      cudaMipmappedArray_const_t mipmappedArray,
      unsigned int  level )
 </pre>
 <div>
   <p>Gets a mipmap level of a CUDA mipmapped
     array.  Returns in <tt>*levelArray</tt> a CUDA array that represents
     a single mipmap level of the CUDA mipmapped array <tt>mipmappedArray</tt>.
   </p>
   <p>If <tt>level</tt> is greater than the
     maximum number of levels in this mipmapped array, cudaErrorInvalidValue
     is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>levelArray</CODE> - Returned mipmap level CUDA array<DD><CODE>mipmappedArray</CODE> - CUDA mipmapped array<DD><CODE>level</CODE> - Mipmap level
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaHostAlloc(jcuda.Pointer, long, int)"><CODE>cudaHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime"><CODE>cudaExtent</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)"><!-- --></A><H3>
cudaMemset3D</H3>
<PRE>
public static int <B>cudaMemset3D</B>(<A HREF="../../jcuda/runtime/cudaPitchedPtr.html" title="class in jcuda.runtime">cudaPitchedPtr</A>&nbsp;pitchDevPtr,
                               int&nbsp;value,
                               <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent)</PRE>
<DL>
<DD>Initializes or sets device memory to a value.
 
 <pre>
 cudaError_t cudaMemset3D (
      cudaPitchedPtr pitchedDevPtr,
      int  value,
      cudaExtent extent )
 </pre>
 <div>
   <p>Initializes or sets device memory to a
     value.  Initializes each element of a 3D array to the specified value
     <tt>value</tt>. The object to initialize is defined by <tt>pitchedDevPtr</tt>. The <tt>pitch</tt> field of <tt>pitchedDevPtr</tt>
     is the width in memory in bytes of the 3D array pointed to by <tt>pitchedDevPtr</tt>, including any padding added to the end of each
     row. The <tt>xsize</tt> field specifies the logical width of each row
     in bytes, while the <tt>ysize</tt> field specifies the height of each
     2D slice in rows.
   </p>
   <p>The extents of the initialized region
     are specified as a <tt>width</tt> in bytes, a <tt>height</tt> in
     rows, and a <tt>depth</tt> in slices.
   </p>
   <p>Extents with <tt>width</tt> greater
     than or equal to the <tt>xsize</tt> of <tt>pitchedDevPtr</tt> may
     perform significantly faster than extents narrower than the <tt>xsize</tt>. Secondarily, extents with <tt>height</tt> equal to the
     <tt>ysize</tt> of <tt>pitchedDevPtr</tt> will perform faster than
     when the <tt>height</tt> is shorter than the <tt>ysize</tt>.
   </p>
   <p>This function performs fastest when the
     <tt>pitchedDevPtr</tt> has been allocated by cudaMalloc3D().
   </p>
   <p>Note that this function is asynchronous
     with respect to the host unless <tt>pitchedDevPtr</tt> refers to
     pinned host memory.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pitchedDevPtr</CODE> - Pointer to pitched device memory<DD><CODE>value</CODE> - Value to set for each byte of specified memory<DD><CODE>extent</CODE> - Size parameters for where to set device memory (width field in bytes)
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue,
 cudaErrorInvalidDevicePointer<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemset(jcuda.Pointer, int, long)"><CODE>cudaMemset(jcuda.Pointer, int, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset2D(jcuda.Pointer, long, int, long, long)"><CODE>cudaMemset2D(jcuda.Pointer, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemsetAsync(jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)"><CODE>cudaMemsetAsync(jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset2DAsync(jcuda.Pointer, long, int, long, long, jcuda.runtime.cudaStream_t)"><CODE>cudaMemset2DAsync(jcuda.Pointer, long, int, long, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3DAsync(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent, jcuda.runtime.cudaStream_t)"><CODE>cudaMemset3DAsync(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/cudaPitchedPtr.html" title="class in jcuda.runtime"><CODE>cudaPitchedPtr</CODE></A>, 
<A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime"><CODE>cudaExtent</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemsetAsync(jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemsetAsync</H3>
<PRE>
public static int <B>cudaMemsetAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                  int&nbsp;value,
                                  long&nbsp;count,
                                  <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Initializes or sets device memory to a value.
 
 <pre>
 cudaError_t cudaMemsetAsync (
      void* devPtr,
      int  value,
      size_t count,
      cudaStream_t stream = 0 )
 </pre>
 <div>
   <p>Initializes or sets device memory to a
     value.  Fills the first <tt>count</tt> bytes of the memory area
     pointed to by <tt>devPtr</tt> with the constant byte value <tt>value</tt>.
   </p>
   <p>cudaMemsetAsync() is asynchronous with
     respect to the host, so the call may return before the memset is
     complete. The operation can optionally
     be associated to a stream by passing a
     non-zero <tt>stream</tt> argument. If <tt>stream</tt> is non-zero,
     the operation may overlap with operations in other streams.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>devPtr</CODE> - Pointer to device memory<DD><CODE>value</CODE> - Value to set for each byte of specified memory<DD><CODE>count</CODE> - Size in bytes to set<DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue,
 cudaErrorInvalidDevicePointer<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemset(jcuda.Pointer, int, long)"><CODE>cudaMemset(jcuda.Pointer, int, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset2D(jcuda.Pointer, long, int, long, long)"><CODE>cudaMemset2D(jcuda.Pointer, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)"><CODE>cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset2DAsync(jcuda.Pointer, long, int, long, long, jcuda.runtime.cudaStream_t)"><CODE>cudaMemset2DAsync(jcuda.Pointer, long, int, long, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3DAsync(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent, jcuda.runtime.cudaStream_t)"><CODE>cudaMemset3DAsync(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemset2DAsync(jcuda.Pointer, long, int, long, long, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemset2DAsync</H3>
<PRE>
public static int <B>cudaMemset2DAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                    long&nbsp;pitch,
                                    int&nbsp;value,
                                    long&nbsp;width,
                                    long&nbsp;height,
                                    <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Initializes or sets device memory to a value.
 
 <pre>
 cudaError_t cudaMemset2DAsync (
      void* devPtr,
      size_t pitch,
      int  value,
      size_t width,
      size_t height,
      cudaStream_t stream = 0 )
 </pre>
 <div>
   <p>Initializes or sets device memory to a
     value.  Sets to the specified value <tt>value</tt> a matrix (<tt>height</tt> rows of <tt>width</tt> bytes each) pointed to by <tt>dstPtr</tt>. <tt>pitch</tt> is the width in bytes of the 2D array
     pointed to by <tt>dstPtr</tt>, including any padding added to the end
     of each row. This function performs fastest when the pitch is one that
     has been passed
     back by cudaMallocPitch().
   </p>
   <p>cudaMemset2DAsync() is asynchronous with
     respect to the host, so the call may return before the memset is
     complete. The operation can optionally
     be associated to a stream by passing a
     non-zero <tt>stream</tt> argument. If <tt>stream</tt> is non-zero,
     the operation may overlap with operations in other streams.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>devPtr</CODE> - Pointer to 2D device memory<DD><CODE>pitch</CODE> - Pitch in bytes of 2D device memory<DD><CODE>value</CODE> - Value to set for each byte of specified memory<DD><CODE>width</CODE> - Width of matrix set (columns in bytes)<DD><CODE>height</CODE> - Height of matrix set (rows)<DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue,
 cudaErrorInvalidDevicePointer<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemset(jcuda.Pointer, int, long)"><CODE>cudaMemset(jcuda.Pointer, int, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset2D(jcuda.Pointer, long, int, long, long)"><CODE>cudaMemset2D(jcuda.Pointer, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)"><CODE>cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemsetAsync(jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)"><CODE>cudaMemsetAsync(jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3DAsync(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent, jcuda.runtime.cudaStream_t)"><CODE>cudaMemset3DAsync(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemset3DAsync(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemset3DAsync</H3>
<PRE>
public static int <B>cudaMemset3DAsync</B>(<A HREF="../../jcuda/runtime/cudaPitchedPtr.html" title="class in jcuda.runtime">cudaPitchedPtr</A>&nbsp;pitchedDevPtr,
                                    int&nbsp;value,
                                    <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent,
                                    <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Initializes or sets device memory to a value.
 
 <pre>
 cudaError_t cudaMemset3DAsync (
      cudaPitchedPtr pitchedDevPtr,
      int  value,
      cudaExtent extent,
      cudaStream_t stream = 0 )
 </pre>
 <div>
   <p>Initializes or sets device memory to a
     value.  Initializes each element of a 3D array to the specified value
     <tt>value</tt>. The object to initialize is defined by <tt>pitchedDevPtr</tt>. The <tt>pitch</tt> field of <tt>pitchedDevPtr</tt>
     is the width in memory in bytes of the 3D array pointed to by <tt>pitchedDevPtr</tt>, including any padding added to the end of each
     row. The <tt>xsize</tt> field specifies the logical width of each row
     in bytes, while the <tt>ysize</tt> field specifies the height of each
     2D slice in rows.
   </p>
   <p>The extents of the initialized region
     are specified as a <tt>width</tt> in bytes, a <tt>height</tt> in
     rows, and a <tt>depth</tt> in slices.
   </p>
   <p>Extents with <tt>width</tt> greater
     than or equal to the <tt>xsize</tt> of <tt>pitchedDevPtr</tt> may
     perform significantly faster than extents narrower than the <tt>xsize</tt>. Secondarily, extents with <tt>height</tt> equal to the
     <tt>ysize</tt> of <tt>pitchedDevPtr</tt> will perform faster than
     when the <tt>height</tt> is shorter than the <tt>ysize</tt>.
   </p>
   <p>This function performs fastest when the
     <tt>pitchedDevPtr</tt> has been allocated by cudaMalloc3D().
   </p>
   <p>cudaMemset3DAsync() is asynchronous with
     respect to the host, so the call may return before the memset is
     complete. The operation can optionally
     be associated to a stream by passing a
     non-zero <tt>stream</tt> argument. If <tt>stream</tt> is non-zero,
     the operation may overlap with operations in other streams.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pitchedDevPtr</CODE> - Pointer to pitched device memory<DD><CODE>value</CODE> - Value to set for each byte of specified memory<DD><CODE>extent</CODE> - Size parameters for where to set device memory (width field in bytes)<DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue,
 cudaErrorInvalidDevicePointer<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemset(jcuda.Pointer, int, long)"><CODE>cudaMemset(jcuda.Pointer, int, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset2D(jcuda.Pointer, long, int, long, long)"><CODE>cudaMemset2D(jcuda.Pointer, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)"><CODE>cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemsetAsync(jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)"><CODE>cudaMemsetAsync(jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset2DAsync(jcuda.Pointer, long, int, long, long, jcuda.runtime.cudaStream_t)"><CODE>cudaMemset2DAsync(jcuda.Pointer, long, int, long, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/cudaPitchedPtr.html" title="class in jcuda.runtime"><CODE>cudaPitchedPtr</CODE></A>, 
<A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime"><CODE>cudaExtent</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy3D(jcuda.runtime.cudaMemcpy3DParms)"><!-- --></A><H3>
cudaMemcpy3D</H3>
<PRE>
public static int <B>cudaMemcpy3D</B>(<A HREF="../../jcuda/runtime/cudaMemcpy3DParms.html" title="class in jcuda.runtime">cudaMemcpy3DParms</A>&nbsp;p)</PRE>
<DL>
<DD>Copies data between 3D objects.
 
 <pre>
 cudaError_t cudaMemcpy3D (
      const cudaMemcpy3DParms* p )
 </pre>
 <div>
   <p>Copies data between 3D objects.  
   <pre>struct cudaExtent {
   size_t width;
   size_t height;
   size_t depth;
 };
 struct cudaExtent 
                   make_cudaExtent(size_t w, size_t h, size_t d);
 
 struct cudaPos {
   size_t x;
   size_t y;
   size_t z;
 };
 struct cudaPos 
                   make_cudaPos(size_t x, size_t y, size_t z);
 
 struct cudaMemcpy3DParms {
   cudaArray_t           
                   srcArray;
   struct cudaPos        
                   srcPos;
   struct cudaPitchedPtr 
                   srcPtr;
   cudaArray_t           
                   dstArray;
   struct cudaPos        
                   dstPos;
   struct cudaPitchedPtr 
                   dstPtr;
   struct cudaExtent     
                   extent;
   enum cudaMemcpyKind   
                   kind;
 };</pre>
   </p>
   <p>cudaMemcpy3D() copies data betwen two
     3D objects. The source and destination objects may be in either host
     memory, device memory, or a CUDA
     array. The source, destination, extent,
     and kind of copy performed is specified by the cudaMemcpy3DParms struct
     which should be initialized to zero before use: 
   <pre>cudaMemcpy3DParms
 myParms = {0};</pre>
   </p>
   <p>The struct passed to cudaMemcpy3D() must
     specify one of <tt>srcArray</tt> or <tt>srcPtr</tt> and one of <tt>dstArray</tt> or <tt>dstPtr</tt>. Passing more than one non-zero
     source or destination will cause cudaMemcpy3D() to return an error.
   </p>
   <p>The <tt>srcPos</tt> and <tt>dstPos</tt>
     fields are optional offsets into the source and destination objects
     and are defined in units of each object's elements. The
     element for a host or device pointer is
     assumed to be <strong>unsigned char</strong>. For CUDA arrays,
     positions must be in the range [0, 2048) for any dimension.
   </p>
   <p>The <tt>extent</tt> field defines the
     dimensions of the transferred area in elements. If a CUDA array is
     participating in the copy, the extent
     is defined in terms of that array's
     elements. If no CUDA array is participating in the copy then the
     extents are defined in
     elements of <strong>unsigned
     char</strong>.
   </p>
   <p>The <tt>kind</tt> field defines the
     direction of the copy. It must be one of cudaMemcpyHostToHost,
     cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost, or
     cudaMemcpyDeviceToDevice.
   </p>
   <p>If the source and destination are both
     arrays, cudaMemcpy3D() will return an error if they do not have the
     same element size.
   </p>
   <p>The source and destination object may
     not overlap. If overlapping source and destination objects are
     specified, undefined
     behavior will result.
   </p>
   <p>The source object must lie entirely
     within the region defined by <tt>srcPos</tt> and <tt>extent</tt>.
     The destination object must lie entirely within the region defined by
     <tt>dstPos</tt> and <tt>extent</tt>.
   </p>
   <p>cudaMemcpy3D() returns an error if the
     pitch of <tt>srcPtr</tt> or <tt>dstPtr</tt> exceeds the maximum
     allowed. The pitch of a cudaPitchedPtr allocated with cudaMalloc3D()
     will always be valid.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           synchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p</CODE> - 3D memory copy parameters
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,
 cudaErrorInvalidPitchValue, cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)"><CODE>cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy3DAsync(jcuda.runtime.cudaMemcpy3DParms, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy3DAsync(jcuda.runtime.cudaMemcpy3DParms, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime"><CODE>cudaExtent</CODE></A>, 
<A HREF="../../jcuda/runtime/cudaPos.html" title="class in jcuda.runtime"><CODE>cudaPos</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy3DPeer(jcuda.runtime.cudaMemcpy3DPeerParms)"><!-- --></A><H3>
cudaMemcpy3DPeer</H3>
<PRE>
public static int <B>cudaMemcpy3DPeer</B>(<A HREF="../../jcuda/runtime/cudaMemcpy3DPeerParms.html" title="class in jcuda.runtime">cudaMemcpy3DPeerParms</A>&nbsp;p)</PRE>
<DL>
<DD>Copies memory between devices.
 
 <pre>
 cudaError_t cudaMemcpy3DPeer (
      const cudaMemcpy3DPeerParms* p )
 </pre>
 <div>
   <p>Copies memory between devices.  Perform
     a 3D memory copy according to the parameters specified in <tt>p</tt>.
     See the definition of the cudaMemcpy3DPeerParms structure for
     documentation of its parameters.
   </p>
   <p>Note that this function is synchronous
     with respect to the host only if the source or destination of the
     transfer is host
     memory. Note also that this copy is
     serialized with respect to all pending and future asynchronous work in
     to the current
     device, the copy's source device, and
     the copy's destination device (use cudaMemcpy3DPeerAsync to avoid this
     synchronization).
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           synchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p</CODE> - Parameters for the memory copy
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevice<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyPeer(jcuda.Pointer, int, jcuda.Pointer, int, long)"><CODE>cudaMemcpyPeer(jcuda.Pointer, int, jcuda.Pointer, int, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyPeerAsync(jcuda.Pointer, int, jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyPeerAsync(jcuda.Pointer, int, jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy3DPeerAsync(jcuda.runtime.cudaMemcpy3DPeerParms, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy3DPeerAsync(jcuda.runtime.cudaMemcpy3DPeerParms, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy3DAsync(jcuda.runtime.cudaMemcpy3DParms, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpy3DAsync</H3>
<PRE>
public static int <B>cudaMemcpy3DAsync</B>(<A HREF="../../jcuda/runtime/cudaMemcpy3DParms.html" title="class in jcuda.runtime">cudaMemcpy3DParms</A>&nbsp;p,
                                    <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Copies data between 3D objects.
 
 <pre>
 cudaError_t cudaMemcpy3DAsync (
      const cudaMemcpy3DParms* p,
      cudaStream_t stream = 0 )
 </pre>
 <div>
   <p>Copies data between 3D objects.  
   <pre>struct cudaExtent {
   size_t width;
   size_t height;
   size_t depth;
 };
 struct cudaExtent 
                   make_cudaExtent(size_t w, size_t h, size_t d);
 
 struct cudaPos {
   size_t x;
   size_t y;
   size_t z;
 };
 struct cudaPos 
                   make_cudaPos(size_t x, size_t y, size_t z);
 
 struct cudaMemcpy3DParms {
   cudaArray_t           
                   srcArray;
   struct cudaPos        
                   srcPos;
   struct cudaPitchedPtr 
                   srcPtr;
   cudaArray_t           
                   dstArray;
   struct cudaPos        
                   dstPos;
   struct cudaPitchedPtr 
                   dstPtr;
   struct cudaExtent     
                   extent;
   enum cudaMemcpyKind   
                   kind;
 };</pre>
   </p>
   <p>cudaMemcpy3DAsync() copies data betwen
     two 3D objects. The source and destination objects may be in either
     host memory, device memory, or a CUDA
     array. The source, destination, extent,
     and kind of copy performed is specified by the cudaMemcpy3DParms struct
     which should be initialized to zero before use: 
   <pre>cudaMemcpy3DParms
 myParms = {0};</pre>
   </p>
   <p>The struct passed to cudaMemcpy3DAsync()
     must specify one of <tt>srcArray</tt> or <tt>srcPtr</tt> and one of
     <tt>dstArray</tt> or <tt>dstPtr</tt>. Passing more than one non-zero
     source or destination will cause cudaMemcpy3DAsync() to return an
     error.
   </p>
   <p>The <tt>srcPos</tt> and <tt>dstPos</tt>
     fields are optional offsets into the source and destination objects
     and are defined in units of each object's elements. The
     element for a host or device pointer is
     assumed to be <strong>unsigned char</strong>. For CUDA arrays,
     positions must be in the range [0, 2048) for any dimension.
   </p>
   <p>The <tt>extent</tt> field defines the
     dimensions of the transferred area in elements. If a CUDA array is
     participating in the copy, the extent
     is defined in terms of that array's
     elements. If no CUDA array is participating in the copy then the
     extents are defined in
     elements of <strong>unsigned
     char</strong>.
   </p>
   <p>The <tt>kind</tt> field defines the
     direction of the copy. It must be one of cudaMemcpyHostToHost,
     cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost, or
     cudaMemcpyDeviceToDevice.
   </p>
   <p>If the source and destination are both
     arrays, cudaMemcpy3DAsync() will return an error if they do not have
     the same element size.
   </p>
   <p>The source and destination object may
     not overlap. If overlapping source and destination objects are
     specified, undefined
     behavior will result.
   </p>
   <p>The source object must lie entirely
     within the region defined by <tt>srcPos</tt> and <tt>extent</tt>.
     The destination object must lie entirely within the region defined by
     <tt>dstPos</tt> and <tt>extent</tt>.
   </p>
   <p>cudaMemcpy3DAsync() returns an error if
     the pitch of <tt>srcPtr</tt> or <tt>dstPtr</tt> exceeds the maximum
     allowed. The pitch of a cudaPitchedPtr allocated with cudaMalloc3D()
     will always be valid.
   </p>
   <p>cudaMemcpy3DAsync() is asynchronous with
     respect to the host, so the call may return before the copy is complete.
     The copy can optionally be
     associated to a stream by passing a
     non-zero <tt>stream</tt> argument. If <tt>kind</tt> is
     cudaMemcpyHostToDevice or cudaMemcpyDeviceToHost and <tt>stream</tt>
     is non-zero, the copy may overlap with operations in other streams.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           asynchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p</CODE> - 3D memory copy parameters<DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,
 cudaErrorInvalidPitchValue, cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)"><CODE>cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy3D(jcuda.runtime.cudaMemcpy3DParms)"><CODE>cudaMemcpy3D(jcuda.runtime.cudaMemcpy3DParms)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime"><CODE>cudaExtent</CODE></A>, 
<A HREF="../../jcuda/runtime/cudaPos.html" title="class in jcuda.runtime"><CODE>cudaPos</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy3DPeerAsync(jcuda.runtime.cudaMemcpy3DPeerParms, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpy3DPeerAsync</H3>
<PRE>
public static int <B>cudaMemcpy3DPeerAsync</B>(<A HREF="../../jcuda/runtime/cudaMemcpy3DPeerParms.html" title="class in jcuda.runtime">cudaMemcpy3DPeerParms</A>&nbsp;p,
                                        <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Copies memory between devices asynchronously.
 
 <pre>
 cudaError_t cudaMemcpy3DPeerAsync (
      const cudaMemcpy3DPeerParms* p,
      cudaStream_t stream = 0 )
 </pre>
 <div>
   <p>Copies memory between devices
     asynchronously.  Perform a 3D memory copy according to the parameters
     specified in <tt>p</tt>. See the definition of the cudaMemcpy3DPeerParms
     structure for documentation of its parameters.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           asynchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p</CODE> - Parameters for the memory copy<DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevice<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyPeer(jcuda.Pointer, int, jcuda.Pointer, int, long)"><CODE>cudaMemcpyPeer(jcuda.Pointer, int, jcuda.Pointer, int, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyPeerAsync(jcuda.Pointer, int, jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyPeerAsync(jcuda.Pointer, int, jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy3DPeerAsync(jcuda.runtime.cudaMemcpy3DPeerParms, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy3DPeerAsync(jcuda.runtime.cudaMemcpy3DPeerParms, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemGetInfo(long[], long[])"><!-- --></A><H3>
cudaMemGetInfo</H3>
<PRE>
public static int <B>cudaMemGetInfo</B>(long[]&nbsp;free,
                                 long[]&nbsp;total)</PRE>
<DL>
<DD>Gets free and total device memory.
 
 <pre>
 cudaError_t cudaMemGetInfo (
      size_t* free,
      size_t* total )
 </pre>
 <div>
   <p>Gets free and total device memory. 
     Returns in <tt>*free</tt> and <tt>*total</tt> respectively, the free
     and total amount of memory available for allocation by the device in
     bytes.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches. 
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>free</CODE> - Returned free memory in bytes<DD><CODE>total</CODE> - Returned total memory in bytes
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError, cudaErrorInvalidValue,
 cudaErrorLaunchFailure</DL>
</DD>
</DL>
<HR>

<A NAME="cudaArrayGetInfo(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent, int[], jcuda.runtime.cudaArray)"><!-- --></A><H3>
cudaArrayGetInfo</H3>
<PRE>
public static int <B>cudaArrayGetInfo</B>(<A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                                   <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent,
                                   int[]&nbsp;flags,
                                   <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array)</PRE>
<DL>
<DD>Gets info about the specified cudaArray.
 
 <pre>
 cudaError_t cudaArrayGetInfo (
      cudaChannelFormatDesc* desc,
      cudaExtent* extent,
      unsigned int* flags,
      cudaArray_t array )
 </pre>
 <div>
   <p>Gets info about the specified cudaArray.
     Returns in <tt>*desc</tt>, <tt>*extent</tt> and <tt>*flags</tt>
     respectively, the type, shape and flags of <tt>array</tt>.
   </p>
   <p>Any of <tt>*desc</tt>, <tt>*extent</tt>
     and <tt>*flags</tt> may be specified as NULL.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches. 
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>desc</CODE> - Returned array type<DD><CODE>extent</CODE> - Returned array shape. 2D arrays will have depth of zero<DD><CODE>flags</CODE> - Returned array flags<DD><CODE>array</CODE> - The cudaArray to get info for
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue</DL>
</DD>
</DL>
<HR>

<A NAME="cudaHostAlloc(jcuda.Pointer, long, int)"><!-- --></A><H3>
cudaHostAlloc</H3>
<PRE>
public static int <B>cudaHostAlloc</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr,
                                long&nbsp;size,
                                int&nbsp;flags)</PRE>
<DL>
<DD>Allocates page-locked memory on the host.
 
 <pre>
 cudaError_t cudaHostAlloc (
      void** pHost,
      size_t size,
      unsigned int  flags )
 </pre>
 <div>
   <p>Allocates page-locked memory on the host.
     Allocates <tt>size</tt> bytes of host memory that is page-locked and
     accessible to the device. The driver tracks the virtual memory ranges
     allocated
     with this function and automatically
     accelerates calls to functions such as cudaMemcpy(). Since the memory
     can be accessed directly by the device, it can be read or written with
     much higher bandwidth than pageable
     memory obtained with functions such as
     malloc(). Allocating excessive amounts of pinned memory may degrade
     system performance,
     since it reduces the amount of memory
     available to the system for paging. As a result, this function is best
     used sparingly
     to allocate staging areas for data
     exchange between host and device.
   </p>
   <p>The <tt>flags</tt> parameter enables
     different options to be specified that affect the allocation, as
     follows.
   <ul>
     <li>
       <p>cudaHostAllocDefault: This
         flag's value is defined to be 0 and causes cudaHostAlloc() to emulate
         cudaMallocHost().
       </p>
     </li>
     <li>
       <p>cudaHostAllocPortable: The
         memory returned by this call will be considered as pinned memory by
         all CUDA contexts, not just the one that performed
         the allocation.
       </p>
     </li>
     <li>
       <p>cudaHostAllocMapped: Maps the
         allocation into the CUDA address space. The device pointer to the
         memory may be obtained by calling cudaHostGetDevicePointer().
       </p>
     </li>
     <li>
       <p>cudaHostAllocWriteCombined:
         Allocates the memory as write-combined (WC). WC memory can be
         transferred across the PCI Express bus more quickly on some
         system configurations, but
         cannot be read efficiently by most CPUs. WC memory is a good option
         for buffers that will be written
         by the CPU and read by the
         device via mapped pinned memory or host-&gt;device transfers.
       </p>
     </li>
   </ul>
   </p>
   <p>All of these flags are orthogonal to
     one another: a developer may allocate memory that is portable, mapped
     and/or write-combined
     with no restrictions.
   </p>
   <p>cudaSetDeviceFlags() must have been
     called with the cudaDeviceMapHost flag in order for the
     cudaHostAllocMapped flag to have any effect.
   </p>
   <p>The cudaHostAllocMapped flag may be
     specified on CUDA contexts for devices that do not support mapped
     pinned memory. The failure is deferred to cudaHostGetDevicePointer()
     because the memory may be mapped into other CUDA contexts via the
     cudaHostAllocPortable flag.
   </p>
   <p>Memory allocated by this function must
     be freed with cudaFreeHost().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pHost</CODE> - Device pointer to allocated memory<DD><CODE>size</CODE> - Requested allocation size in bytes<DD><CODE>flags</CODE> - Requested properties of allocated memory
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMemoryAllocation<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaSetDeviceFlags(int)"><CODE>cudaSetDeviceFlags(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaHostRegister(jcuda.Pointer, long, int)"><!-- --></A><H3>
cudaHostRegister</H3>
<PRE>
public static int <B>cudaHostRegister</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr,
                                   long&nbsp;size,
                                   int&nbsp;flags)</PRE>
<DL>
<DD>Registers an existing host memory range for use by CUDA.
 
 <pre>
 cudaError_t cudaHostRegister (
      void* ptr,
      size_t size,
      unsigned int  flags )
 </pre>
 <div>
   <p>Registers an existing host memory range
     for use by CUDA.  Page-locks the memory range specified by <tt>ptr</tt>
     and <tt>size</tt> and maps it for the device(s) as specified by <tt>flags</tt>. This memory range also is added to the same tracking
     mechanism as cudaHostAlloc() to automatically accelerate calls to
     functions such as cudaMemcpy(). Since the memory can be accessed
     directly by the device, it can be read or written with much higher
     bandwidth than pageable
     memory that has not been registered.
     Page-locking excessive amounts of memory may degrade system performance,
     since it reduces
     the amount of memory available to the
     system for paging. As a result, this function is best used sparingly
     to register staging
     areas for data exchange between host and
     device.
   </p>
   <p>The <tt>flags</tt> parameter enables
     different options to be specified that affect the allocation, as
     follows.
   </p>
   <ul>
     <li>
       <p>cudaHostRegisterPortable: The
         memory returned by this call will be considered as pinned memory by
         all CUDA contexts, not just the one that performed
         the allocation.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaHostRegisterMapped: Maps
         the allocation into the CUDA address space. The device pointer to the
         memory may be obtained by calling cudaHostGetDevicePointer(). This
         feature is available only on GPUs with compute capability greater than
         or equal to 1.1.
       </p>
     </li>
   </ul>
   </p>
   <p>All of these flags are orthogonal to
     one another: a developer may page-lock memory that is portable or
     mapped with no restrictions.
   </p>
   <p>The CUDA context must have been created
     with the cudaMapHost flag in order for the cudaHostRegisterMapped flag
     to have any effect.
   </p>
   <p>The cudaHostRegisterMapped flag may be
     specified on CUDA contexts for devices that do not support mapped
     pinned memory. The failure is deferred to cudaHostGetDevicePointer()
     because the memory may be mapped into other CUDA contexts via the
     cudaHostRegisterPortable flag.
   </p>
   <p>The memory page-locked by this function
     must be unregistered with cudaHostUnregister().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ptr</CODE> - Host pointer to memory to page-lock<DD><CODE>size</CODE> - Size in bytes of the address range to page-lock in bytes<DD><CODE>flags</CODE> - Flags for allocation request
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorMemoryAllocation<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaHostUnregister(jcuda.Pointer)"><CODE>cudaHostUnregister(jcuda.Pointer)</CODE></A>, 
<CODE>JCuda#cudaHostGetFlags</CODE>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaHostGetDevicePointer(jcuda.Pointer, jcuda.Pointer, int)"><CODE>cudaHostGetDevicePointer(jcuda.Pointer, jcuda.Pointer, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaHostUnregister(jcuda.Pointer)"><!-- --></A><H3>
cudaHostUnregister</H3>
<PRE>
public static int <B>cudaHostUnregister</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr)</PRE>
<DL>
<DD>Unregisters a memory range that was registered with cudaHostRegister.
 
 <pre>
 cudaError_t cudaHostUnregister (
      void* ptr )
 </pre>
 <div>
   <p>Unregisters a memory range that was
     registered with cudaHostRegister.  Unmaps the memory range whose base
     address is specified
     by <tt>ptr</tt>, and makes it pageable
     again.
   </p>
   <p>The base address must be the same one
     specified to cudaHostRegister().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ptr</CODE> - Host pointer to memory to unregister
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaHostUnregister(jcuda.Pointer)"><CODE>cudaHostUnregister(jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaHostGetDevicePointer(jcuda.Pointer, jcuda.Pointer, int)"><!-- --></A><H3>
cudaHostGetDevicePointer</H3>
<PRE>
public static int <B>cudaHostGetDevicePointer</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pDevice,
                                           <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pHost,
                                           int&nbsp;flags)</PRE>
<DL>
<DD>Passes back device pointer of mapped host memory allocated by cudaHostAlloc or registered by cudaHostRegister.
 
 <pre>
 cudaError_t cudaHostGetDevicePointer (
      void** pDevice,
      void* pHost,
      unsigned int  flags )
 </pre>
 <div>
   <p>Passes back device pointer of mapped host
     memory allocated by cudaHostAlloc or registered by cudaHostRegister. 
     Passes back
     the device pointer corresponding to the
     mapped, pinned host buffer allocated by cudaHostAlloc() or registered
     by cudaHostRegister().
   </p>
   <p>cudaHostGetDevicePointer() will fail if
     the cudaDeviceMapHost flag was not specified before deferred context
     creation occurred, or if called on a device that does not support
     mapped,
     pinned memory.
   </p>
   <p><tt>flags</tt> provides for future
     releases. For now, it must be set to 0.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pDevice</CODE> - Returned device pointer for mapped memory<DD><CODE>pHost</CODE> - Requested host pointer mapping<DD><CODE>flags</CODE> - Flags for extensions (must be 0 for now)
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorMemoryAllocation<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaSetDeviceFlags(int)"><CODE>cudaSetDeviceFlags(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaHostAlloc(jcuda.Pointer, long, int)"><CODE>cudaHostAlloc(jcuda.Pointer, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMalloc(jcuda.Pointer, long)"><!-- --></A><H3>
cudaMalloc</H3>
<PRE>
public static int <B>cudaMalloc</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                             long&nbsp;size)</PRE>
<DL>
<DD>Allocate memory on the device.
 
 <pre>
 cudaError_t cudaMalloc (
      void** devPtr,
      size_t size )
 </pre>
 <div>
   <p>Allocate memory on the device.  Allocates
     <tt>size</tt> bytes of linear memory on the device and returns in <tt>*devPtr</tt> a pointer to the allocated memory. The allocated memory
     is suitably aligned for any kind of variable. The memory is not
     cleared.
     cudaMalloc() returns cudaErrorMemoryAllocation
     in case of failure.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>devPtr</CODE> - Pointer to allocated device memory<DD><CODE>size</CODE> - Requested allocation size in bytes
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMemoryAllocation<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)"><CODE>cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaHostAlloc(jcuda.Pointer, long, int)"><CODE>cudaHostAlloc(jcuda.Pointer, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMallocHost(jcuda.Pointer, long)"><!-- --></A><H3>
cudaMallocHost</H3>
<PRE>
public static int <B>cudaMallocHost</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr,
                                 long&nbsp;size)</PRE>
<DL>
<DD>[C++ API] Allocates page-locked memory on the host
 
 <pre>
 cudaError_t cudaMallocHost (
      void** ptr,
      size_t size,
      unsigned int  flags )
 </pre>
 <div>
   <p>[C++ API] Allocates page-locked memory
     on the host  Allocates <tt>size</tt> bytes of host memory that is
     page-locked and accessible to the device. The driver tracks the virtual
     memory ranges allocated
     with this function and automatically
     accelerates calls to functions such as cudaMemcpy(). Since the memory
     can be accessed directly by the device, it can be read or written with
     much higher bandwidth than pageable
     memory obtained with functions such as
     malloc(). Allocating excessive amounts of pinned memory may degrade
     system performance,
     since it reduces the amount of memory
     available to the system for paging. As a result, this function is best
     used sparingly
     to allocate staging areas for data
     exchange between host and device.
   </p>
   <p>The <tt>flags</tt> parameter enables
     different options to be specified that affect the allocation, as
     follows.
   <ul>
     <li>
       <p>cudaHostAllocDefault: This
         flag's value is defined to be 0.
       </p>
     </li>
     <li>
       <p>cudaHostAllocPortable: The
         memory returned by this call will be considered as pinned memory by
         all CUDA contexts, not just the one that performed
         the allocation.
       </p>
     </li>
     <li>
       <p>cudaHostAllocMapped: Maps the
         allocation into the CUDA address space. The device pointer to the
         memory may be obtained by calling cudaHostGetDevicePointer().
       </p>
     </li>
     <li>
       <p>cudaHostAllocWriteCombined:
         Allocates the memory as write-combined (WC). WC memory can be
         transferred across the PCI Express bus more quickly on some
         system configurations, but
         cannot be read efficiently by most CPUs. WC memory is a good option
         for buffers that will be written
         by the CPU and read by the
         device via mapped pinned memory or host-&gt;device transfers.
       </p>
     </li>
   </ul>
   </p>
   <p>All of these flags are orthogonal to
     one another: a developer may allocate memory that is portable, mapped
     and/or write-combined
     with no restrictions.
   </p>
   <p>cudaSetDeviceFlags() must have been
     called with the cudaDeviceMapHost flag in order for the
     cudaHostAllocMapped flag to have any effect.
   </p>
   <p>The cudaHostAllocMapped flag may be
     specified on CUDA contexts for devices that do not support mapped
     pinned memory. The failure is deferred to cudaHostGetDevicePointer()
     because the memory may be mapped into other CUDA contexts via the
     cudaHostAllocPortable flag.
   </p>
   <p>Memory allocated by this function must
     be freed with cudaFreeHost().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ptr</CODE> - Pointer to allocated host memory<DD><CODE>size</CODE> - Requested allocation size in bytes<DD><CODE>ptr</CODE> - Device pointer to allocated memory<DD><CODE>size</CODE> - Requested allocation size in bytes<DD><CODE>flags</CODE> - Requested properties of allocated memory
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMemoryAllocation<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaSetDeviceFlags(int)"><CODE>cudaSetDeviceFlags(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaHostAlloc(jcuda.Pointer, long, int)"><CODE>cudaHostAlloc(jcuda.Pointer, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMallocPitch(jcuda.Pointer, long[], long, long)"><!-- --></A><H3>
cudaMallocPitch</H3>
<PRE>
public static int <B>cudaMallocPitch</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                  long[]&nbsp;pitch,
                                  long&nbsp;width,
                                  long&nbsp;height)</PRE>
<DL>
<DD>Allocates pitched memory on the device.
 
 <pre>
 cudaError_t cudaMallocPitch (
      void** devPtr,
      size_t* pitch,
      size_t width,
      size_t height )
 </pre>
 <div>
   <p>Allocates pitched memory on the device. 
     Allocates at least <tt>width</tt> (in bytes) * <tt>height</tt> bytes
     of linear memory on the device and returns in <tt>*devPtr</tt> a
     pointer to the allocated memory. The function may pad the allocation
     to ensure that corresponding pointers in any given
     row will continue to meet the alignment
     requirements for coalescing as the address is updated from row to row.
     The pitch returned
     in <tt>*pitch</tt> by cudaMallocPitch()
     is the width in bytes of the allocation. The intended usage of <tt>pitch</tt> is as a separate parameter of the allocation, used to
     compute addresses within the 2D array. Given the row and column of
     an array element of type <tt>T</tt>,
     the address is computed as: 
   <pre>    T* pElement = (T*)((char*)BaseAddress
 + Row * pitch) + Column;</pre>
   </p>
   <p>For allocations of 2D arrays, it is
     recommended that programmers consider performing pitch allocations
     using cudaMallocPitch(). Due to pitch alignment restrictions in the
     hardware, this is especially true if the application will be performing
     2D memory
     copies between different regions of
     device memory (whether linear memory or CUDA arrays).
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>devPtr</CODE> - Pointer to allocated pitched device memory<DD><CODE>pitch</CODE> - Pitch for allocation<DD><CODE>width</CODE> - Requested pitched allocation width (in bytes)<DD><CODE>height</CODE> - Requested pitched allocation height
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMemoryAllocation<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)"><CODE>cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaHostAlloc(jcuda.Pointer, long, int)"><CODE>cudaHostAlloc(jcuda.Pointer, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)"><!-- --></A><H3>
cudaMallocArray</H3>
<PRE>
public static int <B>cudaMallocArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array,
                                  <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                                  long&nbsp;width,
                                  long&nbsp;height)</PRE>
<DL>
<DD>Allocate an array on the device.
 
 <pre>
 cudaError_t cudaMallocArray (
      cudaArray_t* array,
      const cudaChannelFormatDesc* desc,
      size_t width,
      size_t height = 0,
      unsigned int  flags = 0 )
 </pre>
 <div>
   <p>Allocate an array on the device. 
     Allocates a CUDA array according to the cudaChannelFormatDesc structure
     <tt>desc</tt> and returns a handle to the new CUDA array in <tt>*array</tt>.
   </p>
   <p>The cudaChannelFormatDesc is defined
     as: 
   <pre>    struct cudaChannelFormatDesc {
         int x, y, z, w;
     enum cudaChannelFormatKind 
                   f;
     };</pre>
   where cudaChannelFormatKind is one of
   cudaChannelFormatKindSigned, cudaChannelFormatKindUnsigned, or
   cudaChannelFormatKindFloat.
   </p>
   <p>The <tt>flags</tt> parameter enables
     different options to be specified that affect the allocation, as
     follows.
   <ul>
     <li>
       <p>cudaArrayDefault: This flag's
         value is defined to be 0 and provides default array allocation
       </p>
     </li>
     <li>
       <p>cudaArraySurfaceLoadStore:
         Allocates an array that can be read from or written to using a surface
         reference
       </p>
     </li>
     <li>
       <p>cudaArrayTextureGather: This
         flag indicates that texture gather operations will be performed on the
         array.
       </p>
     </li>
   </ul>
   </p>
   <p><tt>width</tt> and <tt>height</tt>
     must meet certain size requirements. See cudaMalloc3DArray() for more
     details.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Pointer to allocated array in device memory<DD><CODE>desc</CODE> - Requested channel format<DD><CODE>width</CODE> - Requested array allocation width<DD><CODE>height</CODE> - Requested array allocation height<DD><CODE>flags</CODE> - Requested properties of allocated array
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMemoryAllocation<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaHostAlloc(jcuda.Pointer, long, int)"><CODE>cudaHostAlloc(jcuda.Pointer, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long, int)"><!-- --></A><H3>
cudaMallocArray</H3>
<PRE>
public static int <B>cudaMallocArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array,
                                  <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                                  long&nbsp;width,
                                  long&nbsp;height,
                                  int&nbsp;flags)</PRE>
<DL>
<DD>Allocate an array on the device.
 
 <pre>
 cudaError_t cudaMallocArray (
      cudaArray_t* array,
      const cudaChannelFormatDesc* desc,
      size_t width,
      size_t height = 0,
      unsigned int  flags = 0 )
 </pre>
 <div>
   <p>Allocate an array on the device. 
     Allocates a CUDA array according to the cudaChannelFormatDesc structure
     <tt>desc</tt> and returns a handle to the new CUDA array in <tt>*array</tt>.
   </p>
   <p>The cudaChannelFormatDesc is defined
     as: 
   <pre>    struct cudaChannelFormatDesc {
         int x, y, z, w;
     enum cudaChannelFormatKind 
                   f;
     };</pre>
   where cudaChannelFormatKind is one of
   cudaChannelFormatKindSigned, cudaChannelFormatKindUnsigned, or
   cudaChannelFormatKindFloat.
   </p>
   <p>The <tt>flags</tt> parameter enables
     different options to be specified that affect the allocation, as
     follows.
   <ul>
     <li>
       <p>cudaArrayDefault: This flag's
         value is defined to be 0 and provides default array allocation
       </p>
     </li>
     <li>
       <p>cudaArraySurfaceLoadStore:
         Allocates an array that can be read from or written to using a surface
         reference
       </p>
     </li>
     <li>
       <p>cudaArrayTextureGather: This
         flag indicates that texture gather operations will be performed on the
         array.
       </p>
     </li>
   </ul>
   </p>
   <p><tt>width</tt> and <tt>height</tt>
     must meet certain size requirements. See cudaMalloc3DArray() for more
     details.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Pointer to allocated array in device memory<DD><CODE>desc</CODE> - Requested channel format<DD><CODE>width</CODE> - Requested array allocation width<DD><CODE>height</CODE> - Requested array allocation height<DD><CODE>flags</CODE> - Requested properties of allocated array
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMemoryAllocation<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaHostAlloc(jcuda.Pointer, long, int)"><CODE>cudaHostAlloc(jcuda.Pointer, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaFree(jcuda.Pointer)"><!-- --></A><H3>
cudaFree</H3>
<PRE>
public static int <B>cudaFree</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr)</PRE>
<DL>
<DD>Frees memory on the device.
 
 <pre>
 cudaError_t cudaFree (
      void* devPtr )
 </pre>
 <div>
   <p>Frees memory on the device.  Frees the
     memory space pointed to by <tt>devPtr</tt>, which must have been
     returned by a previous call to cudaMalloc() or cudaMallocPitch().
     Otherwise, or if cudaFree(<tt>devPtr</tt>) has already been called
     before, an error is returned. If <tt>devPtr</tt> is 0, no operation
     is performed. cudaFree() returns cudaErrorInvalidDevicePointer in case
     of failure.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>devPtr</CODE> - Device pointer to memory to free
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevicePointer,
 cudaErrorInitializationError<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)"><CODE>cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaHostAlloc(jcuda.Pointer, long, int)"><CODE>cudaHostAlloc(jcuda.Pointer, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaFreeHost(jcuda.Pointer)"><!-- --></A><H3>
cudaFreeHost</H3>
<PRE>
public static int <B>cudaFreeHost</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr)</PRE>
<DL>
<DD>Frees page-locked memory.
 
 <pre>
 cudaError_t cudaFreeHost (
      void* ptr )
 </pre>
 <div>
   <p>Frees page-locked memory.  Frees the
     memory space pointed to by <tt>hostPtr</tt>, which must have been
     returned by a previous call to cudaMallocHost() or cudaHostAlloc().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ptr</CODE> - Pointer to memory to free
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)"><CODE>cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaHostAlloc(jcuda.Pointer, long, int)"><CODE>cudaHostAlloc(jcuda.Pointer, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaFreeArray(jcuda.runtime.cudaArray)"><!-- --></A><H3>
cudaFreeArray</H3>
<PRE>
public static int <B>cudaFreeArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array)</PRE>
<DL>
<DD>Frees an array on the device.
 
 <pre>
 cudaError_t cudaFreeArray (
      cudaArray_t array )
 </pre>
 <div>
   <p>Frees an array on the device.  Frees the
     CUDA array <tt>array</tt>, which must have been * returned by a
     previous call to cudaMallocArray(). If cudaFreeArray(<tt>array</tt>)
     has already been called before, cudaErrorInvalidValue is returned. If
     <tt>devPtr</tt> is 0, no operation is performed.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Pointer to array to free
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue,
 cudaErrorInitializationError<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)"><CODE>cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaHostAlloc(jcuda.Pointer, long, int)"><CODE>cudaHostAlloc(jcuda.Pointer, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaFreeMipmappedArray(jcuda.runtime.cudaMipmappedArray)"><!-- --></A><H3>
cudaFreeMipmappedArray</H3>
<PRE>
public static int <B>cudaFreeMipmappedArray</B>(<A HREF="../../jcuda/runtime/cudaMipmappedArray.html" title="class in jcuda.runtime">cudaMipmappedArray</A>&nbsp;mipmappedArray)</PRE>
<DL>
<DD>Frees a mipmapped array on the device.
 
 <pre>
 cudaError_t cudaFreeMipmappedArray (
      cudaMipmappedArray_t mipmappedArray )
 </pre>
 <div>
   <p>Frees a mipmapped array on the device. 
     Frees the CUDA mipmapped array <tt>mipmappedArray</tt>, which must
     have been returned by a previous call to cudaMallocMipmappedArray().
     If cudaFreeMipmappedArray(<tt>mipmappedArray</tt>) has already been
     called before, cudaErrorInvalidValue is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mipmappedArray</CODE> - Pointer to mipmapped array to free
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue,
 cudaErrorInitializationError<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)"><CODE>cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaHostAlloc(jcuda.Pointer, long, int)"><CODE>cudaHostAlloc(jcuda.Pointer, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><!-- --></A><H3>
cudaMemcpy</H3>
<PRE>
public static int <B>cudaMemcpy</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                             <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                             long&nbsp;count,
                             int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data between host and device.
 
 <pre>
 cudaError_t cudaMemcpy (
      void* dst,
      const void* src,
      size_t count,
      cudaMemcpyKind kind )
 </pre>
 <div>
   <p>Copies data between host and device. 
     Copies <tt>count</tt> bytes from the memory area pointed to by <tt>src</tt> to the memory area pointed to by <tt>dst</tt>, where <tt>kind</tt> is one of cudaMemcpyHostToHost, cudaMemcpyHostToDevice,
     cudaMemcpyDeviceToHost, or cudaMemcpyDeviceToDevice, and specifies the
     direction of the copy. The memory areas may not overlap. Calling
     cudaMemcpy() with <tt>dst</tt> and <tt>src</tt> pointers that do not
     match the direction of the copy results in an undefined behavior.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches.
         </p>
       </li>
       <li>
         <p>This function exhibits
           synchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination memory address<DD><CODE>src</CODE> - Source memory address<DD><CODE>count</CODE> - Size in bytes to copy<DD><CODE>kind</CODE> - Type of transfer
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,
 cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyPeer(jcuda.Pointer, int, jcuda.Pointer, int, long)"><!-- --></A><H3>
cudaMemcpyPeer</H3>
<PRE>
public static int <B>cudaMemcpyPeer</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                 int&nbsp;dstDevice,
                                 <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                 int&nbsp;srcDevice,
                                 long&nbsp;count)</PRE>
<DL>
<DD>Copies memory between two devices.
 
 <pre>
 cudaError_t cudaMemcpyPeer (
      void* dst,
      int  dstDevice,
      const void* src,
      int  srcDevice,
      size_t count )
 </pre>
 <div>
   <p>Copies memory between two devices. 
     Copies memory from one device to memory on another device. <tt>dst</tt>
     is the base device pointer of the destination memory and <tt>dstDevice</tt> is the destination device. <tt>src</tt> is the base
     device pointer of the source memory and <tt>srcDevice</tt> is the
     source device. <tt>count</tt> specifies the number of bytes to copy.
   </p>
   <p>Note that this function is asynchronous
     with respect to the host, but serialized with respect all pending and
     future asynchronous
     work in to the current device, <tt>srcDevice</tt>, and <tt>dstDevice</tt> (use cudaMemcpyPeerAsync to
     avoid this synchronization).
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           synchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination device pointer<DD><CODE>dstDevice</CODE> - Destination device<DD><CODE>src</CODE> - Source device pointer<DD><CODE>srcDevice</CODE> - Source device<DD><CODE>count</CODE> - Size of memory copy in bytes
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevice<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyPeerAsync(jcuda.Pointer, int, jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyPeerAsync(jcuda.Pointer, int, jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy3DPeerAsync(jcuda.runtime.cudaMemcpy3DPeerParms, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy3DPeerAsync(jcuda.runtime.cudaMemcpy3DPeerParms, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><!-- --></A><H3>
cudaMemcpyToArray</H3>
<PRE>
public static int <B>cudaMemcpyToArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                                    long&nbsp;wOffset,
                                    long&nbsp;hOffset,
                                    <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                    long&nbsp;count,
                                    int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data between host and device.
 
 <pre>
 cudaError_t cudaMemcpyToArray (
      cudaArray_t dst,
      size_t wOffset,
      size_t hOffset,
      const void* src,
      size_t count,
      cudaMemcpyKind kind )
 </pre>
 <div>
   <p>Copies data between host and device. 
     Copies <tt>count</tt> bytes from the memory area pointed to by <tt>src</tt> to the CUDA array <tt>dst</tt> starting at the upper left
     corner (<tt>wOffset</tt>, <tt>hOffset</tt>), where <tt>kind</tt> is
     one of cudaMemcpyHostToHost, cudaMemcpyHostToDevice,
     cudaMemcpyDeviceToHost, or cudaMemcpyDeviceToDevice, and specifies the
     direction of the copy.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           synchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination memory address<DD><CODE>wOffset</CODE> - Destination starting X offset<DD><CODE>hOffset</CODE> - Destination starting Y offset<DD><CODE>src</CODE> - Source memory address<DD><CODE>count</CODE> - Size in bytes to copy<DD><CODE>kind</CODE> - Type of transfer
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,
 cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><!-- --></A><H3>
cudaMemcpyFromArray</H3>
<PRE>
public static int <B>cudaMemcpyFromArray</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                      <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                                      long&nbsp;wOffset,
                                      long&nbsp;hOffset,
                                      long&nbsp;count,
                                      int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data between host and device.
 
 <pre>
 cudaError_t cudaMemcpyFromArray (
      void* dst,
      cudaArray_const_t src,
      size_t wOffset,
      size_t hOffset,
      size_t count,
      cudaMemcpyKind kind )
 </pre>
 <div>
   <p>Copies data between host and device. 
     Copies <tt>count</tt> bytes from the CUDA array <tt>src</tt> starting
     at the upper left corner (<tt>wOffset</tt>, hOffset) to the memory
     area pointed to by <tt>dst</tt>, where <tt>kind</tt> is one of
     cudaMemcpyHostToHost, cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost,
     or cudaMemcpyDeviceToDevice, and specifies the direction of the copy.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           synchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination memory address<DD><CODE>src</CODE> - Source memory address<DD><CODE>wOffset</CODE> - Source starting X offset<DD><CODE>hOffset</CODE> - Source starting Y offset<DD><CODE>count</CODE> - Size in bytes to copy<DD><CODE>kind</CODE> - Type of transfer
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,
 cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><!-- --></A><H3>
cudaMemcpyArrayToArray</H3>
<PRE>
public static int <B>cudaMemcpyArrayToArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                                         long&nbsp;wOffsetDst,
                                         long&nbsp;hOffsetDst,
                                         <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                                         long&nbsp;wOffsetSrc,
                                         long&nbsp;hOffsetSrc,
                                         long&nbsp;count,
                                         int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data between host and device.
 
 <pre>
 cudaError_t cudaMemcpyArrayToArray (
      cudaArray_t dst,
      size_t wOffsetDst,
      size_t hOffsetDst,
      cudaArray_const_t src,
      size_t wOffsetSrc,
      size_t hOffsetSrc,
      size_t count,
      cudaMemcpyKind kind = cudaMemcpyDeviceToDevice )
 </pre>
 <div>
   <p>Copies data between host and device. 
     Copies <tt>count</tt> bytes from the CUDA array <tt>src</tt> starting
     at the upper left corner (<tt>wOffsetSrc</tt>, <tt>hOffsetSrc</tt>)
     to the CUDA array <tt>dst</tt> starting at the upper left corner (<tt>wOffsetDst</tt>, <tt>hOffsetDst</tt>) where <tt>kind</tt> is one of
     cudaMemcpyHostToHost, cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost,
     or cudaMemcpyDeviceToDevice, and specifies the direction of the copy.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination memory address<DD><CODE>wOffsetDst</CODE> - Destination starting X offset<DD><CODE>hOffsetDst</CODE> - Destination starting Y offset<DD><CODE>src</CODE> - Source memory address<DD><CODE>wOffsetSrc</CODE> - Source starting X offset<DD><CODE>hOffsetSrc</CODE> - Source starting Y offset<DD><CODE>count</CODE> - Size in bytes to copy<DD><CODE>kind</CODE> - Type of transfer
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue,
 cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><!-- --></A><H3>
cudaMemcpy2D</H3>
<PRE>
public static int <B>cudaMemcpy2D</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                               long&nbsp;dpitch,
                               <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                               long&nbsp;spitch,
                               long&nbsp;width,
                               long&nbsp;height,
                               int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data between host and device.
 
 <pre>
 cudaError_t cudaMemcpy2D (
      void* dst,
      size_t dpitch,
      const void* src,
      size_t spitch,
      size_t width,
      size_t height,
      cudaMemcpyKind kind )
 </pre>
 <div>
   <p>Copies data between host and device. 
     Copies a matrix (<tt>height</tt> rows of <tt>width</tt> bytes each)
     from the memory area pointed to by <tt>src</tt> to the memory area
     pointed to by <tt>dst</tt>, where <tt>kind</tt> is one of
     cudaMemcpyHostToHost, cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost,
     or cudaMemcpyDeviceToDevice, and specifies the direction of the copy.
     <tt>dpitch</tt> and <tt>spitch</tt> are the widths in memory in bytes
     of the 2D arrays pointed to by <tt>dst</tt> and <tt>src</tt>,
     including any padding added to the end of each row. The memory areas
     may not overlap. <tt>width</tt> must not exceed either <tt>dpitch</tt>
     or <tt>spitch</tt>. Calling cudaMemcpy2D() with <tt>dst</tt> and <tt>src</tt> pointers that do not match the direction of the copy results
     in an undefined behavior. cudaMemcpy2D() returns an error if <tt>dpitch</tt> or <tt>spitch</tt> exceeds the maximum allowed.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination memory address<DD><CODE>dpitch</CODE> - Pitch of destination memory<DD><CODE>src</CODE> - Source memory address<DD><CODE>spitch</CODE> - Pitch of source memory<DD><CODE>width</CODE> - Width of matrix transfer (columns in bytes)<DD><CODE>height</CODE> - Height of matrix transfer (rows)<DD><CODE>kind</CODE> - Type of transfer
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidPitchValue,
 cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><!-- --></A><H3>
cudaMemcpy2DToArray</H3>
<PRE>
public static int <B>cudaMemcpy2DToArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                                      long&nbsp;wOffset,
                                      long&nbsp;hOffset,
                                      <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                      long&nbsp;spitch,
                                      long&nbsp;width,
                                      long&nbsp;height,
                                      int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data between host and device.
 
 <pre>
 cudaError_t cudaMemcpy2DToArray (
      cudaArray_t dst,
      size_t wOffset,
      size_t hOffset,
      const void* src,
      size_t spitch,
      size_t width,
      size_t height,
      cudaMemcpyKind kind )
 </pre>
 <div>
   <p>Copies data between host and device. 
     Copies a matrix (<tt>height</tt> rows of <tt>width</tt> bytes each)
     from the memory area pointed to by <tt>src</tt> to the CUDA array <tt>dst</tt> starting at the upper left corner (<tt>wOffset</tt>, <tt>hOffset</tt>) where <tt>kind</tt> is one of cudaMemcpyHostToHost,
     cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost, or cudaMemcpyDeviceToDevice,
     and specifies the direction of the copy. <tt>spitch</tt> is the width
     in memory in bytes of the 2D array pointed to by <tt>src</tt>,
     including any padding added to the end of each row. <tt>wOffset</tt>
     + <tt>width</tt> must not exceed the width of the CUDA array <tt>dst</tt>. <tt>width</tt> must not exceed <tt>spitch</tt>.
     cudaMemcpy2DToArray() returns an error if <tt>spitch</tt> exceeds the
     maximum allowed.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           synchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination memory address<DD><CODE>wOffset</CODE> - Destination starting X offset<DD><CODE>hOffset</CODE> - Destination starting Y offset<DD><CODE>src</CODE> - Source memory address<DD><CODE>spitch</CODE> - Pitch of source memory<DD><CODE>width</CODE> - Width of matrix transfer (columns in bytes)<DD><CODE>height</CODE> - Height of matrix transfer (rows)<DD><CODE>kind</CODE> - Type of transfer
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,
 cudaErrorInvalidPitchValue, cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><!-- --></A><H3>
cudaMemcpy2DFromArray</H3>
<PRE>
public static int <B>cudaMemcpy2DFromArray</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                        long&nbsp;dpitch,
                                        <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                                        long&nbsp;wOffset,
                                        long&nbsp;hOffset,
                                        long&nbsp;width,
                                        long&nbsp;height,
                                        int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data between host and device.
 
 <pre>
 cudaError_t cudaMemcpy2DFromArray (
      void* dst,
      size_t dpitch,
      cudaArray_const_t src,
      size_t wOffset,
      size_t hOffset,
      size_t width,
      size_t height,
      cudaMemcpyKind kind )
 </pre>
 <div>
   <p>Copies data between host and device. 
     Copies a matrix (<tt>height</tt> rows of <tt>width</tt> bytes each)
     from the CUDA array <tt>srcArray</tt> starting at the upper left
     corner (<tt>wOffset</tt>, <tt>hOffset</tt>) to the memory area
     pointed to by <tt>dst</tt>, where <tt>kind</tt> is one of
     cudaMemcpyHostToHost, cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost,
     or cudaMemcpyDeviceToDevice, and specifies the direction of the copy.
     <tt>dpitch</tt> is the width in memory in bytes of the 2D array
     pointed to by <tt>dst</tt>, including any padding added to the end of
     each row. <tt>wOffset</tt> + <tt>width</tt> must not exceed the width
     of the CUDA array <tt>src</tt>. <tt>width</tt> must not exceed <tt>dpitch</tt>. cudaMemcpy2DFromArray() returns an error if <tt>dpitch</tt> exceeds the maximum allowed.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           synchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination memory address<DD><CODE>dpitch</CODE> - Pitch of destination memory<DD><CODE>src</CODE> - Source memory address<DD><CODE>wOffset</CODE> - Source starting X offset<DD><CODE>hOffset</CODE> - Source starting Y offset<DD><CODE>width</CODE> - Width of matrix transfer (columns in bytes)<DD><CODE>height</CODE> - Height of matrix transfer (rows)<DD><CODE>kind</CODE> - Type of transfer
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,
 cudaErrorInvalidPitchValue, cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><!-- --></A><H3>
cudaMemcpy2DArrayToArray</H3>
<PRE>
public static int <B>cudaMemcpy2DArrayToArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                                           long&nbsp;wOffsetDst,
                                           long&nbsp;hOffsetDst,
                                           <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                                           long&nbsp;wOffsetSrc,
                                           long&nbsp;hOffsetSrc,
                                           long&nbsp;width,
                                           long&nbsp;height,
                                           int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data between host and device.
 
 <pre>
 cudaError_t cudaMemcpy2DArrayToArray (
      cudaArray_t dst,
      size_t wOffsetDst,
      size_t hOffsetDst,
      cudaArray_const_t src,
      size_t wOffsetSrc,
      size_t hOffsetSrc,
      size_t width,
      size_t height,
      cudaMemcpyKind kind = cudaMemcpyDeviceToDevice )
 </pre>
 <div>
   <p>Copies data between host and device. 
     Copies a matrix (<tt>height</tt> rows of <tt>width</tt> bytes each)
     from the CUDA array <tt>srcArray</tt> starting at the upper left
     corner (<tt>wOffsetSrc</tt>, <tt>hOffsetSrc</tt>) to the CUDA array
     <tt>dst</tt> starting at the upper left corner (<tt>wOffsetDst</tt>,
     <tt>hOffsetDst</tt>), where <tt>kind</tt> is one of cudaMemcpyHostToHost,
     cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost, or cudaMemcpyDeviceToDevice,
     and specifies the direction of the copy. <tt>wOffsetDst</tt> + <tt>width</tt> must not exceed the width of the CUDA array <tt>dst</tt>.
     <tt>wOffsetSrc</tt> + <tt>width</tt> must not exceed the width of
     the CUDA array <tt>src</tt>.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           synchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination memory address<DD><CODE>wOffsetDst</CODE> - Destination starting X offset<DD><CODE>hOffsetDst</CODE> - Destination starting Y offset<DD><CODE>src</CODE> - Source memory address<DD><CODE>wOffsetSrc</CODE> - Source starting X offset<DD><CODE>hOffsetSrc</CODE> - Source starting Y offset<DD><CODE>width</CODE> - Width of matrix transfer (columns in bytes)<DD><CODE>height</CODE> - Height of matrix transfer (rows)<DD><CODE>kind</CODE> - Type of transfer
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue,
 cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><!-- --></A><H3>
cudaMemcpyToSymbol</H3>
<PRE>
public static int <B>cudaMemcpyToSymbol</B>(java.lang.String&nbsp;symbol,
                                     <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                     long&nbsp;count,
                                     long&nbsp;offset,
                                     int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>[C++ API] Copies data to the given symbol on the device
 
 <pre>
 template < class T > cudaError_t cudaMemcpyToSymbol (
      const T& symbol,
      const void* src,
      size_t count,
      size_t offset = 0,
      cudaMemcpyKind kind = cudaMemcpyHostToDevice ) [inline]
 </pre>
 <div>
   <p>[C++ API] Copies data to the given symbol
     on the device  Copies <tt>count</tt> bytes from the memory area
     pointed to by <tt>src</tt> to the memory area <tt>offset</tt> bytes
     from the start of symbol <tt>symbol</tt>. The memory areas may not
     overlap. <tt>symbol</tt> is a variable that resides in global or
     constant memory space. <tt>kind</tt> can be either cudaMemcpyHostToDevice
     or cudaMemcpyDeviceToDevice.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           synchronous behavior for most use cases. 
         </p>
       </li>
       <li>
         <p>Use of a string naming a
           variable as the <tt>symbol</tt> paramater was deprecated in CUDA 4.1
           and removed in CUDA 5.0.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>symbol</CODE> - Device symbol address<DD><CODE>src</CODE> - Source memory address<DD><CODE>count</CODE> - Size in bytes to copy<DD><CODE>offset</CODE> - Offset from start of symbol in bytes<DD><CODE>kind</CODE> - Type of transfer<DD><CODE>symbol</CODE> - Device symbol reference<DD><CODE>src</CODE> - Source memory address<DD><CODE>count</CODE> - Size in bytes to copy<DD><CODE>offset</CODE> - Offset from start of symbol in bytes<DD><CODE>kind</CODE> - Type of transfer
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidSymbol,
 cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><!-- --></A><H3>
cudaMemcpyFromSymbol</H3>
<PRE>
public static int <B>cudaMemcpyFromSymbol</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                       java.lang.String&nbsp;symbol,
                                       long&nbsp;count,
                                       long&nbsp;offset,
                                       int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>[C++ API] Copies data from the given symbol on the device
 
 <pre>
 template < class T > cudaError_t cudaMemcpyFromSymbol (
      void* dst,
      const T& symbol,
      size_t count,
      size_t offset = 0,
      cudaMemcpyKind kind = cudaMemcpyDeviceToHost ) [inline]
 </pre>
 <div>
   <p>[C++ API] Copies data from the given
     symbol on the device  Copies <tt>count</tt> bytes from the memory area
     <tt>offset</tt> bytes from the start of symbol <tt>symbol</tt> to
     the memory area pointed to by <tt>dst</tt>. The memory areas may not
     overlap. <tt>symbol</tt> is a variable that resides in global or
     constant memory space. <tt>kind</tt> can be either cudaMemcpyDeviceToHost
     or cudaMemcpyDeviceToDevice.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           synchronous behavior for most use cases. 
         </p>
       </li>
       <li>
         <p>Use of a string naming a
           variable as the <tt>symbol</tt> paramater was deprecated in CUDA 4.1
           and removed in CUDA 5.0.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination memory address<DD><CODE>symbol</CODE> - Device symbol address<DD><CODE>count</CODE> - Size in bytes to copy<DD><CODE>offset</CODE> - Offset from start of symbol in bytes<DD><CODE>kind</CODE> - Type of transfer<DD><CODE>dst</CODE> - Destination memory address<DD><CODE>symbol</CODE> - Device symbol reference<DD><CODE>count</CODE> - Size in bytes to copy<DD><CODE>offset</CODE> - Offset from start of symbol in bytes<DD><CODE>kind</CODE> - Type of transfer
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidSymbol,
 cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpyAsync</H3>
<PRE>
public static int <B>cudaMemcpyAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                  <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                  long&nbsp;count,
                                  int&nbsp;cudaMemcpyKind_kind,
                                  <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Copies data between host and device.
 
 <pre>
 cudaError_t cudaMemcpyAsync (
      void* dst,
      const void* src,
      size_t count,
      cudaMemcpyKind kind,
      cudaStream_t stream = 0 )
 </pre>
 <div>
   <p>Copies data between host and device. 
     Copies <tt>count</tt> bytes from the memory area pointed to by <tt>src</tt> to the memory area pointed to by <tt>dst</tt>, where <tt>kind</tt> is one of cudaMemcpyHostToHost, cudaMemcpyHostToDevice,
     cudaMemcpyDeviceToHost, or cudaMemcpyDeviceToDevice, and specifies the
     direction of the copy. The memory areas may not overlap. Calling
     cudaMemcpyAsync() with <tt>dst</tt> and <tt>src</tt> pointers that
     do not match the direction of the copy results in an undefined
     behavior.
   </p>
   <p>cudaMemcpyAsync() is asynchronous with
     respect to the host, so the call may return before the copy is complete.
     The copy can optionally be
     associated to a stream by passing a
     non-zero <tt>stream</tt> argument. If <tt>kind</tt> is
     cudaMemcpyHostToDevice or cudaMemcpyDeviceToHost and the <tt>stream</tt>
     is non-zero, the copy may overlap with operations in other streams.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           asynchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination memory address<DD><CODE>src</CODE> - Source memory address<DD><CODE>count</CODE> - Size in bytes to copy<DD><CODE>kind</CODE> - Type of transfer<DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,
 cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyPeerAsync(jcuda.Pointer, int, jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpyPeerAsync</H3>
<PRE>
public static int <B>cudaMemcpyPeerAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                      int&nbsp;dstDevice,
                                      <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                      int&nbsp;srcDevice,
                                      long&nbsp;count,
                                      <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Copies memory between two devices asynchronously.
 
 <pre>
 cudaError_t cudaMemcpyPeerAsync (
      void* dst,
      int  dstDevice,
      const void* src,
      int  srcDevice,
      size_t count,
      cudaStream_t stream = 0 )
 </pre>
 <div>
   <p>Copies memory between two devices
     asynchronously.  Copies memory from one device to memory on another
     device. <tt>dst</tt> is the base device pointer of the destination
     memory and <tt>dstDevice</tt> is the destination device. <tt>src</tt>
     is the base device pointer of the source memory and <tt>srcDevice</tt>
     is the source device. <tt>count</tt> specifies the number of bytes to
     copy.
   </p>
   <p>Note that this function is asynchronous
     with respect to the host and all work in other streams and other
     devices.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           asynchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination device pointer<DD><CODE>dstDevice</CODE> - Destination device<DD><CODE>src</CODE> - Source device pointer<DD><CODE>srcDevice</CODE> - Source device<DD><CODE>count</CODE> - Size of memory copy in bytes<DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevice<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyPeer(jcuda.Pointer, int, jcuda.Pointer, int, long)"><CODE>cudaMemcpyPeer(jcuda.Pointer, int, jcuda.Pointer, int, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy3DPeerAsync(jcuda.runtime.cudaMemcpy3DPeerParms, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy3DPeerAsync(jcuda.runtime.cudaMemcpy3DPeerParms, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpyToArrayAsync</H3>
<PRE>
public static int <B>cudaMemcpyToArrayAsync</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                                         long&nbsp;wOffset,
                                         long&nbsp;hOffset,
                                         <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                         long&nbsp;count,
                                         int&nbsp;cudaMemcpyKind_kind,
                                         <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Copies data between host and device.
 
 <pre>
 cudaError_t cudaMemcpyToArrayAsync (
      cudaArray_t dst,
      size_t wOffset,
      size_t hOffset,
      const void* src,
      size_t count,
      cudaMemcpyKind kind,
      cudaStream_t stream = 0 )
 </pre>
 <div>
   <p>Copies data between host and device. 
     Copies <tt>count</tt> bytes from the memory area pointed to by <tt>src</tt> to the CUDA array <tt>dst</tt> starting at the upper left
     corner (<tt>wOffset</tt>, <tt>hOffset</tt>), where <tt>kind</tt> is
     one of cudaMemcpyHostToHost, cudaMemcpyHostToDevice,
     cudaMemcpyDeviceToHost, or cudaMemcpyDeviceToDevice, and specifies the
     direction of the copy.
   </p>
   <p>cudaMemcpyToArrayAsync() is asynchronous
     with respect to the host, so the call may return before the copy is
     complete. The copy can optionally be
     associated to a stream by passing a
     non-zero <tt>stream</tt> argument. If <tt>kind</tt> is
     cudaMemcpyHostToDevice or cudaMemcpyDeviceToHost and <tt>stream</tt>
     is non-zero, the copy may overlap with operations in other streams.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           asynchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination memory address<DD><CODE>wOffset</CODE> - Destination starting X offset<DD><CODE>hOffset</CODE> - Destination starting Y offset<DD><CODE>src</CODE> - Source memory address<DD><CODE>count</CODE> - Size in bytes to copy<DD><CODE>kind</CODE> - Type of transfer<DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,
 cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpyFromArrayAsync</H3>
<PRE>
public static int <B>cudaMemcpyFromArrayAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                           <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                                           long&nbsp;wOffset,
                                           long&nbsp;hOffset,
                                           long&nbsp;count,
                                           int&nbsp;cudaMemcpyKind_kind,
                                           <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Copies data between host and device.
 
 <pre>
 cudaError_t cudaMemcpyFromArrayAsync (
      void* dst,
      cudaArray_const_t src,
      size_t wOffset,
      size_t hOffset,
      size_t count,
      cudaMemcpyKind kind,
      cudaStream_t stream = 0 )
 </pre>
 <div>
   <p>Copies data between host and device. 
     Copies <tt>count</tt> bytes from the CUDA array <tt>src</tt> starting
     at the upper left corner (<tt>wOffset</tt>, hOffset) to the memory
     area pointed to by <tt>dst</tt>, where <tt>kind</tt> is one of
     cudaMemcpyHostToHost, cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost,
     or cudaMemcpyDeviceToDevice, and specifies the direction of the copy.
   </p>
   <p>cudaMemcpyFromArrayAsync() is asynchronous
     with respect to the host, so the call may return before the copy is
     complete. The copy can optionally be
     associated to a stream by passing a
     non-zero <tt>stream</tt> argument. If <tt>kind</tt> is
     cudaMemcpyHostToDevice or cudaMemcpyDeviceToHost and <tt>stream</tt>
     is non-zero, the copy may overlap with operations in other streams.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           asynchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination memory address<DD><CODE>src</CODE> - Source memory address<DD><CODE>wOffset</CODE> - Source starting X offset<DD><CODE>hOffset</CODE> - Source starting Y offset<DD><CODE>count</CODE> - Size in bytes to copy<DD><CODE>kind</CODE> - Type of transfer<DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,
 cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpy2DAsync</H3>
<PRE>
public static int <B>cudaMemcpy2DAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                    long&nbsp;dpitch,
                                    <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                    long&nbsp;spitch,
                                    long&nbsp;width,
                                    long&nbsp;height,
                                    int&nbsp;cudaMemcpyKind_kind,
                                    <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Copies data between host and device.
 
 <pre>
 cudaError_t cudaMemcpy2DAsync (
      void* dst,
      size_t dpitch,
      const void* src,
      size_t spitch,
      size_t width,
      size_t height,
      cudaMemcpyKind kind,
      cudaStream_t stream = 0 )
 </pre>
 <div>
   <p>Copies data between host and device. 
     Copies a matrix (<tt>height</tt> rows of <tt>width</tt> bytes each)
     from the memory area pointed to by <tt>src</tt> to the memory area
     pointed to by <tt>dst</tt>, where <tt>kind</tt> is one of
     cudaMemcpyHostToHost, cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost,
     or cudaMemcpyDeviceToDevice, and specifies the direction of the copy.
     <tt>dpitch</tt> and <tt>spitch</tt> are the widths in memory in bytes
     of the 2D arrays pointed to by <tt>dst</tt> and <tt>src</tt>,
     including any padding added to the end of each row. The memory areas
     may not overlap. <tt>width</tt> must not exceed either <tt>dpitch</tt>
     or <tt>spitch</tt>. Calling cudaMemcpy2DAsync() with <tt>dst</tt>
     and <tt>src</tt> pointers that do not match the direction of the copy
     results in an undefined behavior. cudaMemcpy2DAsync() returns an error
     if <tt>dpitch</tt> or <tt>spitch</tt> is greater than the maximum
     allowed.
   </p>
   <p>cudaMemcpy2DAsync() is asynchronous with
     respect to the host, so the call may return before the copy is complete.
     The copy can optionally be
     associated to a stream by passing a
     non-zero <tt>stream</tt> argument. If <tt>kind</tt> is
     cudaMemcpyHostToDevice or cudaMemcpyDeviceToHost and <tt>stream</tt>
     is non-zero, the copy may overlap with operations in other streams.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           asynchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination memory address<DD><CODE>dpitch</CODE> - Pitch of destination memory<DD><CODE>src</CODE> - Source memory address<DD><CODE>spitch</CODE> - Pitch of source memory<DD><CODE>width</CODE> - Width of matrix transfer (columns in bytes)<DD><CODE>height</CODE> - Height of matrix transfer (rows)<DD><CODE>kind</CODE> - Type of transfer<DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidPitchValue,
 cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpy2DToArrayAsync</H3>
<PRE>
public static int <B>cudaMemcpy2DToArrayAsync</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                                           long&nbsp;wOffset,
                                           long&nbsp;hOffset,
                                           <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                           long&nbsp;spitch,
                                           long&nbsp;width,
                                           long&nbsp;height,
                                           int&nbsp;cudaMemcpyKind_kind,
                                           <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Copies data between host and device.
 
 <pre>
 cudaError_t cudaMemcpy2DToArrayAsync (
      cudaArray_t dst,
      size_t wOffset,
      size_t hOffset,
      const void* src,
      size_t spitch,
      size_t width,
      size_t height,
      cudaMemcpyKind kind,
      cudaStream_t stream = 0 )
 </pre>
 <div>
   <p>Copies data between host and device. 
     Copies a matrix (<tt>height</tt> rows of <tt>width</tt> bytes each)
     from the memory area pointed to by <tt>src</tt> to the CUDA array <tt>dst</tt> starting at the upper left corner (<tt>wOffset</tt>, <tt>hOffset</tt>) where <tt>kind</tt> is one of cudaMemcpyHostToHost,
     cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost, or cudaMemcpyDeviceToDevice,
     and specifies the direction of the copy. <tt>spitch</tt> is the width
     in memory in bytes of the 2D array pointed to by <tt>src</tt>,
     including any padding added to the end of each row. <tt>wOffset</tt>
     + <tt>width</tt> must not exceed the width of the CUDA array <tt>dst</tt>. <tt>width</tt> must not exceed <tt>spitch</tt>.
     cudaMemcpy2DToArrayAsync() returns an error if <tt>spitch</tt> exceeds
     the maximum allowed.
   </p>
   <p>cudaMemcpy2DToArrayAsync() is asynchronous
     with respect to the host, so the call may return before the copy is
     complete. The copy can optionally be
     associated to a stream by passing a
     non-zero <tt>stream</tt> argument. If <tt>kind</tt> is
     cudaMemcpyHostToDevice or cudaMemcpyDeviceToHost and <tt>stream</tt>
     is non-zero, the copy may overlap with operations in other streams.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           asynchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination memory address<DD><CODE>wOffset</CODE> - Destination starting X offset<DD><CODE>hOffset</CODE> - Destination starting Y offset<DD><CODE>src</CODE> - Source memory address<DD><CODE>spitch</CODE> - Pitch of source memory<DD><CODE>width</CODE> - Width of matrix transfer (columns in bytes)<DD><CODE>height</CODE> - Height of matrix transfer (rows)<DD><CODE>kind</CODE> - Type of transfer<DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,
 cudaErrorInvalidPitchValue, cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpy2DFromArrayAsync</H3>
<PRE>
public static int <B>cudaMemcpy2DFromArrayAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                             long&nbsp;dpitch,
                                             <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                                             long&nbsp;wOffset,
                                             long&nbsp;hOffset,
                                             long&nbsp;width,
                                             long&nbsp;height,
                                             int&nbsp;cudaMemcpyKind_kind,
                                             <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Copies data between host and device.
 
 <pre>
 cudaError_t cudaMemcpy2DFromArrayAsync (
      void* dst,
      size_t dpitch,
      cudaArray_const_t src,
      size_t wOffset,
      size_t hOffset,
      size_t width,
      size_t height,
      cudaMemcpyKind kind,
      cudaStream_t stream = 0 )
 </pre>
 <div>
   <p>Copies data between host and device. 
     Copies a matrix (<tt>height</tt> rows of <tt>width</tt> bytes each)
     from the CUDA array <tt>srcArray</tt> starting at the upper left
     corner (<tt>wOffset</tt>, <tt>hOffset</tt>) to the memory area
     pointed to by <tt>dst</tt>, where <tt>kind</tt> is one of
     cudaMemcpyHostToHost, cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost,
     or cudaMemcpyDeviceToDevice, and specifies the direction of the copy.
     <tt>dpitch</tt> is the width in memory in bytes of the 2D array
     pointed to by <tt>dst</tt>, including any padding added to the end of
     each row. <tt>wOffset</tt> + <tt>width</tt> must not exceed the width
     of the CUDA array <tt>src</tt>. <tt>width</tt> must not exceed <tt>dpitch</tt>. cudaMemcpy2DFromArrayAsync() returns an error if <tt>dpitch</tt> exceeds the maximum allowed.
   </p>
   <p>cudaMemcpy2DFromArrayAsync() is
     asynchronous with respect to the host, so the call may return before
     the copy is complete. The copy can optionally be
     associated to a stream by passing a
     non-zero <tt>stream</tt> argument. If <tt>kind</tt> is
     cudaMemcpyHostToDevice or cudaMemcpyDeviceToHost and <tt>stream</tt>
     is non-zero, the copy may overlap with operations in other streams.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           asynchronous behavior for most use cases.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination memory address<DD><CODE>dpitch</CODE> - Pitch of destination memory<DD><CODE>src</CODE> - Source memory address<DD><CODE>wOffset</CODE> - Source starting X offset<DD><CODE>hOffset</CODE> - Source starting Y offset<DD><CODE>width</CODE> - Width of matrix transfer (columns in bytes)<DD><CODE>height</CODE> - Height of matrix transfer (rows)<DD><CODE>kind</CODE> - Type of transfer<DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,
 cudaErrorInvalidPitchValue, cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpyToSymbolAsync</H3>
<PRE>
public static int <B>cudaMemcpyToSymbolAsync</B>(java.lang.String&nbsp;symbol,
                                          <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                          long&nbsp;count,
                                          long&nbsp;offset,
                                          int&nbsp;cudaMemcpyKind_kind,
                                          <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>[C++ API] Copies data to the given symbol on the device
 
 <pre>
 template < class T > cudaError_t cudaMemcpyToSymbolAsync (
      const T& symbol,
      const void* src,
      size_t count,
      size_t offset = 0,
      cudaMemcpyKind kind = cudaMemcpyHostToDevice,
      cudaStream_t stream = 0 ) [inline]
 </pre>
 <div>
   <p>[C++ API] Copies data to the given symbol
     on the device  Copies <tt>count</tt> bytes from the memory area
     pointed to by <tt>src</tt> to the memory area <tt>offset</tt> bytes
     from the start of symbol <tt>symbol</tt>. The memory areas may not
     overlap. <tt>symbol</tt> is a variable that resides in global or
     constant memory space. <tt>kind</tt> can be either cudaMemcpyHostToDevice
     or cudaMemcpyDeviceToDevice.
   </p>
   <p>cudaMemcpyToSymbolAsync() is asynchronous
     with respect to the host, so the call may return before the copy is
     complete. The copy can optionally be
     associated to a stream by passing a
     non-zero <tt>stream</tt> argument. If <tt>kind</tt> is
     cudaMemcpyHostToDevice and <tt>stream</tt> is non-zero, the copy may
     overlap with operations in other streams.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           asynchronous behavior for most use cases. 
         </p>
       </li>
       <li>
         <p>Use of a string naming a
           variable as the <tt>symbol</tt> paramater was deprecated in CUDA 4.1
           and removed in CUDA 5.0.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>symbol</CODE> - Device symbol address<DD><CODE>src</CODE> - Source memory address<DD><CODE>count</CODE> - Size in bytes to copy<DD><CODE>offset</CODE> - Offset from start of symbol in bytes<DD><CODE>kind</CODE> - Type of transfer<DD><CODE>stream</CODE> - Stream identifier<DD><CODE>symbol</CODE> - Device symbol reference<DD><CODE>src</CODE> - Source memory address<DD><CODE>count</CODE> - Size in bytes to copy<DD><CODE>offset</CODE> - Offset from start of symbol in bytes<DD><CODE>kind</CODE> - Type of transfer<DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidSymbol,
 cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpyFromSymbolAsync</H3>
<PRE>
public static int <B>cudaMemcpyFromSymbolAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                            java.lang.String&nbsp;symbol,
                                            long&nbsp;count,
                                            long&nbsp;offset,
                                            int&nbsp;cudaMemcpyKind_kind,
                                            <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>[C++ API] Copies data from the given symbol on the device
 
 <pre>
 template < class T > cudaError_t cudaMemcpyFromSymbolAsync (
      void* dst,
      const T& symbol,
      size_t count,
      size_t offset = 0,
      cudaMemcpyKind kind = cudaMemcpyDeviceToHost,
      cudaStream_t stream = 0 ) [inline]
 </pre>
 <div>
   <p>[C++ API] Copies data from the given
     symbol on the device  Copies <tt>count</tt> bytes from the memory area
     <tt>offset</tt> bytes from the start of symbol <tt>symbol</tt> to
     the memory area pointed to by <tt>dst</tt>. The memory areas may not
     overlap. <tt>symbol</tt> is a variable that resides in global or
     constant memory space. <tt>kind</tt> can be either cudaMemcpyDeviceToHost
     or cudaMemcpyDeviceToDevice.
   </p>
   <p>cudaMemcpyFromSymbolAsync() is
     asynchronous with respect to the host, so the call may return before
     the copy is complete. The copy can optionally be
     associated to a stream by passing a
     non-zero <tt>stream</tt> argument. If <tt>kind</tt> is
     cudaMemcpyDeviceToHost and <tt>stream</tt> is non-zero, the copy may
     overlap with operations in other streams.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>This function exhibits
           asynchronous behavior for most use cases. 
         </p>
       </li>
       <li>
         <p>Use of a string naming a
           variable as the <tt>symbol</tt> paramater was deprecated in CUDA 4.1
           and removed in CUDA 5.0.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - Destination memory address<DD><CODE>symbol</CODE> - Device symbol address<DD><CODE>count</CODE> - Size in bytes to copy<DD><CODE>offset</CODE> - Offset from start of symbol in bytes<DD><CODE>kind</CODE> - Type of transfer<DD><CODE>stream</CODE> - Stream identifier<DD><CODE>dst</CODE> - Destination memory address<DD><CODE>symbol</CODE> - Device symbol reference<DD><CODE>count</CODE> - Size in bytes to copy<DD><CODE>offset</CODE> - Offset from start of symbol in bytes<DD><CODE>kind</CODE> - Type of transfer<DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidSymbol,
 cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><CODE>cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemset(jcuda.Pointer, int, long)"><!-- --></A><H3>
cudaMemset</H3>
<PRE>
public static int <B>cudaMemset</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;mem,
                             int&nbsp;c,
                             long&nbsp;count)</PRE>
<DL>
<DD>Initializes or sets device memory to a value.
 
 <pre>
 cudaError_t cudaMemset (
      void* devPtr,
      int  value,
      size_t count )
 </pre>
 <div>
   <p>Initializes or sets device memory to a
     value.  Fills the first <tt>count</tt> bytes of the memory area
     pointed to by <tt>devPtr</tt> with the constant byte value <tt>value</tt>.
   </p>
   <p>Note that this function is asynchronous
     with respect to the host unless <tt>devPtr</tt> refers to pinned host
     memory.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>devPtr</CODE> - Pointer to device memory<DD><CODE>value</CODE> - Value to set for each byte of specified memory<DD><CODE>count</CODE> - Size in bytes to set
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue,
 cudaErrorInvalidDevicePointer<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemset2D(jcuda.Pointer, long, int, long, long)"><CODE>cudaMemset2D(jcuda.Pointer, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)"><CODE>cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemsetAsync(jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)"><CODE>cudaMemsetAsync(jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset2DAsync(jcuda.Pointer, long, int, long, long, jcuda.runtime.cudaStream_t)"><CODE>cudaMemset2DAsync(jcuda.Pointer, long, int, long, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3DAsync(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent, jcuda.runtime.cudaStream_t)"><CODE>cudaMemset3DAsync(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemset2D(jcuda.Pointer, long, int, long, long)"><!-- --></A><H3>
cudaMemset2D</H3>
<PRE>
public static int <B>cudaMemset2D</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;mem,
                               long&nbsp;pitch,
                               int&nbsp;c,
                               long&nbsp;width,
                               long&nbsp;height)</PRE>
<DL>
<DD>Initializes or sets device memory to a value.
 
 <pre>
 cudaError_t cudaMemset2D (
      void* devPtr,
      size_t pitch,
      int  value,
      size_t width,
      size_t height )
 </pre>
 <div>
   <p>Initializes or sets device memory to a
     value.  Sets to the specified value <tt>value</tt> a matrix (<tt>height</tt> rows of <tt>width</tt> bytes each) pointed to by <tt>dstPtr</tt>. <tt>pitch</tt> is the width in bytes of the 2D array
     pointed to by <tt>dstPtr</tt>, including any padding added to the end
     of each row. This function performs fastest when the pitch is one that
     has been passed
     back by cudaMallocPitch().
   </p>
   <p>Note that this function is asynchronous
     with respect to the host unless <tt>devPtr</tt> refers to pinned host
     memory.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>devPtr</CODE> - Pointer to 2D device memory<DD><CODE>pitch</CODE> - Pitch in bytes of 2D device memory<DD><CODE>value</CODE> - Value to set for each byte of specified memory<DD><CODE>width</CODE> - Width of matrix set (columns in bytes)<DD><CODE>height</CODE> - Height of matrix set (rows)
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue,
 cudaErrorInvalidDevicePointer<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemset(jcuda.Pointer, int, long)"><CODE>cudaMemset(jcuda.Pointer, int, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)"><CODE>cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemsetAsync(jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)"><CODE>cudaMemsetAsync(jcuda.Pointer, int, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset2DAsync(jcuda.Pointer, long, int, long, long, jcuda.runtime.cudaStream_t)"><CODE>cudaMemset2DAsync(jcuda.Pointer, long, int, long, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3DAsync(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent, jcuda.runtime.cudaStream_t)"><CODE>cudaMemset3DAsync(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)"><!-- --></A><H3>
cudaGetChannelDesc</H3>
<PRE>
public static int <B>cudaGetChannelDesc</B>(<A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                                     <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array)</PRE>
<DL>
<DD>Get the channel descriptor of an array.
 
 <pre>
 cudaError_t cudaGetChannelDesc (
      cudaChannelFormatDesc* desc,
      cudaArray_const_t array )
 </pre>
 <div>
   <p>Get the channel descriptor of an array. 
     Returns in <tt>*desc</tt> the channel descriptor of the CUDA array
     <tt>array</tt>.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>desc</CODE> - Channel format<DD><CODE>array</CODE> - Memory array on device
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateChannelDesc(int, int, int, int, int)"><CODE>cudaCreateChannelDesc(int, int, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)"><CODE>cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><CODE>cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaUnbindTexture(jcuda.runtime.textureReference)"><CODE>cudaUnbindTexture(jcuda.runtime.textureReference)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)"><CODE>cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaCreateChannelDesc(int, int, int, int, int)"><!-- --></A><H3>
cudaCreateChannelDesc</H3>
<PRE>
public static <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A> <B>cudaCreateChannelDesc</B>(int&nbsp;x,
                                                          int&nbsp;y,
                                                          int&nbsp;z,
                                                          int&nbsp;w,
                                                          int&nbsp;cudaChannelFormatKind_f)</PRE>
<DL>
<DD>[C++ API] Returns a channel descriptor using the specified format
 
 <pre>
 template < class T > cudaChannelFormatDesc cudaCreateChannelDesc (
      void ) [inline]
 </pre>
 <div>
   <p>[C++ API] Returns a channel descriptor
     using the specified format  Returns a channel descriptor with format
     <tt>f</tt> and number of bits of each component <tt>x</tt>, <tt>y</tt>, <tt>z</tt>, and <tt>w</tt>. The cudaChannelFormatDesc is
     defined as: 
   <pre>  struct cudaChannelFormatDesc {
     int x, y, z, w;
     enum cudaChannelFormatKind 
                   f;
   };</pre>
   </p>
   <p>where cudaChannelFormatKind is one of
     cudaChannelFormatKindSigned, cudaChannelFormatKindUnsigned, or
     cudaChannelFormatKindFloat.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - X component<DD><CODE>y</CODE> - Y component<DD><CODE>z</CODE> - Z component<DD><CODE>w</CODE> - W component<DD><CODE>f</CODE> - Channel format
<DT><B>Returns:</B><DD>Channel descriptor with format f<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateChannelDesc(int, int, int, int, int)"><CODE>cudaCreateChannelDesc(int, int, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)"><CODE>cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)"><CODE>cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><CODE>cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaUnbindTexture(jcuda.runtime.textureReference)"><CODE>cudaUnbindTexture(jcuda.runtime.textureReference)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)"><CODE>cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetLastError()"><!-- --></A><H3>
cudaGetLastError</H3>
<PRE>
public static int <B>cudaGetLastError</B>()</PRE>
<DL>
<DD>Returns the last error from a runtime call.
 
 <pre>
 cudaError_t cudaGetLastError (
      void )
 </pre>
 <div>
   <p>Returns the last error from a runtime
     call.  Returns the last error that has been produced by any of the
     runtime calls in
     the same host thread and resets it to
     cudaSuccess.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMissingConfiguration,
 cudaErrorMemoryAllocation, cudaErrorInitializationError,
 cudaErrorLaunchFailure, cudaErrorLaunchTimeout,
 cudaErrorLaunchOutOfResources, cudaErrorInvalidDeviceFunction,
 cudaErrorInvalidConfiguration, cudaErrorInvalidDevice,
 cudaErrorInvalidValue, cudaErrorInvalidPitchValue, cudaErrorInvalidSymbol,
 cudaErrorUnmapBufferObjectFailed, cudaErrorInvalidHostPointer,
 cudaErrorInvalidDevicePointer, cudaErrorInvalidTexture,
 cudaErrorInvalidTextureBinding, cudaErrorInvalidChannelDescriptor,
 cudaErrorInvalidMemcpyDirection, cudaErrorInvalidFilterSetting,
 cudaErrorInvalidNormSetting, cudaErrorUnknown,
 cudaErrorInvalidResourceHandle, cudaErrorInsufficientDriver,
 cudaErrorSetOnActiveProcess, cudaErrorStartupFailure,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaPeekAtLastError()"><CODE>cudaPeekAtLastError()</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetErrorString(int)"><CODE>cudaGetErrorString(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaPeekAtLastError()"><!-- --></A><H3>
cudaPeekAtLastError</H3>
<PRE>
public static int <B>cudaPeekAtLastError</B>()</PRE>
<DL>
<DD>Returns the last error from a runtime call.
 
 <pre>
 cudaError_t cudaPeekAtLastError (
      void )
 </pre>
 <div>
   <p>Returns the last error from a runtime
     call.  Returns the last error that has been produced by any of the
     runtime calls in
     the same host thread. Note that this call
     does not reset the error to cudaSuccess like cudaGetLastError().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMissingConfiguration,
 cudaErrorMemoryAllocation, cudaErrorInitializationError,
 cudaErrorLaunchFailure, cudaErrorLaunchTimeout,
 cudaErrorLaunchOutOfResources, cudaErrorInvalidDeviceFunction,
 cudaErrorInvalidConfiguration, cudaErrorInvalidDevice,
 cudaErrorInvalidValue, cudaErrorInvalidPitchValue, cudaErrorInvalidSymbol,
 cudaErrorUnmapBufferObjectFailed, cudaErrorInvalidHostPointer,
 cudaErrorInvalidDevicePointer, cudaErrorInvalidTexture,
 cudaErrorInvalidTextureBinding, cudaErrorInvalidChannelDescriptor,
 cudaErrorInvalidMemcpyDirection, cudaErrorInvalidFilterSetting,
 cudaErrorInvalidNormSetting, cudaErrorUnknown,
 cudaErrorInvalidResourceHandle, cudaErrorInsufficientDriver,
 cudaErrorSetOnActiveProcess, cudaErrorStartupFailure,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetLastError()"><CODE>cudaGetLastError()</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetErrorString(int)"><CODE>cudaGetErrorString(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetErrorString(int)"><!-- --></A><H3>
cudaGetErrorString</H3>
<PRE>
public static java.lang.String <B>cudaGetErrorString</B>(int&nbsp;error)</PRE>
<DL>
<DD>Returns the message string from an error code.

 <div>
   <div>
     <table>
       <tr>
         <td>const char* cudaGetErrorString           </td>
         <td>(</td>
         <td>cudaError_t&nbsp;</td>
         <td> <em>error</em>          </td>
         <td>&nbsp;)&nbsp;</td>
         <td></td>
       </tr>
     </table>
   </div>
   <div>
     <p>
       Returns the message string from an error code.
     <p>
   </div>
 </div>
<P>
<DD><DL>

<DT><B>Returns:</B><DD><code>char*</code> pointer to a NULL-terminated string<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetLastError()"><CODE>cudaGetLastError()</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaPeekAtLastError()"><CODE>cudaPeekAtLastError()</CODE></A>, 
<A HREF="../../jcuda/runtime/cudaError.html" title="class in jcuda.runtime"><CODE>cudaError</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaStreamCreate(jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaStreamCreate</H3>
<PRE>
public static int <B>cudaStreamCreate</B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Create an asynchronous stream.
 
 <pre>
 cudaError_t cudaStreamCreate (
      cudaStream_t* pStream )
 </pre>
 <div>
   <p>Create an asynchronous stream.  Creates
     a new asynchronous stream.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pStream</CODE> - Pointer to new stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreate(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamCreate(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreateWithFlags(jcuda.runtime.cudaStream_t, int)"><CODE>cudaStreamCreateWithFlags(jcuda.runtime.cudaStream_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamQuery(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamQuery(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamSynchronize(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamSynchronize(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)"><CODE>cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamAddCallback(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaStreamCallback, java.lang.Object, int)"><CODE>cudaStreamAddCallback(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaStreamCallback, java.lang.Object, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamDestroy(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamDestroy(jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaStreamCreateWithFlags(jcuda.runtime.cudaStream_t, int)"><!-- --></A><H3>
cudaStreamCreateWithFlags</H3>
<PRE>
public static int <B>cudaStreamCreateWithFlags</B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;pStream,
                                            int&nbsp;flags)</PRE>
<DL>
<DD>Create an asynchronous stream.
 
 <pre>
 cudaError_t cudaStreamCreateWithFlags (
      cudaStream_t* pStream,
      unsigned int  flags )
 </pre>
 <div>
   <p>Create an asynchronous stream.  Creates
     a new asynchronous stream. The <tt>flags</tt> argument determines the
     behaviors of the stream. Valid values for <tt>flags</tt> are
   <ul>
     <li>
       <p>cudaStreamDefault: Default
         stream creation flag.
       </p>
     </li>
     <li>
       <p>cudaStreamNonBlocking: Specifies
         that work running in the created stream may run concurrently with work
         in stream 0 (the NULL stream), and that
         the created stream should
         perform no implicit synchronization with stream 0.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pStream</CODE> - Pointer to new stream identifier<DD><CODE>flags</CODE> - Parameters for stream creation
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreate(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamCreate(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamQuery(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamQuery(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamSynchronize(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamSynchronize(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)"><CODE>cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamAddCallback(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaStreamCallback, java.lang.Object, int)"><CODE>cudaStreamAddCallback(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaStreamCallback, java.lang.Object, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamDestroy(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamDestroy(jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaStreamDestroy(jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaStreamDestroy</H3>
<PRE>
public static int <B>cudaStreamDestroy</B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Destroys and cleans up an asynchronous stream.
 
 <pre>
 cudaError_t cudaStreamDestroy (
      cudaStream_t stream )
 </pre>
 <div>
   <p>Destroys and cleans up an asynchronous
     stream.  Destroys and cleans up the asynchronous stream specified by
     <tt>stream</tt>.
   </p>
   <p>In case the device is still doing work
     in the stream <tt>stream</tt> when cudaStreamDestroy() is called, the
     function will return immediately and the resources associated with <tt>stream</tt> will be released automatically once the device has
     completed all work in <tt>stream</tt>.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidResourceHandle<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreate(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamCreate(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreateWithFlags(jcuda.runtime.cudaStream_t, int)"><CODE>cudaStreamCreateWithFlags(jcuda.runtime.cudaStream_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamQuery(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamQuery(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)"><CODE>cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamSynchronize(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamSynchronize(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamAddCallback(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaStreamCallback, java.lang.Object, int)"><CODE>cudaStreamAddCallback(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaStreamCallback, java.lang.Object, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)"><!-- --></A><H3>
cudaStreamWaitEvent</H3>
<PRE>
public static int <B>cudaStreamWaitEvent</B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream,
                                      <A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event,
                                      int&nbsp;flags)</PRE>
<DL>
<DD>Make a compute stream wait on an event.
 
 <pre>
 cudaError_t cudaStreamWaitEvent (
      cudaStream_t stream,
      cudaEvent_t event,
      unsigned int  flags )
 </pre>
 <div>
   <p>Make a compute stream wait on an event. 
     Makes all future work submitted to <tt>stream</tt> wait until <tt>event</tt> reports completion before beginning execution. This
     synchronization will be performed efficiently on the device. The event
     <tt>event</tt> may be from a different
     context than <tt>stream</tt>, in which case this function will perform
     cross-device synchronization.
   </p>
   <p>The stream <tt>stream</tt> will wait
     only for the completion of the most recent host call to cudaEventRecord()
     on <tt>event</tt>. Once this call has returned, any functions
     (including cudaEventRecord() and cudaEventDestroy()) may be called on
     <tt>event</tt> again, and the subsequent calls will not have any
     effect on <tt>stream</tt>.
   </p>
   <p>If <tt>stream</tt> is NULL, any future
     work submitted in any stream will wait for <tt>event</tt> to complete
     before beginning execution. This effectively creates a barrier for all
     future work submitted to the device on
     this thread.
   </p>
   <p>If cudaEventRecord() has not been called
     on <tt>event</tt>, this call acts as if the record has already
     completed, and so is a functional no-op.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - Stream to wait<DD><CODE>event</CODE> - Event to wait on<DD><CODE>flags</CODE> - Parameters for the operation (must be 0)
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidResourceHandle<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreate(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamCreate(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreateWithFlags(jcuda.runtime.cudaStream_t, int)"><CODE>cudaStreamCreateWithFlags(jcuda.runtime.cudaStream_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamQuery(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamQuery(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamSynchronize(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamSynchronize(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamAddCallback(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaStreamCallback, java.lang.Object, int)"><CODE>cudaStreamAddCallback(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaStreamCallback, java.lang.Object, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamDestroy(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamDestroy(jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaStreamAddCallback(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaStreamCallback, java.lang.Object, int)"><!-- --></A><H3>
cudaStreamAddCallback</H3>
<PRE>
public static int <B>cudaStreamAddCallback</B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream,
                                        <A HREF="../../jcuda/runtime/cudaStreamCallback.html" title="interface in jcuda.runtime">cudaStreamCallback</A>&nbsp;callback,
                                        java.lang.Object&nbsp;userData,
                                        int&nbsp;flags)</PRE>
<DL>
<DD>Add a callback to a compute stream.
 
 <pre>
 cudaError_t cudaStreamAddCallback (
      cudaStream_t stream,
      cudaStreamCallback_t callback,
      void* userData,
      unsigned int  flags )
 </pre>
 <div>
   <p>Add a callback to a compute stream.  Adds
     a callback to be called on the host after all currently enqueued items
     in the stream
     have completed. For each
     cudaStreamAddCallback call, a callback will be executed exactly once.
     The callback will block later
     work in the stream until it is finished.
   </p>
   <p>The callback may be passed cudaSuccess
     or an error code. In the event of a device error, all subsequently
     executed callbacks will receive an appropriate cudaError_t.
   </p>
   <p>Callbacks must not make any CUDA API
     calls. Attempting to use CUDA APIs will result in cudaErrorNotPermitted.
     Callbacks must not perform any synchronization that may depend on
     outstanding device work or other callbacks that are not
     mandated to run earlier. Callbacks
     without a mandated order (in independent streams) execute in undefined
     order and may be
     serialized.
   </p>
   <p>This API requires compute capability
     1.1 or greater. See cudaDeviceGetAttribute or cudaGetDeviceProperties
     to query compute capability. Calling this API with an earlier compute
     version will return cudaErrorNotSupported.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - Stream to add callback to<DD><CODE>callback</CODE> - The function to call once preceding stream operations are complete<DD><CODE>userData</CODE> - User specified data to be passed to the callback function<DD><CODE>flags</CODE> - Reserved for future use, must be 0
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidResourceHandle,
 cudaErrorNotSupported<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreate(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamCreate(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreateWithFlags(jcuda.runtime.cudaStream_t, int)"><CODE>cudaStreamCreateWithFlags(jcuda.runtime.cudaStream_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamQuery(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamQuery(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamSynchronize(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamSynchronize(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)"><CODE>cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamDestroy(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamDestroy(jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaStreamSynchronize(jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaStreamSynchronize</H3>
<PRE>
public static int <B>cudaStreamSynchronize</B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Waits for stream tasks to complete.
 
 <pre>
 cudaError_t cudaStreamSynchronize (
      cudaStream_t stream )
 </pre>
 <div>
   <p>Waits for stream tasks to complete. 
     Blocks until <tt>stream</tt> has completed all operations. If the
     cudaDeviceScheduleBlockingSync flag was set for this device, the host
     thread will block until the stream is finished with all of its tasks.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidResourceHandle<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreate(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamCreate(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreateWithFlags(jcuda.runtime.cudaStream_t, int)"><CODE>cudaStreamCreateWithFlags(jcuda.runtime.cudaStream_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamQuery(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamQuery(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)"><CODE>cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamAddCallback(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaStreamCallback, java.lang.Object, int)"><CODE>cudaStreamAddCallback(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaStreamCallback, java.lang.Object, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamDestroy(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamDestroy(jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaStreamQuery(jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaStreamQuery</H3>
<PRE>
public static int <B>cudaStreamQuery</B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Queries an asynchronous stream for completion status.
 
 <pre>
 cudaError_t cudaStreamQuery (
      cudaStream_t stream )
 </pre>
 <div>
   <p>Queries an asynchronous stream for
     completion status.  Returns cudaSuccess if all operations in <tt>stream</tt> have completed, or cudaErrorNotReady if not.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorNotReady, cudaErrorInvalidResourceHandle<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreate(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamCreate(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreateWithFlags(jcuda.runtime.cudaStream_t, int)"><CODE>cudaStreamCreateWithFlags(jcuda.runtime.cudaStream_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)"><CODE>cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamSynchronize(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamSynchronize(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamAddCallback(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaStreamCallback, java.lang.Object, int)"><CODE>cudaStreamAddCallback(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaStreamCallback, java.lang.Object, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamDestroy(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamDestroy(jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaEventCreate(jcuda.runtime.cudaEvent_t)"><!-- --></A><H3>
cudaEventCreate</H3>
<PRE>
public static int <B>cudaEventCreate</B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</PRE>
<DL>
<DD>[C++ API] Creates an event object with the specified flags
 
 <pre>
 cudaError_t cudaEventCreate (
      cudaEvent_t* event,
      unsigned int  flags )
 </pre>
 <div>
   <p>[C++ API] Creates an event object with
     the specified flags  Creates an event object with the specified flags.
     Valid flags
     include:
   <ul>
     <li>
       <p>cudaEventDefault: Default event
         creation flag.
       </p>
     </li>
     <li>
       <p>cudaEventBlockingSync: Specifies
         that event should use blocking synchronization. A host thread that uses
         cudaEventSynchronize() to wait on an event created with this flag will
         block until the event actually completes.
       </p>
     </li>
     <li>
       <p>cudaEventDisableTiming:
         Specifies that the created event does not need to record timing data.
         Events created with this flag specified and the cudaEventBlockingSync
         flag not specified will provide the best performance when used with
         cudaStreamWaitEvent() and cudaEventQuery().
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>event</CODE> - Newly created event<DD><CODE>event</CODE> - Newly created event<DD><CODE>flags</CODE> - Flags for new event
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError, cudaErrorInvalidValue,
 cudaErrorLaunchFailure, cudaErrorMemoryAllocation<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreate(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventCreate(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)"><CODE>cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)"><CODE>cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventQuery(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventQuery(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventSynchronize(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventSynchronize(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventDestroy(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventDestroy(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)"><CODE>cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)"><CODE>cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)"><!-- --></A><H3>
cudaEventCreateWithFlags</H3>
<PRE>
public static int <B>cudaEventCreateWithFlags</B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event,
                                           int&nbsp;flags)</PRE>
<DL>
<DD>Creates an event object with the specified flags.
 
 <pre>
 cudaError_t cudaEventCreateWithFlags (
      cudaEvent_t* event,
      unsigned int  flags )
 </pre>
 <div>
   <p>Creates an event object with the specified
     flags.  Creates an event object with the specified flags. Valid flags
     include:
   <ul>
     <li>
       <p>cudaEventDefault: Default event
         creation flag.
       </p>
     </li>
     <li>
       <p>cudaEventBlockingSync: Specifies
         that event should use blocking synchronization. A host thread that uses
         cudaEventSynchronize() to wait on an event created with this flag will
         block until the event actually completes.
       </p>
     </li>
     <li>
       <p>cudaEventDisableTiming:
         Specifies that the created event does not need to record timing data.
         Events created with this flag specified and the cudaEventBlockingSync
         flag not specified will provide the best performance when used with
         cudaStreamWaitEvent() and cudaEventQuery().
       </p>
     </li>
     <li>
       <p>cudaEventInterprocess: Specifies
         that the created event may be used as an interprocess event by
         cudaIpcGetEventHandle(). cudaEventInterprocess must be specified along
         with cudaEventDisableTiming.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>event</CODE> - Newly created event<DD><CODE>flags</CODE> - Flags for new event
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError, cudaErrorInvalidValue,
 cudaErrorLaunchFailure, cudaErrorMemoryAllocation<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreate(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventCreate(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventSynchronize(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventSynchronize(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventDestroy(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventDestroy(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)"><CODE>cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)"><CODE>cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaEventRecord</H3>
<PRE>
public static int <B>cudaEventRecord</B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event,
                                  <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Records an event.
 
 <pre>
 cudaError_t cudaEventRecord (
      cudaEvent_t event,
      cudaStream_t stream = 0 )
 </pre>
 <div>
   <p>Records an event.  Records an event. If
     <tt>stream</tt> is non-zero, the event is recorded after all preceding
     operations in <tt>stream</tt> have been completed; otherwise, it is
     recorded after all preceding operations in the CUDA context have been
     completed. Since
     operation is asynchronous, cudaEventQuery()
     and/or cudaEventSynchronize() must be used to determine when the event
     has actually been recorded.
   </p>
   <p>If cudaEventRecord() has previously been
     called on <tt>event</tt>, then this call will overwrite any existing
     state in <tt>event</tt>. Any subsequent calls which examine the status
     of <tt>event</tt> will only examine the completion of this most recent
     call to cudaEventRecord().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>event</CODE> - Event to record<DD><CODE>stream</CODE> - Stream in which to record event
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInitializationError,
 cudaErrorInvalidResourceHandle, cudaErrorLaunchFailure<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreate(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventCreate(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)"><CODE>cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventQuery(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventQuery(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventSynchronize(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventSynchronize(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventDestroy(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventDestroy(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)"><CODE>cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)"><CODE>cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaEventQuery(jcuda.runtime.cudaEvent_t)"><!-- --></A><H3>
cudaEventQuery</H3>
<PRE>
public static int <B>cudaEventQuery</B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</PRE>
<DL>
<DD>Queries an event's status.
 
 <pre>
 cudaError_t cudaEventQuery (
      cudaEvent_t event )
 </pre>
 <div>
   <p>Queries an event's status.  Query the
     status of all device work preceding the most recent call to
     cudaEventRecord() (in the appropriate compute streams, as specified by
     the arguments to cudaEventRecord()).
   </p>
   <p>If this work has successfully been
     completed by the device, or if cudaEventRecord() has not been called
     on <tt>event</tt>, then cudaSuccess is returned. If this work has not
     yet been completed by the device then cudaErrorNotReady is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>event</CODE> - Event to query
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorNotReady, cudaErrorInitializationError,
 cudaErrorInvalidValue, cudaErrorInvalidResourceHandle,
 cudaErrorLaunchFailure<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreate(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventCreate(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)"><CODE>cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)"><CODE>cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventSynchronize(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventSynchronize(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventDestroy(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventDestroy(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)"><CODE>cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaEventSynchronize(jcuda.runtime.cudaEvent_t)"><!-- --></A><H3>
cudaEventSynchronize</H3>
<PRE>
public static int <B>cudaEventSynchronize</B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</PRE>
<DL>
<DD>Waits for an event to complete.
 
 <pre>
 cudaError_t cudaEventSynchronize (
      cudaEvent_t event )
 </pre>
 <div>
   <p>Waits for an event to complete.  Wait
     until the completion of all device work preceding the most recent call
     to cudaEventRecord() (in the appropriate compute streams, as specified
     by the arguments to cudaEventRecord()).
   </p>
   <p>If cudaEventRecord() has not been called
     on <tt>event</tt>, cudaSuccess is returned immediately.
   </p>
   <p>Waiting for an event that was created
     with the cudaEventBlockingSync flag will cause the calling CPU thread
     to block until the event has been completed by the device. If the
     cudaEventBlockingSync flag has not been set, then the CPU thread will
     busy-wait until the event has been completed by the device.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>event</CODE> - Event to wait for
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError, cudaErrorInvalidValue,
 cudaErrorInvalidResourceHandle, cudaErrorLaunchFailure<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreate(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventCreate(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)"><CODE>cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)"><CODE>cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventQuery(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventQuery(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventDestroy(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventDestroy(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)"><CODE>cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaEventDestroy(jcuda.runtime.cudaEvent_t)"><!-- --></A><H3>
cudaEventDestroy</H3>
<PRE>
public static int <B>cudaEventDestroy</B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</PRE>
<DL>
<DD>Destroys an event object.
 
 <pre>
 cudaError_t cudaEventDestroy (
      cudaEvent_t event )
 </pre>
 <div>
   <p>Destroys an event object.  Destroys the
     event specified by <tt>event</tt>.
   </p>
   <p>In case <tt>event</tt> has been recorded
     but has not yet been completed when cudaEventDestroy() is called, the
     function will return immediately and the resources associated with <tt>event</tt> will be released automatically once the device has completed
     <tt>event</tt>.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>event</CODE> - Event to destroy
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError, cudaErrorInvalidValue,
 cudaErrorLaunchFailure<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreate(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventCreate(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)"><CODE>cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventQuery(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventQuery(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventSynchronize(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventSynchronize(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)"><CODE>cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)"><CODE>cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)"><!-- --></A><H3>
cudaEventElapsedTime</H3>
<PRE>
public static int <B>cudaEventElapsedTime</B>(float[]&nbsp;ms,
                                       <A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;start,
                                       <A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;end)</PRE>
<DL>
<DD>Computes the elapsed time between events.
 
 <pre>
 cudaError_t cudaEventElapsedTime (
      float* ms,
      cudaEvent_t start,
      cudaEvent_t end )
 </pre>
 <div>
   <p>Computes the elapsed time between events.
     Computes the elapsed time between two events (in milliseconds with a
     resolution
     of around 0.5 microseconds).
   </p>
   <p>If either event was last recorded in a
     non-NULL stream, the resulting time may be greater than expected (even
     if both used
     the same stream handle). This happens
     because the cudaEventRecord() operation takes place asynchronously and
     there is no guarantee that the measured latency is actually just
     between the two
     events. Any number of other different
     stream operations could execute in between the two measured events,
     thus altering the
     timing in a significant way.
   </p>
   <p>If cudaEventRecord() has not been called
     on either event, then cudaErrorInvalidResourceHandle is returned. If
     cudaEventRecord() has been called on both events but one or both of
     them has not yet been completed (that is, cudaEventQuery() would return
     cudaErrorNotReady on at least one of the events), cudaErrorNotReady is
     returned. If either event was created with the cudaEventDisableTiming
     flag, then this function will return cudaErrorInvalidResourceHandle.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ms</CODE> - Time between start and end in ms<DD><CODE>start</CODE> - Starting event<DD><CODE>end</CODE> - Ending event
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorNotReady, cudaErrorInvalidValue,
 cudaErrorInitializationError, cudaErrorInvalidResourceHandle,
 cudaErrorLaunchFailure<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreate(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventCreate(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)"><CODE>cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventQuery(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventQuery(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventSynchronize(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventSynchronize(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventDestroy(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventDestroy(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)"><CODE>cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDeviceReset()"><!-- --></A><H3>
cudaDeviceReset</H3>
<PRE>
public static int <B>cudaDeviceReset</B>()</PRE>
<DL>
<DD>Destroy all allocations and reset all state on the current device in the current process.
 
 <pre>
 cudaError_t cudaDeviceReset (
      void )
 </pre>
 <div>
   <p>Destroy all allocations and reset all
     state on the current device in the current process.  Explicitly destroys
     and cleans
     up all resources associated with the
     current device in the current process. Any subsequent API call to this
     device will reinitialize
     the device.
   </p>
   <p>Note that this function will reset the
     device immediately. It is the caller's responsibility to ensure that
     the device is
     not being accessed by any other host
     threads from the process when this function is called.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSynchronize()"><CODE>cudaDeviceSynchronize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDeviceSynchronize()"><!-- --></A><H3>
cudaDeviceSynchronize</H3>
<PRE>
public static int <B>cudaDeviceSynchronize</B>()</PRE>
<DL>
<DD>Wait for compute device to finish.
 
 <pre>
 cudaError_t cudaDeviceSynchronize (
      void )
 </pre>
 <div>
   <p>Wait for compute device to finish. 
     Blocks until the device has completed all preceding requested tasks.
     cudaDeviceSynchronize() returns an error if one of the preceding tasks
     has failed. If the cudaDeviceScheduleBlockingSync flag was set for this
     device, the host thread will block until the device has finished its
     work.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceReset()"><CODE>cudaDeviceReset()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDeviceSetLimit(int, long)"><!-- --></A><H3>
cudaDeviceSetLimit</H3>
<PRE>
public static int <B>cudaDeviceSetLimit</B>(int&nbsp;limit,
                                     long&nbsp;value)</PRE>
<DL>
<DD>Set resource limits.
 
 <pre>
 cudaError_t cudaDeviceSetLimit (
      cudaLimit limit,
      size_t value )
 </pre>
 <div>
   <p>Set resource limits.  Setting <tt>limit</tt> to <tt>value</tt> is a request by the application to
     update the current limit maintained by the device. The driver is free
     to modify the requested
     value to meet h/w requirements (this
     could be clamping to minimum or maximum values, rounding up to nearest
     element size,
     etc). The application can use
     cudaDeviceGetLimit() to find out exactly what the limit has been set
     to.
   </p>
   <p>Setting each cudaLimit has its own
     specific restrictions, so each is discussed here.
   </p>
   <ul>
     <li>
       <p>cudaLimitStackSize controls
         the stack size in bytes of each GPU thread. This limit is only
         applicable to devices of compute capability 2.0 and
         higher. Attempting to set this
         limit on devices of compute capability less than 2.0 will result in
         the error cudaErrorUnsupportedLimit being returned.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaLimitPrintfFifoSize controls
         the size in bytes of the shared FIFO used by the printf() and fprintf()
         device system calls. Setting cudaLimitPrintfFifoSize must be performed
         before launching any kernel that uses the printf() or fprintf() device
         system calls, otherwise cudaErrorInvalidValue will be returned. This
         limit is only applicable to devices of compute capability 2.0 and
         higher. Attempting to set this limit
         on devices of compute capability
         less than 2.0 will result in the error cudaErrorUnsupportedLimit being
         returned.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaLimitMallocHeapSize controls
         the size in bytes of the heap used by the malloc() and free() device
         system calls. Setting cudaLimitMallocHeapSize must be performed before
         launching any kernel that uses the malloc() or free() device system
         calls, otherwise cudaErrorInvalidValue will be returned. This limit is
         only applicable to devices of compute capability 2.0 and higher.
         Attempting to set this limit
         on devices of compute capability
         less than 2.0 will result in the error cudaErrorUnsupportedLimit being
         returned.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaLimitDevRuntimeSyncDepth
         controls the maximum nesting depth of a grid at which a thread can
         safely call cudaDeviceSynchronize(). Setting this limit must be
         performed before any launch of a kernel that uses the device runtime
         and calls cudaDeviceSynchronize() above the default sync depth, two
         levels of grids. Calls to cudaDeviceSynchronize() will fail with error
         code cudaErrorSyncDepthExceeded if the limitation is violated. This
         limit can be set smaller than the default or up the maximum launch
         depth of 24. When
         setting this limit, keep in mind
         that additional levels of sync depth require the runtime to reserve
         large amounts of device
         memory which can no longer be
         used for user allocations. If these reservations of device memory fail,
         cudaDeviceSetLimit will return cudaErrorMemoryAllocation, and the limit
         can be reset to a lower value. This limit is only applicable to devices
         of compute capability 3.5 and higher.
         Attempting to set this limit on
         devices of compute capability less than 3.5 will result in the error
         cudaErrorUnsupportedLimit being returned.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaLimitDevRuntimePendingLaunchCount
         controls the maximum number of outstanding device runtime launches that
         can be made from the current device. A grid is outstanding
         from the point of launch up
         until the grid is known to have been completed. Device runtime launches
         which violate this limitation
         fail and return
         cudaErrorLaunchPendingCountExceeded when cudaGetLastError() is called
         after launch. If more pending launches than the default (2048 launches)
         are needed for a module using the device
         runtime, this limit can be
         increased. Keep in mind that being able to sustain additional pending
         launches will require the
         runtime to reserve larger
         amounts of device memory upfront which can no longer be used for
         allocations. If these reservations
         fail, cudaDeviceSetLimit will
         return cudaErrorMemoryAllocation, and the limit can be reset to a lower
         value. This limit is only applicable to devices of compute capability
         3.5 and higher.
         Attempting to set this limit on
         devices of compute capability less than 3.5 will result in the error
         cudaErrorUnsupportedLimit being returned.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>limit</CODE> - Limit to set<DD><CODE>value</CODE> - Size of limit
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorUnsupportedLimit, cudaErrorInvalidValue,
 cudaErrorMemoryAllocation<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceGetLimit(long[], int)"><CODE>cudaDeviceGetLimit(long[], int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDeviceGetLimit(long[], int)"><!-- --></A><H3>
cudaDeviceGetLimit</H3>
<PRE>
public static int <B>cudaDeviceGetLimit</B>(long[]&nbsp;pValue,
                                     int&nbsp;limit)</PRE>
<DL>
<DD>Returns resource limits.
 
 <pre>
 cudaError_t cudaDeviceGetLimit (
      size_t* pValue,
      cudaLimit limit )
 </pre>
 <div>
   <p>Returns resource limits.  Returns in <tt>*pValue</tt> the current size of <tt>limit</tt>. The supported
     cudaLimit values are:
   <ul>
     <li>
       <p>cudaLimitStackSize: stack size
         in bytes of each GPU thread;
       </p>
     </li>
     <li>
       <p>cudaLimitPrintfFifoSize: size
         in bytes of the shared FIFO used by the printf() and fprintf() device
         system calls.
       </p>
     </li>
     <li>
       <p>cudaLimitMallocHeapSize: size
         in bytes of the heap used by the malloc() and free() device system
         calls;
       </p>
     </li>
     <li>
       <p>cudaLimitDevRuntimeSyncDepth:
         maximum grid depth at which a thread can isssue the device runtime call
         cudaDeviceSynchronize() to wait on child grid launches to complete.
       </p>
     </li>
     <li>
       <p>cudaLimitDevRuntimePendingLaunchCount:
         maximum number of outstanding device runtime launches.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pValue</CODE> - Returned size of the limit<DD><CODE>limit</CODE> - Limit to query
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorUnsupportedLimit, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetLimit(int, long)"><CODE>cudaDeviceSetLimit(int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDeviceGetCacheConfig(int[])"><!-- --></A><H3>
cudaDeviceGetCacheConfig</H3>
<PRE>
public static int <B>cudaDeviceGetCacheConfig</B>(int[]&nbsp;pCacheConfig)</PRE>
<DL>
<DD>Returns the preferred cache configuration for the current device.
 
 <pre>
 cudaError_t cudaDeviceGetCacheConfig (
      cudaFuncCache ** pCacheConfig )
 </pre>
 <div>
   <p>Returns the preferred cache configuration
     for the current device.  On devices where the L1 cache and shared
     memory use the
     same hardware resources, this returns
     through <tt>pCacheConfig</tt> the preferred cache configuration for
     the current device. This is only a preference. The runtime will use
     the requested configuration
     if possible, but it is free to choose a
     different configuration if required to execute functions.
   </p>
   <p>This will return a <tt>pCacheConfig</tt>
     of cudaFuncCachePreferNone on devices where the size of the L1 cache
     and shared memory are fixed.
   </p>
   <p>The supported cache configurations are:
   <ul>
     <li>
       <p>cudaFuncCachePreferNone: no
         preference for shared memory or L1 (default)
       </p>
     </li>
     <li>
       <p>cudaFuncCachePreferShared:
         prefer larger shared memory and smaller L1 cache
       </p>
     </li>
     <li>
       <p>cudaFuncCachePreferL1: prefer
         larger L1 cache and smaller shared memory
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCacheConfig</CODE> - Returned cache configuration
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetCacheConfig(int)"><CODE>cudaDeviceSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetCacheConfig(int)"><CODE>cudaDeviceSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetCacheConfig(int)"><CODE>cudaDeviceSetCacheConfig(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDeviceGetSharedMemConfig(int[])"><!-- --></A><H3>
cudaDeviceGetSharedMemConfig</H3>
<PRE>
public static int <B>cudaDeviceGetSharedMemConfig</B>(int[]&nbsp;pConfig)</PRE>
<DL>
<DD>Returns the shared memory configuration for the current device.
 
 <pre>
 cudaError_t cudaDeviceGetSharedMemConfig (
      cudaSharedMemConfig ** pConfig )
 </pre>
 <div>
   <p>Returns the shared memory configuration
     for the current device.  This function will return in <tt>pConfig</tt>
     the current size of shared memory banks on the current device. On
     devices with configurable shared memory banks, cudaDeviceSetSharedMemConfig
     can be used to change this setting, so that all subsequent kernel
     launches will by default use the new bank size. When
     cudaDeviceGetSharedMemConfig is called on devices without configurable
     shared memory, it will return the fixed bank size of the hardware.
   </p>
   <p>The returned bank configurations can be
     either:
   <ul>
     <li>
       <p>cudaSharedMemBankSizeFourByte
         - shared memory bank width is four bytes.
       </p>
     </li>
     <li>
       <p>cudaSharedMemBankSizeEightByte
         - shared memory bank width is eight bytes.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pConfig</CODE> - Returned cache configuration
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue,
 cudaErrorInitializationError<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetCacheConfig(int)"><CODE>cudaDeviceSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceGetCacheConfig(int[])"><CODE>cudaDeviceGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetSharedMemConfig(int)"><CODE>cudaDeviceSetSharedMemConfig(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetCacheConfig(int)"><CODE>cudaDeviceSetCacheConfig(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDeviceSetSharedMemConfig(int)"><!-- --></A><H3>
cudaDeviceSetSharedMemConfig</H3>
<PRE>
public static int <B>cudaDeviceSetSharedMemConfig</B>(int&nbsp;config)</PRE>
<DL>
<DD>Sets the shared memory configuration for the current device.
 
 <pre>
 cudaError_t cudaDeviceSetSharedMemConfig (
      cudaSharedMemConfig config )
 </pre>
 <div>
   <p>Sets the shared memory configuration for
     the current device.  On devices with configurable shared memory banks,
     this function
     will set the shared memory bank size
     which is used for all subsequent kernel launches. Any per-function
     setting of shared
     memory set via cudaFuncSetSharedMemConfig
     will override the device wide setting.
   </p>
   <p>Changing the shared memory configuration
     between launches may introduce a device side synchronization
     point.
   </p>
   <p>Changing the shared memory bank size
     will not increase shared memory usage or affect occupancy of kernels,
     but may have major
     effects on performance. Larger bank sizes
     will allow for greater potential bandwidth to shared memory, but will
     change what
     kinds of accesses to shared memory will
     result in bank conflicts.
   </p>
   <p>This function will do nothing on devices
     with fixed shared memory bank size.
   </p>
   <p>The supported bank configurations are:
   <ul>
     <li>
       <p>cudaSharedMemBankSizeDefault:
         set bank width the device default (currently, four bytes)
       </p>
     </li>
     <li>
       <p>cudaSharedMemBankSizeFourByte:
         set shared memory bank width to be four bytes natively.
       </p>
     </li>
     <li>
       <p>cudaSharedMemBankSizeEightByte:
         set shared memory bank width to be eight bytes natively.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>config</CODE> - Requested cache configuration
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue,
 cudaErrorInitializationError<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetCacheConfig(int)"><CODE>cudaDeviceSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceGetCacheConfig(int[])"><CODE>cudaDeviceGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceGetSharedMemConfig(int[])"><CODE>cudaDeviceGetSharedMemConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetCacheConfig(int)"><CODE>cudaDeviceSetCacheConfig(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDeviceSetCacheConfig(int)"><!-- --></A><H3>
cudaDeviceSetCacheConfig</H3>
<PRE>
public static int <B>cudaDeviceSetCacheConfig</B>(int&nbsp;cacheConfig)</PRE>
<DL>
<DD>Sets the preferred cache configuration for the current device.
 
 <pre>
 cudaError_t cudaDeviceSetCacheConfig (
      cudaFuncCache cacheConfig )
 </pre>
 <div>
   <p>Sets the preferred cache configuration
     for the current device.  On devices where the L1 cache and shared
     memory use the same
     hardware resources, this sets through
     <tt>cacheConfig</tt> the preferred cache configuration for the current
     device. This is only a preference. The runtime will use the requested
     configuration
     if possible, but it is free to choose a
     different configuration if required to execute the function. Any
     function preference
     set via cudaDeviceSetCacheConfig ( C API)
     or cudaDeviceSetCacheConfig ( C++ API) will be preferred over this
     device-wide setting. Setting the device-wide cache configuration to
     cudaFuncCachePreferNone will cause subsequent kernel launches to prefer
     to not change the cache configuration unless required to launch the
     kernel.
   </p>
   <p>This setting does nothing on devices
     where the size of the L1 cache and shared memory are fixed.
   </p>
   <p>Launching a kernel with a different
     preference than the most recent preference setting may insert a
     device-side synchronization
     point.
   </p>
   <p>The supported cache configurations are:
   <ul>
     <li>
       <p>cudaFuncCachePreferNone: no
         preference for shared memory or L1 (default)
       </p>
     </li>
     <li>
       <p>cudaFuncCachePreferShared:
         prefer larger shared memory and smaller L1 cache
       </p>
     </li>
     <li>
       <p>cudaFuncCachePreferL1: prefer
         larger L1 cache and smaller shared memory
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cacheConfig</CODE> - Requested cache configuration
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceGetCacheConfig(int[])"><CODE>cudaDeviceGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetCacheConfig(int)"><CODE>cudaDeviceSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetCacheConfig(int)"><CODE>cudaDeviceSetCacheConfig(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDeviceGetByPCIBusId(int[], java.lang.String)"><!-- --></A><H3>
cudaDeviceGetByPCIBusId</H3>
<PRE>
public static int <B>cudaDeviceGetByPCIBusId</B>(int[]&nbsp;device,
                                          java.lang.String&nbsp;pciBusId)</PRE>
<DL>
<DD>Returns a handle to a compute device.
 
 <pre>
 cudaError_t cudaDeviceGetByPCIBusId (
      int* device,
      char* pciBusId )
 </pre>
 <div>
   <p>Returns a handle to a compute device. 
     Returns in <tt>*device</tt> a device ordinal given a PCI bus ID
     string.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>device</CODE> - Returned device ordinal<DD><CODE>pciBusId</CODE> - String in one of the following forms: [domain]:[bus]:[device].[function] [domain]:[bus]:[device] [bus]:[device].[function] where domain, bus, device, and function are all hexadecimal values
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevice<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceGetPCIBusId(java.lang.String[], int, int)"><CODE>cudaDeviceGetPCIBusId(java.lang.String[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDeviceGetPCIBusId(java.lang.String[], int, int)"><!-- --></A><H3>
cudaDeviceGetPCIBusId</H3>
<PRE>
public static int <B>cudaDeviceGetPCIBusId</B>(java.lang.String[]&nbsp;pciBusId,
                                        int&nbsp;len,
                                        int&nbsp;device)</PRE>
<DL>
<DD>Returns a PCI Bus Id string for the device.
 
 <pre>
 cudaError_t cudaDeviceGetPCIBusId (
      char* pciBusId,
      int  len,
      int  device )
 </pre>
 <div>
   <p>Returns a PCI Bus Id string for the
     device.  Returns an ASCII string identifying the device <tt>dev</tt>
     in the NULL-terminated string pointed to by <tt>pciBusId</tt>. <tt>len</tt> specifies the maximum length of the string that may be
     returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pciBusId</CODE> - Returned identifier string for the device in the following format [domain]:[bus]:[device].[function] where domain, bus, device, and function are all hexadecimal values. pciBusId should be large enough to store 13 characters including the NULL-terminator.<DD><CODE>len</CODE> - Maximum length of string to store in name<DD><CODE>device</CODE> - Device to get identifier string for
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevice<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceGetByPCIBusId(int[], java.lang.String)"><CODE>cudaDeviceGetByPCIBusId(int[], java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaIpcGetEventHandle(jcuda.runtime.cudaIpcEventHandle, jcuda.runtime.cudaEvent_t)"><!-- --></A><H3>
cudaIpcGetEventHandle</H3>
<PRE>
public static int <B>cudaIpcGetEventHandle</B>(<A HREF="../../jcuda/runtime/cudaIpcEventHandle.html" title="class in jcuda.runtime">cudaIpcEventHandle</A>&nbsp;handle,
                                        <A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</PRE>
<DL>
<DD>Gets an interprocess handle for a previously allocated event.
 
 <pre>
 cudaError_t cudaIpcGetEventHandle (
      cudaIpcEventHandle_t* handle,
      cudaEvent_t event )
 </pre>
 <div>
   <p>Gets an interprocess handle for a
     previously allocated event.  Takes as input a previously allocated
     event. This event must
     have been created with the
     cudaEventInterprocess and cudaEventDisableTiming flags set. This opaque
     handle may be copied into other processes and opened with
     cudaIpcOpenEventHandle to allow efficient hardware synchronization
     between GPU work in different processes.
   </p>
   <p>After the event has been been opened in
     the importing process, cudaEventRecord, cudaEventSynchronize,
     cudaStreamWaitEvent and cudaEventQuery may be used in either process.
     Performing operations on the imported event after the exported event
     has been freed with cudaEventDestroy will result in undefined
     behavior.
   </p>
   <p>IPC functionality is restricted to
     devices with support for unified addressing on Linux operating
     systems.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>handle</CODE> - Pointer to a user allocated cudaIpcEventHandle in which to return the opaque event handle<DD><CODE>event</CODE> - Event allocated with cudaEventInterprocess and cudaEventDisableTiming flags.
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidResourceHandle,
 cudaErrorMemoryAllocation, cudaErrorMapBufferObjectFailed<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreate(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventCreate(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventDestroy(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventDestroy(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventSynchronize(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventSynchronize(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventQuery(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventQuery(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)"><CODE>cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcOpenEventHandle(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaIpcEventHandle)"><CODE>cudaIpcOpenEventHandle(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaIpcEventHandle)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcGetMemHandle(jcuda.runtime.cudaIpcMemHandle, jcuda.Pointer)"><CODE>cudaIpcGetMemHandle(jcuda.runtime.cudaIpcMemHandle, jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcOpenMemHandle(jcuda.Pointer, jcuda.runtime.cudaIpcMemHandle, int)"><CODE>cudaIpcOpenMemHandle(jcuda.Pointer, jcuda.runtime.cudaIpcMemHandle, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcCloseMemHandle(jcuda.Pointer)"><CODE>cudaIpcCloseMemHandle(jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaIpcOpenEventHandle(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaIpcEventHandle)"><!-- --></A><H3>
cudaIpcOpenEventHandle</H3>
<PRE>
public static int <B>cudaIpcOpenEventHandle</B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event,
                                         <A HREF="../../jcuda/runtime/cudaIpcEventHandle.html" title="class in jcuda.runtime">cudaIpcEventHandle</A>&nbsp;handle)</PRE>
<DL>
<DD>Opens an interprocess event handle for use in the current process.
 
 <pre>
 cudaError_t cudaIpcOpenEventHandle (
      cudaEvent_t* event,
      cudaIpcEventHandle_t handle )
 </pre>
 <div>
   <p>Opens an interprocess event handle for
     use in the current process.  Opens an interprocess event handle exported
     from another
     process with cudaIpcGetEventHandle. This
     function returns a cudaEvent_t that behaves like a locally created
     event with the cudaEventDisableTiming flag specified. This event must
     be freed with cudaEventDestroy.
   </p>
   <p>Performing operations on the imported
     event after the exported event has been freed with cudaEventDestroy
     will result in undefined behavior.
   </p>
   <p>IPC functionality is restricted to
     devices with support for unified addressing on Linux operating
     systems.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>event</CODE> - Returns the imported event<DD><CODE>handle</CODE> - Interprocess handle to open
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMapBufferObjectFailed,
 cudaErrorInvalidResourceHandle<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreate(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventCreate(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventDestroy(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventDestroy(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventSynchronize(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventSynchronize(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventQuery(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventQuery(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)"><CODE>cudaStreamWaitEvent(jcuda.runtime.cudaStream_t, jcuda.runtime.cudaEvent_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcGetEventHandle(jcuda.runtime.cudaIpcEventHandle, jcuda.runtime.cudaEvent_t)"><CODE>cudaIpcGetEventHandle(jcuda.runtime.cudaIpcEventHandle, jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcGetMemHandle(jcuda.runtime.cudaIpcMemHandle, jcuda.Pointer)"><CODE>cudaIpcGetMemHandle(jcuda.runtime.cudaIpcMemHandle, jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcOpenMemHandle(jcuda.Pointer, jcuda.runtime.cudaIpcMemHandle, int)"><CODE>cudaIpcOpenMemHandle(jcuda.Pointer, jcuda.runtime.cudaIpcMemHandle, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcCloseMemHandle(jcuda.Pointer)"><CODE>cudaIpcCloseMemHandle(jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaIpcGetMemHandle(jcuda.runtime.cudaIpcMemHandle, jcuda.Pointer)"><!-- --></A><H3>
cudaIpcGetMemHandle</H3>
<PRE>
public static int <B>cudaIpcGetMemHandle</B>(<A HREF="../../jcuda/runtime/cudaIpcMemHandle.html" title="class in jcuda.runtime">cudaIpcMemHandle</A>&nbsp;handle,
                                      <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr)</PRE>
<DL>
<DD><pre>
 cudaError_t cudaIpcGetMemHandle (
      cudaIpcMemHandle_t* handle,
      void* devPtr )
 </pre>
 <div>
   <p> /brief Gets an interprocess memory
     handle for an existing device memory allocation
   </p>
   <p>Takes a pointer to the base of an
     existing device memory allocation created with cudaMalloc and exports
     it for use in another process. This is a lightweight operation and may
     be called multiple times on an allocation
     without adverse effects.
   </p>
   <p>If a region of memory is freed with
     cudaFree and a subsequent call to cudaMalloc returns memory with the
     same device address, cudaIpcGetMemHandle will return a unique handle
     for the new memory.
   </p>
   <p>IPC functionality is restricted to
     devices with support for unified addressing on Linux operating
     systems.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>handle</CODE> - Pointer to user allocated cudaIpcMemHandle to return the handle in.<DD><CODE>devPtr</CODE> - Base pointer to previously allocated device memory
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidResourceHandle,
 cudaErrorMemoryAllocation, cudaErrorMapBufferObjectFailed,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcGetEventHandle(jcuda.runtime.cudaIpcEventHandle, jcuda.runtime.cudaEvent_t)"><CODE>cudaIpcGetEventHandle(jcuda.runtime.cudaIpcEventHandle, jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcOpenEventHandle(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaIpcEventHandle)"><CODE>cudaIpcOpenEventHandle(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaIpcEventHandle)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcOpenMemHandle(jcuda.Pointer, jcuda.runtime.cudaIpcMemHandle, int)"><CODE>cudaIpcOpenMemHandle(jcuda.Pointer, jcuda.runtime.cudaIpcMemHandle, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcCloseMemHandle(jcuda.Pointer)"><CODE>cudaIpcCloseMemHandle(jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaIpcOpenMemHandle(jcuda.Pointer, jcuda.runtime.cudaIpcMemHandle, int)"><!-- --></A><H3>
cudaIpcOpenMemHandle</H3>
<PRE>
public static int <B>cudaIpcOpenMemHandle</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                       <A HREF="../../jcuda/runtime/cudaIpcMemHandle.html" title="class in jcuda.runtime">cudaIpcMemHandle</A>&nbsp;handle,
                                       int&nbsp;flags)</PRE>
<DL>
<DD><pre>
 cudaError_t cudaIpcOpenMemHandle (
      void** devPtr,
      cudaIpcMemHandle_t handle,
      unsigned int  flags )
 </pre>
 <div>
   <p> /brief Opens an interprocess memory
     handle exported from another process and returns a device pointer
     usable in the local
     process.
   </p>
   <p>Maps memory exported from another
     process with cudaIpcGetMemHandle into the current device address space.
     For contexts on different devices cudaIpcOpenMemHandle can attempt to
     enable peer access between the devices as if the user called
     cudaDeviceEnablePeerAccess. This behavior is controlled by the
     cudaIpcMemLazyEnablePeerAccess flag. cudaDeviceCanAccessPeer can
     determine if a mapping is possible.
   </p>
   <p>Contexts that may open cudaIpcMemHandles
     are restricted in the following way. cudaIpcMemHandles from each device
     in a given
     process may only be opened by one context
     per device per other process.
   </p>
   <p>Memory returned from cudaIpcOpenMemHandle
     must be freed with cudaIpcCloseMemHandle.
   </p>
   <p>Calling cudaFree on an exported memory
     region before calling cudaIpcCloseMemHandle in the importing context
     will result in undefined behavior.
   </p>
   <p>IPC functionality is restricted to
     devices with support for unified addressing on Linux operating
     systems.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>devPtr</CODE> - Returned device pointer<DD><CODE>handle</CODE> - cudaIpcMemHandle to open<DD><CODE>flags</CODE> - Flags for this operation. Must be specified as cudaIpcMemLazyEnablePeerAccess
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMapBufferObjectFailed,
 cudaErrorInvalidResourceHandle, cudaErrorTooManyPeers<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcGetEventHandle(jcuda.runtime.cudaIpcEventHandle, jcuda.runtime.cudaEvent_t)"><CODE>cudaIpcGetEventHandle(jcuda.runtime.cudaIpcEventHandle, jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcOpenEventHandle(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaIpcEventHandle)"><CODE>cudaIpcOpenEventHandle(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaIpcEventHandle)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcGetMemHandle(jcuda.runtime.cudaIpcMemHandle, jcuda.Pointer)"><CODE>cudaIpcGetMemHandle(jcuda.runtime.cudaIpcMemHandle, jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcCloseMemHandle(jcuda.Pointer)"><CODE>cudaIpcCloseMemHandle(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceEnablePeerAccess(int, int)"><CODE>cudaDeviceEnablePeerAccess(int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceCanAccessPeer(int[], int, int)"><CODE>cudaDeviceCanAccessPeer(int[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaIpcCloseMemHandle(jcuda.Pointer)"><!-- --></A><H3>
cudaIpcCloseMemHandle</H3>
<PRE>
public static int <B>cudaIpcCloseMemHandle</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr)</PRE>
<DL>
<DD>Close memory mapped with cudaIpcOpenMemHandle.
 
 <pre>
 cudaError_t cudaIpcCloseMemHandle (
      void* devPtr )
 </pre>
 <div>
   <p>Close memory mapped with
     cudaIpcOpenMemHandle.  Unmaps memory returnd by cudaIpcOpenMemHandle.
     The original allocation in the exporting process as well as imported
     mappings in other processes will be unaffected.
   </p>
   <p>Any resources used to enable peer access
     will be freed if this is the last mapping using them.
   </p>
   <p>IPC functionality is restricted to
     devices with support for unified addressing on Linux operating
     systems.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>devPtr</CODE> - Device pointer returned by cudaIpcOpenMemHandle
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMapBufferObjectFailed,
 cudaErrorInvalidResourceHandle,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcGetEventHandle(jcuda.runtime.cudaIpcEventHandle, jcuda.runtime.cudaEvent_t)"><CODE>cudaIpcGetEventHandle(jcuda.runtime.cudaIpcEventHandle, jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcOpenEventHandle(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaIpcEventHandle)"><CODE>cudaIpcOpenEventHandle(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaIpcEventHandle)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcGetMemHandle(jcuda.runtime.cudaIpcMemHandle, jcuda.Pointer)"><CODE>cudaIpcGetMemHandle(jcuda.runtime.cudaIpcMemHandle, jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaIpcOpenMemHandle(jcuda.Pointer, jcuda.runtime.cudaIpcMemHandle, int)"><CODE>cudaIpcOpenMemHandle(jcuda.Pointer, jcuda.runtime.cudaIpcMemHandle, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaThreadExit()"><!-- --></A><H3>
cudaThreadExit</H3>
<PRE>
public static int <B>cudaThreadExit</B>()</PRE>
<DL>
<DD>Exit and clean up from CUDA launches.
 
 <pre>
 cudaError_t cudaThreadExit (
      void )
 </pre>
 <div>
   <p>Exit and clean up from CUDA launches.  
     DeprecatedNote that this function is
     deprecated because its name does not reflect its behavior. Its
     functionality is identical to the
     non-deprecated function cudaDeviceReset(),
     which should be used instead.
   </p>
   <p>Explicitly destroys all cleans up all
     resources associated with the current device in the current process.
     Any subsequent
     API call to this device will reinitialize
     the device.
   </p>
   <p>Note that this function will reset the
     device immediately. It is the caller's responsibility to ensure that
     the device is
     not being accessed by any other host
     threads from the process when this function is called.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceReset()"><CODE>cudaDeviceReset()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaThreadSynchronize()"><!-- --></A><H3>
cudaThreadSynchronize</H3>
<PRE>
public static int <B>cudaThreadSynchronize</B>()</PRE>
<DL>
<DD>Wait for compute device to finish.
 
 <pre>
 cudaError_t cudaThreadSynchronize (
      void )
 </pre>
 <div>
   <p>Wait for compute device to finish.  
     DeprecatedNote that this function is
     deprecated because its name does not reflect its behavior. Its
     functionality is similar to the
     non-deprecated function
     cudaDeviceSynchronize(), which should be used instead.
   </p>
   <p>Blocks until the device has completed
     all preceding requested tasks. cudaThreadSynchronize() returns an error
     if one of the preceding tasks has failed. If the
     cudaDeviceScheduleBlockingSync flag was set for this device, the host
     thread will block until the device has finished its work.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSynchronize()"><CODE>cudaDeviceSynchronize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaThreadSetLimit(int, long)"><!-- --></A><H3>
cudaThreadSetLimit</H3>
<PRE>
public static int <B>cudaThreadSetLimit</B>(int&nbsp;limit,
                                     long&nbsp;value)</PRE>
<DL>
<DD>Set resource limits.
 
 <pre>
 cudaError_t cudaThreadSetLimit (
      cudaLimit limit,
      size_t value )
 </pre>
 <div>
   <p>Set resource limits.  
     DeprecatedNote that this function is
     deprecated because its name does not reflect its behavior. Its
     functionality is identical to the
     non-deprecated function cudaDeviceSetLimit(),
     which should be used instead.
   </p>
   <p>Setting <tt>limit</tt> to <tt>value</tt> is a request by the application to update the current limit
     maintained by the device. The driver is free to modify the requested
     value to meet h/w requirements (this
     could be clamping to minimum or maximum values, rounding up to nearest
     element size,
     etc). The application can use
     cudaThreadGetLimit() to find out exactly what the limit has been set
     to.
   </p>
   <p>Setting each cudaLimit has its own
     specific restrictions, so each is discussed here.
   </p>
   <ul>
     <li>
       <p>cudaLimitStackSize controls
         the stack size of each GPU thread. This limit is only applicable to
         devices of compute capability 2.0 and higher.
         Attempting to set this limit on
         devices of compute capability less than 2.0 will result in the error
         cudaErrorUnsupportedLimit being returned.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaLimitPrintfFifoSize controls
         the size of the shared FIFO used by the printf() and fprintf() device
         system calls. Setting cudaLimitPrintfFifoSize must be performed before
         launching any kernel that uses the printf() or fprintf() device system
         calls, otherwise cudaErrorInvalidValue will be returned. This limit is
         only applicable to devices of compute capability 2.0 and higher.
         Attempting to set this limit
         on devices of compute capability
         less than 2.0 will result in the error cudaErrorUnsupportedLimit being
         returned.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaLimitMallocHeapSize controls
         the size of the heap used by the malloc() and free() device system
         calls. Setting cudaLimitMallocHeapSize must be performed before
         launching any kernel that uses the malloc() or free() device system
         calls, otherwise cudaErrorInvalidValue will be returned. This limit is
         only applicable to devices of compute capability 2.0 and higher.
         Attempting to set this limit
         on devices of compute capability
         less than 2.0 will result in the error cudaErrorUnsupportedLimit being
         returned.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>limit</CODE> - Limit to set<DD><CODE>value</CODE> - Size in bytes of limit
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorUnsupportedLimit, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetLimit(int, long)"><CODE>cudaDeviceSetLimit(int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaThreadGetCacheConfig(int[])"><!-- --></A><H3>
cudaThreadGetCacheConfig</H3>
<PRE>
public static int <B>cudaThreadGetCacheConfig</B>(int[]&nbsp;pCacheConfig)</PRE>
<DL>
<DD>Returns the preferred cache configuration for the current device.
 
 <pre>
 cudaError_t cudaThreadGetCacheConfig (
      cudaFuncCache ** pCacheConfig )
 </pre>
 <div>
   <p>Returns the preferred cache configuration
     for the current device.  
     DeprecatedNote that this function is
     deprecated because its name does not reflect its behavior. Its
     functionality is identical to the
     non-deprecated function
     cudaDeviceGetCacheConfig(), which should be used instead.
   </p>
   <p>On devices where the L1 cache and shared
     memory use the same hardware resources, this returns through <tt>pCacheConfig</tt> the preferred cache configuration for the current
     device. This is only a preference. The runtime will use the requested
     configuration
     if possible, but it is free to choose a
     different configuration if required to execute functions.
   </p>
   <p>This will return a <tt>pCacheConfig</tt>
     of cudaFuncCachePreferNone on devices where the size of the L1 cache
     and shared memory are fixed.
   </p>
   <p>The supported cache configurations are:
   <ul>
     <li>
       <p>cudaFuncCachePreferNone: no
         preference for shared memory or L1 (default)
       </p>
     </li>
     <li>
       <p>cudaFuncCachePreferShared:
         prefer larger shared memory and smaller L1 cache
       </p>
     </li>
     <li>
       <p>cudaFuncCachePreferL1: prefer
         larger L1 cache and smaller shared memory
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCacheConfig</CODE> - Returned cache configuration
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceGetCacheConfig(int[])"><CODE>cudaDeviceGetCacheConfig(int[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaThreadSetCacheConfig(int)"><!-- --></A><H3>
cudaThreadSetCacheConfig</H3>
<PRE>
public static int <B>cudaThreadSetCacheConfig</B>(int&nbsp;cacheConfig)</PRE>
<DL>
<DD>Sets the preferred cache configuration for the current device.
 
 <pre>
 cudaError_t cudaThreadSetCacheConfig (
      cudaFuncCache cacheConfig )
 </pre>
 <div>
   <p>Sets the preferred cache configuration
     for the current device.  
     DeprecatedNote that this function is
     deprecated because its name does not reflect its behavior. Its
     functionality is identical to the
     non-deprecated function
     cudaDeviceSetCacheConfig(), which should be used instead.
   </p>
   <p>On devices where the L1 cache and shared
     memory use the same hardware resources, this sets through <tt>cacheConfig</tt> the preferred cache configuration for the current
     device. This is only a preference. The runtime will use the requested
     configuration
     if possible, but it is free to choose a
     different configuration if required to execute the function. Any
     function preference
     set via cudaDeviceSetCacheConfig ( C API)
     or cudaDeviceSetCacheConfig ( C++ API) will be preferred over this
     device-wide setting. Setting the device-wide cache configuration to
     cudaFuncCachePreferNone will cause subsequent kernel launches to prefer
     to not change the cache configuration unless required to launch the
     kernel.
   </p>
   <p>This setting does nothing on devices
     where the size of the L1 cache and shared memory are fixed.
   </p>
   <p>Launching a kernel with a different
     preference than the most recent preference setting may insert a
     device-side synchronization
     point.
   </p>
   <p>The supported cache configurations are:
   <ul>
     <li>
       <p>cudaFuncCachePreferNone: no
         preference for shared memory or L1 (default)
       </p>
     </li>
     <li>
       <p>cudaFuncCachePreferShared:
         prefer larger shared memory and smaller L1 cache
       </p>
     </li>
     <li>
       <p>cudaFuncCachePreferL1: prefer
         larger L1 cache and smaller shared memory
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cacheConfig</CODE> - Requested cache configuration
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetCacheConfig(int)"><CODE>cudaDeviceSetCacheConfig(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaThreadGetLimit(long[], int)"><!-- --></A><H3>
cudaThreadGetLimit</H3>
<PRE>
public static int <B>cudaThreadGetLimit</B>(long[]&nbsp;pValue,
                                     int&nbsp;limit)</PRE>
<DL>
<DD>Returns resource limits.
 
 <pre>
 cudaError_t cudaThreadGetLimit (
      size_t* pValue,
      cudaLimit limit )
 </pre>
 <div>
   <p>Returns resource limits.  
     DeprecatedNote that this function is
     deprecated because its name does not reflect its behavior. Its
     functionality is identical to the
     non-deprecated function cudaDeviceGetLimit(),
     which should be used instead.
   </p>
   <p>Returns in <tt>*pValue</tt> the current
     size of <tt>limit</tt>. The supported cudaLimit values are:
   <ul>
     <li>
       <p>cudaLimitStackSize: stack size
         of each GPU thread;
       </p>
     </li>
     <li>
       <p>cudaLimitPrintfFifoSize: size
         of the shared FIFO used by the printf() and fprintf() device system
         calls.
       </p>
     </li>
     <li>
       <p>cudaLimitMallocHeapSize: size
         of the heap used by the malloc() and free() device system calls;
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pValue</CODE> - Returned size in bytes of limit<DD><CODE>limit</CODE> - Limit to query
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorUnsupportedLimit, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceGetLimit(long[], int)"><CODE>cudaDeviceGetLimit(long[], int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetSymbolAddress(jcuda.Pointer, java.lang.String)"><!-- --></A><H3>
cudaGetSymbolAddress</H3>
<PRE>
public static int <B>cudaGetSymbolAddress</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                       java.lang.String&nbsp;symbol)</PRE>
<DL>
<DD>[C++ API] Finds the address associated with a CUDA symbol
 
 <pre>
 template < class T > cudaError_t cudaGetSymbolAddress (
      void** devPtr,
      const T& symbol ) [inline]
 </pre>
 <div>
   <p>[C++ API] Finds the address associated
     with a CUDA symbol  Returns in <tt>*devPtr</tt> the address of symbol
     <tt>symbol</tt> on the device. <tt>symbol</tt> can either be a
     variable that resides in global or constant memory space. If <tt>symbol</tt> cannot be found, or if <tt>symbol</tt> is not declared
     in the global or constant memory space, <tt>*devPtr</tt> is unchanged
     and the error cudaErrorInvalidSymbol is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>devPtr</CODE> - Return device pointer associated with symbol<DD><CODE>symbol</CODE> - Device symbol address<DD><CODE>devPtr</CODE> - Return device pointer associated with symbol<DD><CODE>symbol</CODE> - Device symbol reference
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidSymbol<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetSymbolAddress(jcuda.Pointer, java.lang.String)"><CODE>cudaGetSymbolAddress(jcuda.Pointer, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetSymbolSize(long[], java.lang.String)"><CODE>cudaGetSymbolSize(long[], java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetSymbolSize(long[], java.lang.String)"><!-- --></A><H3>
cudaGetSymbolSize</H3>
<PRE>
public static int <B>cudaGetSymbolSize</B>(long[]&nbsp;size,
                                    java.lang.String&nbsp;symbol)</PRE>
<DL>
<DD>[C++ API] Finds the size of the object associated with a CUDA symbol
 
 <pre>
 template < class T > cudaError_t cudaGetSymbolSize (
      size_t* size,
      const T& symbol ) [inline]
 </pre>
 <div>
   <p>[C++ API] Finds the size of the object
     associated with a CUDA symbol  Returns in <tt>*size</tt> the size of
     symbol <tt>symbol</tt>. <tt>symbol</tt> must be a variable that
     resides in global or constant memory space. If <tt>symbol</tt> cannot
     be found, or if <tt>symbol</tt> is not declared in global or constant
     memory space, <tt>*size</tt> is unchanged and the error
     cudaErrorInvalidSymbol is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>size</CODE> - Size of object associated with symbol<DD><CODE>symbol</CODE> - Device symbol address<DD><CODE>size</CODE> - Size of object associated with symbol<DD><CODE>symbol</CODE> - Device symbol reference
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidSymbol<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetSymbolAddress(jcuda.Pointer, java.lang.String)"><CODE>cudaGetSymbolAddress(jcuda.Pointer, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetSymbolSize(long[], java.lang.String)"><CODE>cudaGetSymbolSize(long[], java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><!-- --></A><H3>
cudaBindTexture</H3>
<PRE>
public static int <B>cudaBindTexture</B>(long[]&nbsp;offset,
                                  <A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                                  <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                  <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                                  long&nbsp;size)</PRE>
<DL>
<DD>[C++ API] Binds a memory area to a texture
 
 <pre>
 template < class T, int dim, enum cudaTextureReadMode readMode >
 cudaError_t cudaBindTexture (
      size_t* offset,
      const texture < T,
      dim,
      readMode > & tex,
      const void* devPtr,
      const cudaChannelFormatDesc& desc,
      size_t size = UINT_MAX ) [inline]
 </pre>
 <div>
   <p>[C++ API] Binds a memory area to a
     texture  Binds <tt>size</tt> bytes of the memory area pointed to by
     <tt>devPtr</tt> to texture reference <tt>tex</tt>. <tt>desc</tt>
     describes how the memory is interpreted when fetching values from the
     texture. The <tt>offset</tt> parameter is an optional byte offset as
     with the low-level cudaBindTexture() function. Any memory previously
     bound to <tt>tex</tt> is unbound.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - Offset in bytes<DD><CODE>texref</CODE> - Texture to bind<DD><CODE>devPtr</CODE> - Memory area on device<DD><CODE>desc</CODE> - Channel format<DD><CODE>size</CODE> - Size of the memory area pointed to by devPtr<DD><CODE>offset</CODE> - Offset in bytes<DD><CODE>tex</CODE> - Texture to bind<DD><CODE>devPtr</CODE> - Memory area on device<DD><CODE>size</CODE> - Size of the memory area pointed to by devPtr<DD><CODE>offset</CODE> - Offset in bytes<DD><CODE>tex</CODE> - Texture to bind<DD><CODE>devPtr</CODE> - Memory area on device<DD><CODE>desc</CODE> - Channel format<DD><CODE>size</CODE> - Size of the memory area pointed to by devPtr
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,
 cudaErrorInvalidTexture<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateChannelDesc(int, int, int, int, int)"><CODE>cudaCreateChannelDesc(int, int, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)"><CODE>cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)"><CODE>cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><CODE>cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><CODE>cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaUnbindTexture(jcuda.runtime.textureReference)"><CODE>cudaUnbindTexture(jcuda.runtime.textureReference)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)"><CODE>cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><!-- --></A><H3>
cudaBindTexture2D</H3>
<PRE>
public static int <B>cudaBindTexture2D</B>(long[]&nbsp;offset,
                                    <A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                                    <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                    <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                                    long&nbsp;width,
                                    long&nbsp;height,
                                    long&nbsp;pitch)</PRE>
<DL>
<DD>[C++ API] Binds a 2D memory area to a texture
 
 <pre>
 template < class T, int dim, enum cudaTextureReadMode readMode >
 cudaError_t cudaBindTexture2D (
      size_t* offset,
      const texture < T,
      dim,
      readMode > & tex,
      const void* devPtr,
      const cudaChannelFormatDesc& desc,
      size_t width,
      size_t height,
      size_t pitch ) [inline]
 </pre>
 <div>
   <p>[C++ API] Binds a 2D memory area to a
     texture  Binds the 2D memory area pointed to by <tt>devPtr</tt> to
     the texture reference <tt>tex</tt>. The size of the area is constrained
     by <tt>width</tt> in texel units, <tt>height</tt> in texel units,
     and <tt>pitch</tt> in byte units. <tt>desc</tt> describes how the
     memory is interpreted when fetching values from the texture. Any memory
     previously bound to <tt>tex</tt> is unbound.
   </p>
   <p>Since the hardware enforces an alignment
     requirement on texture base addresses, cudaBindTexture2D() returns in
     <tt>*offset</tt> a byte offset that must be applied to texture fetches
     in order to read from the desired memory. This offset must be divided
     by the texel size and passed to kernels
     that read from the texture so they can be applied to the tex2D()
     function. If the
     device memory pointer was returned from
     cudaMalloc(), the offset is guaranteed to be 0 and NULL may be passed
     as the <tt>offset</tt> parameter.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - Offset in bytes<DD><CODE>texref</CODE> - Texture reference to bind<DD><CODE>devPtr</CODE> - 2D memory area on device<DD><CODE>desc</CODE> - Channel format<DD><CODE>width</CODE> - Width in texel units<DD><CODE>height</CODE> - Height in texel units<DD><CODE>pitch</CODE> - Pitch in bytes<DD><CODE>offset</CODE> - Offset in bytes<DD><CODE>tex</CODE> - Texture reference to bind<DD><CODE>devPtr</CODE> - 2D memory area on device<DD><CODE>width</CODE> - Width in texel units<DD><CODE>height</CODE> - Height in texel units<DD><CODE>pitch</CODE> - Pitch in bytes<DD><CODE>offset</CODE> - Offset in bytes<DD><CODE>tex</CODE> - Texture reference to bind<DD><CODE>devPtr</CODE> - 2D memory area on device<DD><CODE>desc</CODE> - Channel format<DD><CODE>width</CODE> - Width in texel units<DD><CODE>height</CODE> - Height in texel units<DD><CODE>pitch</CODE> - Pitch in bytes
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,
 cudaErrorInvalidTexture<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateChannelDesc(int, int, int, int, int)"><CODE>cudaCreateChannelDesc(int, int, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)"><CODE>cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)"><CODE>cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><CODE>cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><CODE>cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaUnbindTexture(jcuda.runtime.textureReference)"><CODE>cudaUnbindTexture(jcuda.runtime.textureReference)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)"><CODE>cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><!-- --></A><H3>
cudaBindTextureToArray</H3>
<PRE>
public static int <B>cudaBindTextureToArray</B>(<A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                                         <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array,
                                         <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc)</PRE>
<DL>
<DD>[C++ API] Binds an array to a texture
 
 <pre>
 template < class T, int dim, enum cudaTextureReadMode readMode >
 cudaError_t cudaBindTextureToArray (
      const texture < T,
      dim,
      readMode > & tex,
      cudaArray_const_t array,
      const cudaChannelFormatDesc& desc ) [inline]
 </pre>
 <div>
   <p>[C++ API] Binds an array to a texture 
     Binds the CUDA array <tt>array</tt> to the texture reference <tt>tex</tt>. <tt>desc</tt> describes how the memory is interpreted when
     fetching values from the texture. Any CUDA array previously bound to
     <tt>tex</tt> is unbound.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texref</CODE> - Texture to bind<DD><CODE>array</CODE> - Memory array on device<DD><CODE>desc</CODE> - Channel format<DD><CODE>tex</CODE> - Texture to bind<DD><CODE>array</CODE> - Memory array on device<DD><CODE>tex</CODE> - Texture to bind<DD><CODE>array</CODE> - Memory array on device<DD><CODE>desc</CODE> - Channel format
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,
 cudaErrorInvalidTexture<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateChannelDesc(int, int, int, int, int)"><CODE>cudaCreateChannelDesc(int, int, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)"><CODE>cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)"><CODE>cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><CODE>cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><CODE>cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaUnbindTexture(jcuda.runtime.textureReference)"><CODE>cudaUnbindTexture(jcuda.runtime.textureReference)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)"><CODE>cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaBindTextureToMipmappedArray(jcuda.runtime.textureReference, jcuda.runtime.cudaMipmappedArray, jcuda.runtime.cudaChannelFormatDesc)"><!-- --></A><H3>
cudaBindTextureToMipmappedArray</H3>
<PRE>
public static int <B>cudaBindTextureToMipmappedArray</B>(<A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                                                  <A HREF="../../jcuda/runtime/cudaMipmappedArray.html" title="class in jcuda.runtime">cudaMipmappedArray</A>&nbsp;mipmappedArray,
                                                  <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc)</PRE>
<DL>
<DD>[C++ API] Binds a mipmapped array to a texture
 
 <pre>
 template < class T, int dim, enum cudaTextureReadMode readMode >
 cudaError_t cudaBindTextureToMipmappedArray (
      const texture < T,
      dim,
      readMode > & tex,
      cudaMipmappedArray_const_t mipmappedArray,
      const cudaChannelFormatDesc& desc ) [inline]
 </pre>
 <div>
   <p>[C++ API] Binds a mipmapped array to a
     texture  Binds the CUDA mipmapped array <tt>mipmappedArray</tt> to
     the texture reference <tt>tex</tt>. <tt>desc</tt> describes how the
     memory is interpreted when fetching values from the texture. Any CUDA
     mipmapped array previously bound
     to <tt>tex</tt> is unbound.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texref</CODE> - Texture to bind<DD><CODE>mipmappedArray</CODE> - Memory mipmapped array on device<DD><CODE>desc</CODE> - Channel format<DD><CODE>tex</CODE> - Texture to bind<DD><CODE>mipmappedArray</CODE> - Memory mipmapped array on device<DD><CODE>tex</CODE> - Texture to bind<DD><CODE>mipmappedArray</CODE> - Memory mipmapped array on device<DD><CODE>desc</CODE> - Channel format
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,
 cudaErrorInvalidTexture<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateChannelDesc(int, int, int, int, int)"><CODE>cudaCreateChannelDesc(int, int, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)"><CODE>cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)"><CODE>cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><CODE>cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><CODE>cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaUnbindTexture(jcuda.runtime.textureReference)"><CODE>cudaUnbindTexture(jcuda.runtime.textureReference)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)"><CODE>cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaUnbindTexture(jcuda.runtime.textureReference)"><!-- --></A><H3>
cudaUnbindTexture</H3>
<PRE>
public static int <B>cudaUnbindTexture</B>(<A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref)</PRE>
<DL>
<DD>[C++ API] Unbinds a texture
 
 <pre>
 template < class T, int dim, enum cudaTextureReadMode readMode >
 cudaError_t cudaUnbindTexture (
      const texture < T,
      dim,
      readMode > & tex ) [inline]
 </pre>
 <div>
   <p>[C++ API] Unbinds a texture  Unbinds the
     texture bound to <tt>tex</tt>.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texref</CODE> - Texture to unbind<DD><CODE>tex</CODE> - Texture to unbind
<DT><B>Returns:</B><DD>cudaSuccess<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateChannelDesc(int, int, int, int, int)"><CODE>cudaCreateChannelDesc(int, int, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)"><CODE>cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)"><CODE>cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><CODE>cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><CODE>cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaUnbindTexture(jcuda.runtime.textureReference)"><CODE>cudaUnbindTexture(jcuda.runtime.textureReference)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)"><CODE>cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)"><!-- --></A><H3>
cudaGetTextureAlignmentOffset</H3>
<PRE>
public static int <B>cudaGetTextureAlignmentOffset</B>(long[]&nbsp;offset,
                                                <A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref)</PRE>
<DL>
<DD>[C++ API] Get the alignment offset of a texture
 
 <pre>
 template < class T, int dim, enum cudaTextureReadMode readMode >
 cudaError_t cudaGetTextureAlignmentOffset (
      size_t* offset,
      const texture < T,
      dim,
      readMode > & tex ) [inline]
 </pre>
 <div>
   <p>[C++ API] Get the alignment offset of a
     texture  Returns in <tt>*offset</tt> the offset that was returned when
     texture reference <tt>tex</tt> was bound.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - Offset of texture reference in bytes<DD><CODE>texref</CODE> - Texture to get offset of<DD><CODE>offset</CODE> - Offset of texture reference in bytes<DD><CODE>tex</CODE> - Texture to get offset of
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidTexture,
 cudaErrorInvalidTextureBinding<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateChannelDesc(int, int, int, int, int)"><CODE>cudaCreateChannelDesc(int, int, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)"><CODE>cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)"><CODE>cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><CODE>cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><CODE>cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaUnbindTexture(jcuda.runtime.textureReference)"><CODE>cudaUnbindTexture(jcuda.runtime.textureReference)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)"><CODE>cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)"><!-- --></A><H3>
cudaGetTextureReference</H3>
<PRE>
public static int <B>cudaGetTextureReference</B>(<A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                                          java.lang.String&nbsp;symbol)</PRE>
<DL>
<DD>Get the texture reference associated with a symbol.
 
 <pre>
 cudaError_t cudaGetTextureReference (
      const textureReference** texref,
      const void* symbol )
 </pre>
 <div>
   <p>Get the texture reference associated with
     a symbol.  Returns in <tt>*texref</tt> the structure associated to
     the texture reference defined by symbol <tt>symbol</tt>.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>Use of a string naming a
           variable as the <tt>symbol</tt> paramater was removed in CUDA 5.0.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texref</CODE> - Texture reference associated with symbol<DD><CODE>symbol</CODE> - Texture to get reference for
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidTexture<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateChannelDesc(int, int, int, int, int)"><CODE>cudaCreateChannelDesc(int, int, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)"><CODE>cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)"><CODE>cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><CODE>cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaUnbindTexture(jcuda.runtime.textureReference)"><CODE>cudaUnbindTexture(jcuda.runtime.textureReference)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaBindSurfaceToArray(jcuda.runtime.surfaceReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><!-- --></A><H3>
cudaBindSurfaceToArray</H3>
<PRE>
public static int <B>cudaBindSurfaceToArray</B>(<A HREF="../../jcuda/runtime/surfaceReference.html" title="class in jcuda.runtime">surfaceReference</A>&nbsp;surfref,
                                         <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array,
                                         <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc)</PRE>
<DL>
<DD>[C++ API] Binds an array to a surface
 
 <pre>
 template < class T, int dim > cudaError_t cudaBindSurfaceToArray (
      const surface < T,
      dim > & surf,
      cudaArray_const_t array,
      const cudaChannelFormatDesc& desc ) [inline]
 </pre>
 <div>
   <p>[C++ API] Binds an array to a surface 
     Binds the CUDA array <tt>array</tt> to the surface reference <tt>surf</tt>. <tt>desc</tt> describes how the memory is interpreted when
     dealing with the surface. Any CUDA array previously bound to <tt>surf</tt> is unbound.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>surfref</CODE> - Surface to bind<DD><CODE>array</CODE> - Memory array on device<DD><CODE>desc</CODE> - Channel format<DD><CODE>surf</CODE> - Surface to bind<DD><CODE>array</CODE> - Memory array on device<DD><CODE>surf</CODE> - Surface to bind<DD><CODE>array</CODE> - Memory array on device<DD><CODE>desc</CODE> - Channel format
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidSurface<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaBindSurfaceToArray(jcuda.runtime.surfaceReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindSurfaceToArray(jcuda.runtime.surfaceReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindSurfaceToArray(jcuda.runtime.surfaceReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindSurfaceToArray(jcuda.runtime.surfaceReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetSurfaceReference(jcuda.runtime.surfaceReference, java.lang.String)"><!-- --></A><H3>
cudaGetSurfaceReference</H3>
<PRE>
public static int <B>cudaGetSurfaceReference</B>(<A HREF="../../jcuda/runtime/surfaceReference.html" title="class in jcuda.runtime">surfaceReference</A>&nbsp;surfref,
                                          java.lang.String&nbsp;symbol)</PRE>
<DL>
<DD>Get the surface reference associated with a symbol.
 
 <pre>
 cudaError_t cudaGetSurfaceReference (
      const surfaceReference** surfref,
      const void* symbol )
 </pre>
 <div>
   <p>Get the surface reference associated with
     a symbol.  Returns in <tt>*surfref</tt> the structure associated to
     the surface reference defined by symbol <tt>symbol</tt>.
   </p>
   <div>
     <span>Note:</span>
     <ul>
       <li>
         <p>Note that this function may
           also return error codes from previous, asynchronous launches. 
         </p>
       </li>
       <li>
         <p>Use of a string naming a
           variable as the <tt>symbol</tt> paramater was removed in CUDA 5.0.
         </p>
       </li>
     </ul>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>surfref</CODE> - Surface reference associated with symbol<DD><CODE>symbol</CODE> - Surface to get reference for
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidSurface<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaBindSurfaceToArray(jcuda.runtime.surfaceReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindSurfaceToArray(jcuda.runtime.surfaceReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaCreateTextureObject(jcuda.runtime.cudaTextureObject, jcuda.runtime.cudaResourceDesc, jcuda.runtime.cudaTextureDesc, jcuda.runtime.cudaResourceViewDesc)"><!-- --></A><H3>
cudaCreateTextureObject</H3>
<PRE>
public static int <B>cudaCreateTextureObject</B>(<A HREF="../../jcuda/runtime/cudaTextureObject.html" title="class in jcuda.runtime">cudaTextureObject</A>&nbsp;pTexObject,
                                          <A HREF="../../jcuda/runtime/cudaResourceDesc.html" title="class in jcuda.runtime">cudaResourceDesc</A>&nbsp;pResDesc,
                                          <A HREF="../../jcuda/runtime/cudaTextureDesc.html" title="class in jcuda.runtime">cudaTextureDesc</A>&nbsp;pTexDesc,
                                          <A HREF="../../jcuda/runtime/cudaResourceViewDesc.html" title="class in jcuda.runtime">cudaResourceViewDesc</A>&nbsp;pResViewDesc)</PRE>
<DL>
<DD>Creates a texture object.
 
 <pre>
 cudaError_t cudaCreateTextureObject (
      cudaTextureObject_t* pTexObject,
      const cudaResourceDesc* pResDesc,
      const cudaTextureDesc* pTexDesc,
      const cudaResourceViewDesc* pResViewDesc )
 </pre>
 <div>
   <p>Creates a texture object.  Creates a
     texture object and returns it in <tt>pTexObject</tt>. <tt>pResDesc</tt>
     describes the data to texture from. <tt>pTexDesc</tt> describes how
     the data should be sampled. <tt>pResViewDesc</tt> is an optional
     argument that specifies an alternate format for the data described by
     <tt>pResDesc</tt>, and also describes the subresource region to
     restrict access to when texturing. <tt>pResViewDesc</tt> can only be
     specified if the type of resource is a CUDA array or a CUDA mipmapped
     array.
   </p>
   <p>Texture objects are only supported on
     devices of compute capability 3.0 or higher.
   </p>
   <p>The cudaResourceDesc structure is
     defined as: 
   <pre>        struct cudaResourceDesc {
             enum cudaResourceType 
                   resType;
             
             union {
                 struct {
                     cudaArray_t 
                   array;
                 } array;
                 struct {
                     cudaMipmappedArray_t 
                   mipmap;
                 } mipmap;
                 struct {
                     void *devPtr;
                     struct cudaChannelFormatDesc 
                   desc;
                     size_t sizeInBytes;
                 } linear;
                 struct {
                     void *devPtr;
                     struct cudaChannelFormatDesc 
                   desc;
                     size_t width;
                     size_t height;
                     size_t pitchInBytes;
                 } pitch2D;
             } res;
         };</pre>
   where:
   <ul>
     <li>
       <div>
         cudaResourceDesc::resType
         specifies the type of resource to texture from. CUresourceType is
         defined as: 
         <pre>        enum cudaResourceType {
             cudaResourceTypeArray          = 0x00,
             cudaResourceTypeMipmappedArray = 0x01,
             cudaResourceTypeLinear         = 0x02,
             cudaResourceTypePitch2D        = 0x03
         };</pre>
       </div>
     </li>
   </ul>
   </p>
   <p>If cudaResourceDesc::resType is set to
     cudaResourceTypeArray, cudaResourceDesc::res::array::array must be set
     to a valid CUDA array handle.
   </p>
   <p>If cudaResourceDesc::resType is set to
     cudaResourceTypeMipmappedArray, cudaResourceDesc::res::mipmap::mipmap
     must be set to a valid CUDA mipmapped array handle.
   </p>
   <p>If cudaResourceDesc::resType is set to
     cudaResourceTypeLinear, cudaResourceDesc::res::linear::devPtr must be
     set to a valid device pointer, that is aligned to
     cudaDeviceProp::textureAlignment. cudaResourceDesc::res::linear::desc
     describes the format and the number of components per array element.
     cudaResourceDesc::res::linear::sizeInBytes
     specifies the size of the array in bytes.
     The total number of elements in the linear address range cannot exceed
     cudaDeviceProp::maxTexture1DLinear. The number of elements is computed
     as (sizeInBytes / sizeof(desc)).
   </p>
   <p>If cudaResourceDesc::resType is set to
     cudaResourceTypePitch2D, cudaResourceDesc::res::pitch2D::devPtr must
     be set to a valid device pointer, that is aligned to
     cudaDeviceProp::textureAlignment. cudaResourceDesc::res::pitch2D::desc
     describes the format and the number of components per array element.
     cudaResourceDesc::res::pitch2D::width
     and cudaResourceDesc::res::pitch2D::height
     specify the width and height of the array in elements, and cannot
     exceed cudaDeviceProp::maxTexture2DLinear[0] and
     cudaDeviceProp::maxTexture2DLinear[1] respectively.
     cudaResourceDesc::res::pitch2D::pitchInBytes specifies the pitch
     between two rows in bytes and has to be
     aligned to cudaDeviceProp::texturePitchAlignment.
     Pitch cannot exceed cudaDeviceProp::maxTexture2DLinear[2].
   </p>
   <p>
     The cudaTextureDesc struct is defined as
   <pre>        struct cudaTextureDesc {
             enum cudaTextureAddressMode 
                   addressMode[3];
             enum cudaTextureFilterMode  
                   filterMode;
             enum cudaTextureReadMode    
                   readMode;
             int                         sRGB;
             int                         normalizedCoords;
             unsigned int                maxAnisotropy;
             enum cudaTextureFilterMode  
                   mipmapFilterMode;
             float                       mipmapLevelBias;
             float                       minMipmapLevelClamp;
             float                       maxMipmapLevelClamp;
         };</pre>
   where
   <ul>
     <li>
       <div>
         cudaTextureDesc::addressMode
         specifies the addressing mode for each dimension of the texture data.
         cudaTextureAddressMode is defined as: 
         <pre>        enum
 cudaTextureAddressMode {
             cudaAddressModeWrap   = 0,
             cudaAddressModeClamp  = 1,
             cudaAddressModeMirror = 2,
             cudaAddressModeBorder = 3
         };</pre>
         This is ignored if cudaResourceDesc::resType is
         cudaResourceTypeLinear. Also, if cudaTextureDesc::normalizedCoords is
         set to zero, the only supported address mode is cudaAddressModeClamp.
       </div>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <div>
         cudaTextureDesc::filterMode
         specifies the filtering mode to be used when fetching from the texture.
         cudaTextureFilterMode is defined as: 
         <pre>        enum
 cudaTextureFilterMode {
             cudaFilterModePoint  = 0,
             cudaFilterModeLinear = 1
         };</pre>
         This is ignored if cudaResourceDesc::resType is
         cudaResourceTypeLinear.
       </div>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <div>
         cudaTextureDesc::readMode
         specifies whether integer data should be converted to floating point
         or not. cudaTextureReadMode is defined as: 
         <pre>        enum
 cudaTextureReadMode {
             cudaReadModeElementType     = 0,
             cudaReadModeNormalizedFloat = 1
         };</pre>
         Note that this applies only to 8-bit and 16-bit
         integer formats. 32-bit integer format would not be promoted,
         regardless
         of whether or not this
         cudaTextureDesc::readMode is set cudaReadModeNormalizedFloat is
         specified.
       </div>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaTextureDesc::sRGB specifies
         whether sRGB to linear conversion should be performed during texture
         fetch.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaTextureDesc::normalizedCoords
         specifies whether the texture coordinates will be normalized or not.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaTextureDesc::maxAnisotropy
         specifies the maximum anistropy ratio to be used when doing anisotropic
         filtering. This value will be clamped to the range
         [1,16].
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaTextureDesc::mipmapFilterMode
         specifies the filter mode when the calculated mipmap level lies between
         two defined mipmap levels.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaTextureDesc::mipmapLevelBias
         specifies the offset to be applied to the calculated mipmap level.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaTextureDesc::minMipmapLevelClamp
         specifies the lower end of the mipmap level range to clamp access to.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaTextureDesc::maxMipmapLevelClamp
         specifies the upper end of the mipmap level range to clamp access to.
       </p>
     </li>
   </ul>
   </p>
   <p>The cudaResourceViewDesc struct is
     defined as 
   <pre>        struct cudaResourceViewDesc {
             enum cudaResourceViewFormat 
                   format;
             size_t                      width;
             size_t                      height;
             size_t                      depth;
             unsigned int                firstMipmapLevel;
             unsigned int                lastMipmapLevel;
             unsigned int                firstLayer;
             unsigned int                lastLayer;
         };</pre>
   where:
   <ul>
     <li>
       <p>cudaResourceViewDesc::format
         specifies how the data contained in the CUDA array or CUDA mipmapped
         array should be interpreted. Note that this can incur
         a change in size of the texture
         data. If the resource view format is a block compressed format, then
         the underlying CUDA array
         or CUDA mipmapped array has to
         have a 32-bit unsigned integer format with 2 or 4 channels, depending
         on the block compressed
         format. For ex., BC1 and BC4
         require the underlying CUDA array to have a 32-bit unsigned int with 2
         channels. The other BC
         formats require the underlying
         resource to have the same 32-bit unsigned int format but with 4
         channels.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaResourceViewDesc::width
         specifies the new width of the texture data. If the resource view
         format is a block compressed format, this value has to
         be 4 times the original width
         of the resource. For non block compressed formats, this value has to
         be equal to that of the
         original resource.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaResourceViewDesc::height
         specifies the new height of the texture data. If the resource view
         format is a block compressed format, this value has to
         be 4 times the original height
         of the resource. For non block compressed formats, this value has to
         be equal to that of the
         original resource.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaResourceViewDesc::depth
         specifies the new depth of the texture data. This value has to be equal
         to that of the original resource.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaResourceViewDesc::firstMipmapLevel
         specifies the most detailed mipmap level. This will be the new mipmap
         level zero. For non-mipmapped resources, this value
         has to be
         zero.cudaTextureDesc::minMipmapLevelClamp and
         cudaTextureDesc::maxMipmapLevelClamp will be relative to this value.
         For ex., if the firstMipmapLevel is set to 2, and a minMipmapLevelClamp
         of 1.2 is specified,
         then the actual minimum mipmap
         level clamp will be 3.2.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaResourceViewDesc::lastMipmapLevel
         specifies the least detailed mipmap level. For non-mipmapped resources,
         this value has to be zero.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaResourceViewDesc::firstLayer
         specifies the first layer index for layered textures. This will be the
         new layer zero. For non-layered resources, this value
         has to be zero.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>cudaResourceViewDesc::lastLayer
         specifies the last layer index for layered textures. For non-layered
         resources, this value has to be zero.
       </p>
     </li>
   </ul>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pTexObject</CODE> - Texture object to create<DD><CODE>pResDesc</CODE> - Resource descriptor<DD><CODE>pTexDesc</CODE> - Texture descriptor<DD><CODE>pResViewDesc</CODE> - Resource view descriptor
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDestroyTextureObject(jcuda.runtime.cudaTextureObject)"><CODE>cudaDestroyTextureObject(jcuda.runtime.cudaTextureObject)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDestroyTextureObject(jcuda.runtime.cudaTextureObject)"><!-- --></A><H3>
cudaDestroyTextureObject</H3>
<PRE>
public static int <B>cudaDestroyTextureObject</B>(<A HREF="../../jcuda/runtime/cudaTextureObject.html" title="class in jcuda.runtime">cudaTextureObject</A>&nbsp;texObject)</PRE>
<DL>
<DD>Destroys a texture object.
 
 <pre>
 cudaError_t cudaDestroyTextureObject (
      cudaTextureObject_t texObject )
 </pre>
 <div>
   <p>Destroys a texture object.  Destroys the
     texture object specified by <tt>texObject</tt>.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texObject</CODE> - Texture object to destroy
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateTextureObject(jcuda.runtime.cudaTextureObject, jcuda.runtime.cudaResourceDesc, jcuda.runtime.cudaTextureDesc, jcuda.runtime.cudaResourceViewDesc)"><CODE>cudaCreateTextureObject(jcuda.runtime.cudaTextureObject, jcuda.runtime.cudaResourceDesc, jcuda.runtime.cudaTextureDesc, jcuda.runtime.cudaResourceViewDesc)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetTextureObjectResourceDesc(jcuda.runtime.cudaResourceDesc, jcuda.runtime.cudaTextureObject)"><!-- --></A><H3>
cudaGetTextureObjectResourceDesc</H3>
<PRE>
public static int <B>cudaGetTextureObjectResourceDesc</B>(<A HREF="../../jcuda/runtime/cudaResourceDesc.html" title="class in jcuda.runtime">cudaResourceDesc</A>&nbsp;pResDesc,
                                                   <A HREF="../../jcuda/runtime/cudaTextureObject.html" title="class in jcuda.runtime">cudaTextureObject</A>&nbsp;texObject)</PRE>
<DL>
<DD>Returns a texture object's resource descriptor.
 
 <pre>
 cudaError_t cudaGetTextureObjectResourceDesc (
      cudaResourceDesc* pResDesc,
      cudaTextureObject_t texObject )
 </pre>
 <div>
   <p>Returns a texture object's resource
     descriptor.  Returns the resource descriptor for the texture object
     specified by <tt>texObject</tt>.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pResDesc</CODE> - Resource descriptor<DD><CODE>texObject</CODE> - Texture object
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateTextureObject(jcuda.runtime.cudaTextureObject, jcuda.runtime.cudaResourceDesc, jcuda.runtime.cudaTextureDesc, jcuda.runtime.cudaResourceViewDesc)"><CODE>cudaCreateTextureObject(jcuda.runtime.cudaTextureObject, jcuda.runtime.cudaResourceDesc, jcuda.runtime.cudaTextureDesc, jcuda.runtime.cudaResourceViewDesc)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetTextureObjectTextureDesc(jcuda.runtime.cudaTextureDesc, jcuda.runtime.cudaTextureObject)"><!-- --></A><H3>
cudaGetTextureObjectTextureDesc</H3>
<PRE>
public static int <B>cudaGetTextureObjectTextureDesc</B>(<A HREF="../../jcuda/runtime/cudaTextureDesc.html" title="class in jcuda.runtime">cudaTextureDesc</A>&nbsp;pTexDesc,
                                                  <A HREF="../../jcuda/runtime/cudaTextureObject.html" title="class in jcuda.runtime">cudaTextureObject</A>&nbsp;texObject)</PRE>
<DL>
<DD>Returns a texture object's texture descriptor.
 
 <pre>
 cudaError_t cudaGetTextureObjectTextureDesc (
      cudaTextureDesc* pTexDesc,
      cudaTextureObject_t texObject )
 </pre>
 <div>
   <p>Returns a texture object's texture
     descriptor.  Returns the texture descriptor for the texture object
     specified by <tt>texObject</tt>.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pTexDesc</CODE> - Texture descriptor<DD><CODE>texObject</CODE> - Texture object
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateTextureObject(jcuda.runtime.cudaTextureObject, jcuda.runtime.cudaResourceDesc, jcuda.runtime.cudaTextureDesc, jcuda.runtime.cudaResourceViewDesc)"><CODE>cudaCreateTextureObject(jcuda.runtime.cudaTextureObject, jcuda.runtime.cudaResourceDesc, jcuda.runtime.cudaTextureDesc, jcuda.runtime.cudaResourceViewDesc)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetTextureObjectResourceViewDesc(jcuda.runtime.cudaResourceViewDesc, jcuda.runtime.cudaTextureObject)"><!-- --></A><H3>
cudaGetTextureObjectResourceViewDesc</H3>
<PRE>
public static int <B>cudaGetTextureObjectResourceViewDesc</B>(<A HREF="../../jcuda/runtime/cudaResourceViewDesc.html" title="class in jcuda.runtime">cudaResourceViewDesc</A>&nbsp;pResViewDesc,
                                                       <A HREF="../../jcuda/runtime/cudaTextureObject.html" title="class in jcuda.runtime">cudaTextureObject</A>&nbsp;texObject)</PRE>
<DL>
<DD>Returns a texture object's resource view descriptor.
 
 <pre>
 cudaError_t cudaGetTextureObjectResourceViewDesc (
      cudaResourceViewDesc* pResViewDesc,
      cudaTextureObject_t texObject )
 </pre>
 <div>
   <p>Returns a texture object's resource view
     descriptor.  Returns the resource view descriptor for the texture
     object specified
     by <tt>texObject</tt>. If no resource
     view was specified, cudaErrorInvalidValue is returned.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pResViewDesc</CODE> - Resource view descriptor<DD><CODE>texObject</CODE> - Texture object
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateTextureObject(jcuda.runtime.cudaTextureObject, jcuda.runtime.cudaResourceDesc, jcuda.runtime.cudaTextureDesc, jcuda.runtime.cudaResourceViewDesc)"><CODE>cudaCreateTextureObject(jcuda.runtime.cudaTextureObject, jcuda.runtime.cudaResourceDesc, jcuda.runtime.cudaTextureDesc, jcuda.runtime.cudaResourceViewDesc)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaCreateSurfaceObject(jcuda.runtime.cudaSurfaceObject, jcuda.runtime.cudaResourceDesc)"><!-- --></A><H3>
cudaCreateSurfaceObject</H3>
<PRE>
public static int <B>cudaCreateSurfaceObject</B>(<A HREF="../../jcuda/runtime/cudaSurfaceObject.html" title="class in jcuda.runtime">cudaSurfaceObject</A>&nbsp;pSurfObject,
                                          <A HREF="../../jcuda/runtime/cudaResourceDesc.html" title="class in jcuda.runtime">cudaResourceDesc</A>&nbsp;pResDesc)</PRE>
<DL>
<DD>Creates a surface object.
 
 <pre>
 cudaError_t cudaCreateSurfaceObject (
      cudaSurfaceObject_t* pSurfObject,
      const cudaResourceDesc* pResDesc )
 </pre>
 <div>
   <p>Creates a surface object.  Creates a
     surface object and returns it in <tt>pSurfObject</tt>. <tt>pResDesc</tt> describes the data to perform surface load/stores on.
     cudaResourceDesc::resType must be cudaResourceTypeArray and
     cudaResourceDesc::res::array::array must be set to a valid CUDA array
     handle.
   </p>
   <p>Surface objects are only supported on
     devices of compute capability 3.0 or higher.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pSurfObject</CODE> - Surface object to create<DD><CODE>pResDesc</CODE> - Resource descriptor
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDestroySurfaceObject(jcuda.runtime.cudaSurfaceObject)"><CODE>cudaDestroySurfaceObject(jcuda.runtime.cudaSurfaceObject)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDestroySurfaceObject(jcuda.runtime.cudaSurfaceObject)"><!-- --></A><H3>
cudaDestroySurfaceObject</H3>
<PRE>
public static int <B>cudaDestroySurfaceObject</B>(<A HREF="../../jcuda/runtime/cudaSurfaceObject.html" title="class in jcuda.runtime">cudaSurfaceObject</A>&nbsp;surfObject)</PRE>
<DL>
<DD>Destroys a surface object.
 
 <pre>
 cudaError_t cudaDestroySurfaceObject (
      cudaSurfaceObject_t surfObject )
 </pre>
 <div>
   <p>Destroys a surface object.  Destroys the
     surface object specified by <tt>surfObject</tt>.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>surfObject</CODE> - Surface object to destroy
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateSurfaceObject(jcuda.runtime.cudaSurfaceObject, jcuda.runtime.cudaResourceDesc)"><CODE>cudaCreateSurfaceObject(jcuda.runtime.cudaSurfaceObject, jcuda.runtime.cudaResourceDesc)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetSurfaceObjectResourceDesc(jcuda.runtime.cudaResourceDesc, jcuda.runtime.cudaSurfaceObject)"><!-- --></A><H3>
cudaGetSurfaceObjectResourceDesc</H3>
<PRE>
public static int <B>cudaGetSurfaceObjectResourceDesc</B>(<A HREF="../../jcuda/runtime/cudaResourceDesc.html" title="class in jcuda.runtime">cudaResourceDesc</A>&nbsp;pResDesc,
                                                   <A HREF="../../jcuda/runtime/cudaSurfaceObject.html" title="class in jcuda.runtime">cudaSurfaceObject</A>&nbsp;surfObject)</PRE>
<DL>
<DD>Returns a surface object's resource descriptor Returns the resource descriptor for the surface object specified by surfObject.
 
 <pre>
 cudaError_t cudaGetSurfaceObjectResourceDesc (
      cudaResourceDesc* pResDesc,
      cudaSurfaceObject_t surfObject )
 </pre>
 <div>
   <p>Returns a surface object's resource
     descriptor Returns the resource descriptor for the surface object
     specified by <tt>surfObject</tt>.  
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pResDesc</CODE> - Resource descriptor<DD><CODE>surfObject</CODE> - Surface object
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateSurfaceObject(jcuda.runtime.cudaSurfaceObject, jcuda.runtime.cudaResourceDesc)"><CODE>cudaCreateSurfaceObject(jcuda.runtime.cudaSurfaceObject, jcuda.runtime.cudaResourceDesc)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaConfigureCall(jcuda.runtime.dim3, jcuda.runtime.dim3, long, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaConfigureCall</H3>
<PRE>
public static int <B>cudaConfigureCall</B>(<A HREF="../../jcuda/runtime/dim3.html" title="class in jcuda.runtime">dim3</A>&nbsp;gridDim,
                                    <A HREF="../../jcuda/runtime/dim3.html" title="class in jcuda.runtime">dim3</A>&nbsp;blockDim,
                                    long&nbsp;sharedMem,
                                    <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Configure a device-launch.
 
 <pre>
 cudaError_t cudaConfigureCall (
      dim3 gridDim,
      dim3 blockDim,
      size_t sharedMem = 0,
      cudaStream_t stream = 0 )
 </pre>
 <div>
   <p>Configure a device-launch.  Specifies
     the grid and block dimensions for the device call to be executed
     similar to the execution
     configuration syntax. cudaConfigureCall()
     is stack based. Each call pushes data on top of an execution stack.
     This data contains the dimension for the grid and thread
     blocks, together with any arguments for
     the call.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>gridDim</CODE> - Grid dimensions<DD><CODE>blockDim</CODE> - Block dimensions<DD><CODE>sharedMem</CODE> - Shared memory<DD><CODE>stream</CODE> - Stream identifier
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidConfiguration<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetCacheConfig(int)"><CODE>cudaDeviceSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFuncGetAttributes(jcuda.runtime.cudaFuncAttributes, java.lang.String)"><CODE>cudaFuncGetAttributes(jcuda.runtime.cudaFuncAttributes, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaLaunch(java.lang.String)"><CODE>cudaLaunch(java.lang.String)</CODE></A>, 
<CODE>JCuda#cudaSetDoubleForDevice</CODE>, 
<CODE>JCuda#cudaSetDoubleForHost</CODE>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetupArgument(jcuda.Pointer, long, long)"><CODE>cudaSetupArgument(jcuda.Pointer, long, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaSetupArgument(jcuda.Pointer, long, long)"><!-- --></A><H3>
cudaSetupArgument</H3>
<PRE>
public static int <B>cudaSetupArgument</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;arg,
                                    long&nbsp;size,
                                    long&nbsp;offset)</PRE>
<DL>
<DD>[C++ API] Configure a device launch
 
 <pre>
 template < class T > cudaError_t cudaSetupArgument (
      T arg,
      size_t offset ) [inline]
 </pre>
 <div>
   <p>[C++ API] Configure a device launch 
     Pushes <tt>size</tt> bytes of the argument pointed to by <tt>arg</tt>
     at <tt>offset</tt> bytes from the start of the parameter passing area,
     which starts at offset 0. The arguments are stored in the top of the
     execution stack. cudaSetupArgument() must
     be preceded by a call to cudaConfigureCall().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>arg</CODE> - Argument to push for a kernel launch<DD><CODE>size</CODE> - Size of argument<DD><CODE>offset</CODE> - Offset in argument stack to push new arg<DD><CODE>arg</CODE> - Argument to push for a kernel launch<DD><CODE>offset</CODE> - Offset in argument stack to push new arg
<DT><B>Returns:</B><DD>cudaSuccess<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaConfigureCall(jcuda.runtime.dim3, jcuda.runtime.dim3, long, jcuda.runtime.cudaStream_t)"><CODE>cudaConfigureCall(jcuda.runtime.dim3, jcuda.runtime.dim3, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFuncGetAttributes(jcuda.runtime.cudaFuncAttributes, java.lang.String)"><CODE>cudaFuncGetAttributes(jcuda.runtime.cudaFuncAttributes, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaLaunch(java.lang.String)"><CODE>cudaLaunch(java.lang.String)</CODE></A>, 
<CODE>JCuda#cudaSetDoubleForDevice</CODE>, 
<CODE>JCuda#cudaSetDoubleForHost</CODE>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetupArgument(jcuda.Pointer, long, long)"><CODE>cudaSetupArgument(jcuda.Pointer, long, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaFuncGetAttributes(jcuda.runtime.cudaFuncAttributes, java.lang.String)"><!-- --></A><H3>
cudaFuncGetAttributes</H3>
<PRE>
public static int <B>cudaFuncGetAttributes</B>(<A HREF="../../jcuda/runtime/cudaFuncAttributes.html" title="class in jcuda.runtime">cudaFuncAttributes</A>&nbsp;attr,
                                        java.lang.String&nbsp;func)</PRE>
<DL>
<DD>[C++ API] Find out attributes for a given function
 
 <pre>
 template < class T > cudaError_t cudaFuncGetAttributes (
      cudaFuncAttributes* attr,
      T* entry ) [inline]
 </pre>
 <div>
   <p>[C++ API] Find out attributes for a given
     function  This function obtains the attributes of a function specified
     via <tt>entry</tt>. The parameter <tt>entry</tt> must be a pointer
     to a function that executes on the device. The parameter specified by
     <tt>entry</tt> must be declared as a <tt>__global__</tt> function.
     The fetched attributes are placed in <tt>attr</tt>. If the specified
     function does not exist, then cudaErrorInvalidDeviceFunction is
     returned.
   </p>
   <p>Note that some function attributes such
     as maxThreadsPerBlock may vary based on the device that is currently
     being used.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>attr</CODE> - Return pointer to function's attributes<DD><CODE>func</CODE> - Device function symbol<DD><CODE>attr</CODE> - Return pointer to function's attributes<DD><CODE>entry</CODE> - Function to get attributes of
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError,
 cudaErrorInvalidDeviceFunction<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaConfigureCall(jcuda.runtime.dim3, jcuda.runtime.dim3, long, jcuda.runtime.cudaStream_t)"><CODE>cudaConfigureCall(jcuda.runtime.dim3, jcuda.runtime.dim3, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetCacheConfig(int)"><CODE>cudaDeviceSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFuncGetAttributes(jcuda.runtime.cudaFuncAttributes, java.lang.String)"><CODE>cudaFuncGetAttributes(jcuda.runtime.cudaFuncAttributes, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaLaunch(java.lang.String)"><CODE>cudaLaunch(java.lang.String)</CODE></A>, 
<CODE>JCuda#cudaSetDoubleForDevice</CODE>, 
<CODE>JCuda#cudaSetDoubleForHost</CODE>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetupArgument(jcuda.Pointer, long, long)"><CODE>cudaSetupArgument(jcuda.Pointer, long, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaLaunch(java.lang.String)"><!-- --></A><H3>
cudaLaunch</H3>
<PRE>
public static int <B>cudaLaunch</B>(java.lang.String&nbsp;symbol)</PRE>
<DL>
<DD>[C++ API] Launches a device function
 
 <pre>
 template < class T > cudaError_t cudaLaunch (
      T* func ) [inline]
 </pre>
 <div>
   <p>[C++ API] Launches a device function 
     Launches the function <tt>entry</tt> on the device. The parameter <tt>entry</tt> must be a function that executes on the device. The
     parameter specified by <tt>entry</tt> must be declared as a <tt>__global__</tt> function. cudaLaunch() must be preceded by a call to
     cudaConfigureCall() since it pops the data that was pushed by
     cudaConfigureCall() from the execution stack.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>func</CODE> - Device function symbol
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDeviceFunction,
 cudaErrorInvalidConfiguration, cudaErrorLaunchFailure,
 cudaErrorLaunchTimeout, cudaErrorLaunchOutOfResources,
 cudaErrorSharedObjectSymbolNotFound, cudaErrorSharedObjectInitFailed<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaConfigureCall(jcuda.runtime.dim3, jcuda.runtime.dim3, long, jcuda.runtime.cudaStream_t)"><CODE>cudaConfigureCall(jcuda.runtime.dim3, jcuda.runtime.dim3, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceSetCacheConfig(int)"><CODE>cudaDeviceSetCacheConfig(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFuncGetAttributes(jcuda.runtime.cudaFuncAttributes, java.lang.String)"><CODE>cudaFuncGetAttributes(jcuda.runtime.cudaFuncAttributes, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaLaunch(java.lang.String)"><CODE>cudaLaunch(java.lang.String)</CODE></A>, 
<CODE>JCuda#cudaSetDoubleForDevice</CODE>, 
<CODE>JCuda#cudaSetDoubleForHost</CODE>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetupArgument(jcuda.Pointer, long, long)"><CODE>cudaSetupArgument(jcuda.Pointer, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaThreadGetCacheConfig(int[])"><CODE>cudaThreadGetCacheConfig(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaThreadSetCacheConfig(int)"><CODE>cudaThreadSetCacheConfig(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGLSetGLDevice(int)"><!-- --></A><H3>
cudaGLSetGLDevice</H3>
<PRE>
public static int <B>cudaGLSetGLDevice</B>(int&nbsp;device)</PRE>
<DL>
<DD>Sets a CUDA device to use OpenGL interoperability.
 
 <pre>
 cudaError_t cudaGLSetGLDevice (
      int  device )
 </pre>
 <div>
   <p>Sets a CUDA device to use OpenGL
     interoperability.  
     Deprecated<span>This function is
     deprecated as of CUDA 5.0.</span>This function is deprecated and should
     no longer be used. It is no longer necessary to associate a CUDA device
     with an OpenGL
     context in order to achieve maximum
     interoperability performance.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>device</CODE> - Device to use for OpenGL interoperability
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevice,
 cudaErrorSetOnActiveProcess<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsGLRegisterBuffer(jcuda.runtime.cudaGraphicsResource, int, int)"><CODE>cudaGraphicsGLRegisterBuffer(jcuda.runtime.cudaGraphicsResource, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsGLRegisterImage(jcuda.runtime.cudaGraphicsResource, int, int, int)"><CODE>cudaGraphicsGLRegisterImage(jcuda.runtime.cudaGraphicsResource, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGLGetDevices(int[], int[], int, int)"><!-- --></A><H3>
cudaGLGetDevices</H3>
<PRE>
public static int <B>cudaGLGetDevices</B>(int[]&nbsp;pCudaDeviceCount,
                                   int[]&nbsp;pCudaDevices,
                                   int&nbsp;cudaDeviceCount,
                                   int&nbsp;cudaGLDeviceList_deviceList)</PRE>
<DL>
<DD>Gets the CUDA devices associated with the current OpenGL context.
 
 <pre>
 cudaError_t cudaGLGetDevices (
      unsigned int* pCudaDeviceCount,
      int* pCudaDevices,
      unsigned int  cudaDeviceCount,
      cudaGLDeviceList deviceList )
 </pre>
 <div>
   <p>Gets the CUDA devices associated with
     the current OpenGL context.  Returns in <tt>*pCudaDeviceCount</tt>
     the number of CUDA-compatible devices corresponding to the current
     OpenGL context. Also returns in <tt>*pCudaDevices</tt> at most <tt>cudaDeviceCount</tt> of the CUDA-compatible devices corresponding to
     the current OpenGL context. If any of the GPUs being used by the
     current
     OpenGL context are not CUDA capable then
     the call will return cudaErrorNoDevice.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCudaDeviceCount</CODE> - Returned number of CUDA devices corresponding to the current OpenGL context<DD><CODE>pCudaDevices</CODE> - Returned CUDA devices corresponding to the current OpenGL context<DD><CODE>cudaDeviceCount</CODE> - The size of the output device array pCudaDevices<DD><CODE>deviceList</CODE> - The set of devices to return. This set may be cudaGLDeviceListAll for all devices, cudaGLDeviceListCurrentFrame for the devices used to render the current frame (in SLI), or cudaGLDeviceListNextFrame for the devices used to render the next frame (in SLI).
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorNoDevice, cudaErrorUnknown<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsUnregisterResource(jcuda.runtime.cudaGraphicsResource)"><CODE>cudaGraphicsUnregisterResource(jcuda.runtime.cudaGraphicsResource)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)"><CODE>cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)"><CODE>cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGraphicsGLRegisterImage(jcuda.runtime.cudaGraphicsResource, int, int, int)"><!-- --></A><H3>
cudaGraphicsGLRegisterImage</H3>
<PRE>
public static int <B>cudaGraphicsGLRegisterImage</B>(<A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource,
                                              int&nbsp;image,
                                              int&nbsp;target,
                                              int&nbsp;Flags)</PRE>
<DL>
<DD>Register an OpenGL texture or renderbuffer object.
 
 <pre>
 cudaError_t cudaGraphicsGLRegisterImage (
      cudaGraphicsResource** resource,
      GLuint image,
      GLenum target,
      unsigned int  flags )
 </pre>
 <div>
   <p>Register an OpenGL texture or renderbuffer
     object.  Registers the texture or renderbuffer object specified by <tt>image</tt> for access by CUDA. A handle to the registered object is
     returned as <tt>resource</tt>.
   </p>
   <p><tt>target</tt> must match the type of
     the object, and must be one of GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE,
     GL_TEXTURE_CUBE_MAP, GL_TEXTURE_3D,
     GL_TEXTURE_2D_ARRAY, or GL_RENDERBUFFER.
   </p>
   <p>The register flags <tt>flags</tt>
     specify the intended usage, as follows:
   <ul>
     <li>
       <p>cudaGraphicsRegisterFlagsNone:
         Specifies no hints about how this resource will be used. It is therefore
         assumed that this resource will be read from and
         written to by CUDA. This is the
         default value.
       </p>
     </li>
     <li>
       <p>cudaGraphicsRegisterFlagsReadOnly:
         Specifies that CUDA will not write to this resource.
       </p>
     </li>
     <li>
       <p>cudaGraphicsRegisterFlagsWriteDiscard:
         Specifies that CUDA will not read from this resource and will write
         over the entire contents of the resource, so none of
         the data previously stored in
         the resource will be preserved.
       </p>
     </li>
     <li>
       <p>cudaGraphicsRegisterFlagsSurfaceLoadStore: Specifies that CUDA will
         bind this resource to a surface reference.
       </p>
     </li>
     <li>
       <p>cudaGraphicsRegisterFlagsTextureGather:
         Specifies that CUDA will perform texture gather operations on this
         resource.
       </p>
     </li>
   </ul>
   </p>
   <p>The following image formats are
     supported. For brevity's sake, the list is abbreviated. For ex., {GL_R,
     GL_RG} X {8, 16} would
     expand to the following 4 formats {GL_R8,
     GL_R16, GL_RG8, GL_RG16} :
   <ul>
     <li>
       <p>GL_RED, GL_RG, GL_RGBA,
         GL_LUMINANCE, GL_ALPHA, GL_LUMINANCE_ALPHA, GL_INTENSITY
       </p>
     </li>
     <li>
       <p>{GL_R, GL_RG, GL_RGBA} X {8,
         16, 16F, 32F, 8UI, 16UI, 32UI, 8I, 16I, 32I}
       </p>
     </li>
     <li>
       <p>{GL_LUMINANCE, GL_ALPHA,
         GL_LUMINANCE_ALPHA, GL_INTENSITY} X {8, 16, 16F_ARB, 32F_ARB, 8UI_EXT,
         16UI_EXT, 32UI_EXT, 8I_EXT,
         16I_EXT, 32I_EXT}
       </p>
     </li>
   </ul>
   </p>
   <p>The following image classes are currently
     disallowed:
   <ul>
     <li>
       <p>Textures with borders</p>
     </li>
     <li>
       <p>Multisampled renderbuffers</p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>resource</CODE> - Pointer to the returned object handle<DD><CODE>image</CODE> - name of texture or renderbuffer object to be registered<DD><CODE>target</CODE> - Identifies the type of object specified by image<DD><CODE>flags</CODE> - Register flags
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevice, cudaErrorInvalidValue,
 cudaErrorInvalidResourceHandle, cudaErrorUnknown<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsUnregisterResource(jcuda.runtime.cudaGraphicsResource)"><CODE>cudaGraphicsUnregisterResource(jcuda.runtime.cudaGraphicsResource)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)"><CODE>cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGraphicsGLRegisterBuffer(jcuda.runtime.cudaGraphicsResource, int, int)"><!-- --></A><H3>
cudaGraphicsGLRegisterBuffer</H3>
<PRE>
public static int <B>cudaGraphicsGLRegisterBuffer</B>(<A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource,
                                               int&nbsp;buffer,
                                               int&nbsp;Flags)</PRE>
<DL>
<DD>Registers an OpenGL buffer object.
 
 <pre>
 cudaError_t cudaGraphicsGLRegisterBuffer (
      cudaGraphicsResource** resource,
      GLuint buffer,
      unsigned int  flags )
 </pre>
 <div>
   <p>Registers an OpenGL buffer object. 
     Registers the buffer object specified by <tt>buffer</tt> for access
     by CUDA. A handle to the registered object is returned as <tt>resource</tt>. The register flags <tt>flags</tt> specify the intended
     usage, as follows:
   </p>
   <ul>
     <li>
       <p>cudaGraphicsRegisterFlagsNone:
         Specifies no hints about how this resource will be used. It is therefore
         assumed that this resource will be read from and
         written to by CUDA. This is the
         default value.
       </p>
     </li>
     <li>
       <p>cudaGraphicsRegisterFlagsReadOnly:
         Specifies that CUDA will not write to this resource.
       </p>
     </li>
     <li>
       <p>cudaGraphicsRegisterFlagsWriteDiscard:
         Specifies that CUDA will not read from this resource and will write
         over the entire contents of the resource, so none of
         the data previously stored in
         the resource will be preserved.
       </p>
     </li>
   </ul>
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>resource</CODE> - Pointer to the returned object handle<DD><CODE>buffer</CODE> - name of buffer object to be registered<DD><CODE>flags</CODE> - Register flags
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevice, cudaErrorInvalidValue,
 cudaErrorInvalidResourceHandle, cudaErrorUnknown<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsUnregisterResource(jcuda.runtime.cudaGraphicsResource)"><CODE>cudaGraphicsUnregisterResource(jcuda.runtime.cudaGraphicsResource)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)"><CODE>cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGLRegisterBufferObject(int)"><!-- --></A><H3>
cudaGLRegisterBufferObject</H3>
<PRE>
public static int <B>cudaGLRegisterBufferObject</B>(int&nbsp;bufObj)</PRE>
<DL>
<DD>Registers a buffer object for access by CUDA.
 
 <pre>
 cudaError_t cudaGLRegisterBufferObject (
      GLuint bufObj )
 </pre>
 <div>
   <p>Registers a buffer object for access by
     CUDA.  
     Deprecated<span>This function is
     deprecated as of CUDA 3.0.</span>Registers the buffer object of ID <tt>bufObj</tt> for access by CUDA. This function must be called before
     CUDA can map the buffer object. The OpenGL context used to create
     the buffer, or another context from the
     same share group, must be bound to the current thread when this is
     called.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bufObj</CODE> - Buffer object ID to register
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsGLRegisterBuffer(jcuda.runtime.cudaGraphicsResource, int, int)"><CODE>cudaGraphicsGLRegisterBuffer(jcuda.runtime.cudaGraphicsResource, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGLMapBufferObject(jcuda.Pointer, int)"><!-- --></A><H3>
cudaGLMapBufferObject</H3>
<PRE>
public static int <B>cudaGLMapBufferObject</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                        int&nbsp;bufObj)</PRE>
<DL>
<DD>Maps a buffer object for access by CUDA.
 
 <pre>
 cudaError_t cudaGLMapBufferObject (
      void** devPtr,
      GLuint bufObj )
 </pre>
 <div>
   <p>Maps a buffer object for access by CUDA.
     Deprecated<span>This function is
     deprecated as of CUDA 3.0.</span>Maps the buffer object of ID <tt>bufObj</tt> into the address space of CUDA and returns in <tt>*devPtr</tt> the base pointer of the resulting mapping. The buffer
     must have previously been registered by calling cudaGLRegisterBufferObject().
     While a buffer is mapped by CUDA, any OpenGL operation which references
     the buffer will result in undefined behavior. The
     OpenGL context used to create the buffer,
     or another context from the same share group, must be bound to the
     current thread
     when this is called.
   </p>
   <p>All streams in the current thread are
     synchronized with the current GL context.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>devPtr</CODE> - Returned device pointer to CUDA object<DD><CODE>bufObj</CODE> - Buffer object ID to map
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMapBufferObjectFailed<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGLUnmapBufferObject(int)"><!-- --></A><H3>
cudaGLUnmapBufferObject</H3>
<PRE>
public static int <B>cudaGLUnmapBufferObject</B>(int&nbsp;bufObj)</PRE>
<DL>
<DD>Unmaps a buffer object for access by CUDA.
 
 <pre>
 cudaError_t cudaGLUnmapBufferObject (
      GLuint bufObj )
 </pre>
 <div>
   <p>Unmaps a buffer object for access by
     CUDA.  
     Deprecated<span>This function is
     deprecated as of CUDA 3.0.</span>Unmaps the buffer object of ID <tt>bufObj</tt> for access by CUDA. When a buffer is unmapped, the base
     address returned by cudaGLMapBufferObject() is invalid and subsequent
     references to the address result in undefined behavior. The OpenGL
     context used to create the buffer,
     or another context from the same share
     group, must be bound to the current thread when this is called.
   </p>
   <p>All streams in the current thread are
     synchronized with the current GL context.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bufObj</CODE> - Buffer object to unmap
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevicePointer,
 cudaErrorUnmapBufferObjectFailed<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsUnmapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsUnmapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGLUnregisterBufferObject(int)"><!-- --></A><H3>
cudaGLUnregisterBufferObject</H3>
<PRE>
public static int <B>cudaGLUnregisterBufferObject</B>(int&nbsp;bufObj)</PRE>
<DL>
<DD>Unregisters a buffer object for access by CUDA.
 
 <pre>
 cudaError_t cudaGLUnregisterBufferObject (
      GLuint bufObj )
 </pre>
 <div>
   <p>Unregisters a buffer object for access
     by CUDA.  
     Deprecated<span>This function is
     deprecated as of CUDA 3.0.</span>Unregisters the buffer object of ID
     <tt>bufObj</tt> for access by CUDA and releases any CUDA resources
     associated with the buffer. Once a buffer is unregistered, it may no
     longer
     be mapped by CUDA. The GL context used
     to create the buffer, or another context from the same share group,
     must be bound to
     the current thread when this is called.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bufObj</CODE> - Buffer object to unregister
<DT><B>Returns:</B><DD>cudaSuccess<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsUnregisterResource(jcuda.runtime.cudaGraphicsResource)"><CODE>cudaGraphicsUnregisterResource(jcuda.runtime.cudaGraphicsResource)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGLSetBufferObjectMapFlags(int, int)"><!-- --></A><H3>
cudaGLSetBufferObjectMapFlags</H3>
<PRE>
public static int <B>cudaGLSetBufferObjectMapFlags</B>(int&nbsp;bufObj,
                                                int&nbsp;flags)</PRE>
<DL>
<DD>Set usage flags for mapping an OpenGL buffer.
 
 <pre>
 cudaError_t cudaGLSetBufferObjectMapFlags (
      GLuint bufObj,
      unsigned int  flags )
 </pre>
 <div>
   <p>Set usage flags for mapping an OpenGL
     buffer.  
     Deprecated<span>This function is
     deprecated as of CUDA 3.0.</span>Set flags for mapping the OpenGL
     buffer <tt>bufObj</tt>
   </p>
   <p>Changes to flags will take effect the
     next time <tt>bufObj</tt> is mapped. The <tt>flags</tt> argument may
     be any of the following:
   </p>
   <ul>
     <li>
       <p>cudaGLMapFlagsNone: Specifies
         no hints about how this buffer will be used. It is therefore assumed
         that this buffer will be read from and written
         to by CUDA kernels. This is the
         default value.
       </p>
     </li>
     <li>
       <p>cudaGLMapFlagsReadOnly:
         Specifies that CUDA kernels which access this buffer will not write to
         the buffer.
       </p>
     </li>
     <li>
       <p>cudaGLMapFlagsWriteDiscard:
         Specifies that CUDA kernels which access this buffer will not read from
         the buffer and will write over the entire contents
         of the buffer, so none of the
         data previously stored in the buffer will be preserved.
       </p>
     </li>
   </ul>
   </p>
   <p>If <tt>bufObj</tt> has not been
     registered for use with CUDA, then cudaErrorInvalidResourceHandle is
     returned. If <tt>bufObj</tt> is presently mapped for access by CUDA,
     then cudaErrorUnknown is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bufObj</CODE> - Registered buffer object to set flags for<DD><CODE>flags</CODE> - Parameters for buffer mapping
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidResourceHandle,
 cudaErrorUnknown<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsResourceSetMapFlags(jcuda.runtime.cudaGraphicsResource, int)"><CODE>cudaGraphicsResourceSetMapFlags(jcuda.runtime.cudaGraphicsResource, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGLMapBufferObjectAsync(jcuda.Pointer, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaGLMapBufferObjectAsync</H3>
<PRE>
public static int <B>cudaGLMapBufferObjectAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                             int&nbsp;bufObj,
                                             <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Maps a buffer object for access by CUDA.
 
 <pre>
 cudaError_t cudaGLMapBufferObjectAsync (
      void** devPtr,
      GLuint bufObj,
      cudaStream_t stream )
 </pre>
 <div>
   <p>Maps a buffer object for access by CUDA.
     Deprecated<span>This function is
     deprecated as of CUDA 3.0.</span>Maps the buffer object of ID <tt>bufObj</tt> into the address space of CUDA and returns in <tt>*devPtr</tt> the base pointer of the resulting mapping. The buffer
     must have previously been registered by calling cudaGLRegisterBufferObject().
     While a buffer is mapped by CUDA, any OpenGL operation which references
     the buffer will result in undefined behavior. The
     OpenGL context used to create the buffer,
     or another context from the same share group, must be bound to the
     current thread
     when this is called.
   </p>
   <p>Stream /p stream is synchronized with
     the current GL context.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>devPtr</CODE> - Returned device pointer to CUDA object<DD><CODE>bufObj</CODE> - Buffer object ID to map<DD><CODE>stream</CODE> - Stream to synchronize
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMapBufferObjectFailed<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGLUnmapBufferObjectAsync(int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaGLUnmapBufferObjectAsync</H3>
<PRE>
public static int <B>cudaGLUnmapBufferObjectAsync</B>(int&nbsp;bufObj,
                                               <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Unmaps a buffer object for access by CUDA.
 
 <pre>
 cudaError_t cudaGLUnmapBufferObjectAsync (
      GLuint bufObj,
      cudaStream_t stream )
 </pre>
 <div>
   <p>Unmaps a buffer object for access by
     CUDA.  
     Deprecated<span>This function is
     deprecated as of CUDA 3.0.</span>Unmaps the buffer object of ID <tt>bufObj</tt> for access by CUDA. When a buffer is unmapped, the base
     address returned by cudaGLMapBufferObject() is invalid and subsequent
     references to the address result in undefined behavior. The OpenGL
     context used to create the buffer,
     or another context from the same share
     group, must be bound to the current thread when this is called.
   </p>
   <p>Stream /p stream is synchronized with
     the current GL context.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bufObj</CODE> - Buffer object to unmap<DD><CODE>stream</CODE> - Stream to synchronize
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevicePointer,
 cudaErrorUnmapBufferObjectFailed<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsUnmapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsUnmapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDriverGetVersion(int[])"><!-- --></A><H3>
cudaDriverGetVersion</H3>
<PRE>
public static int <B>cudaDriverGetVersion</B>(int[]&nbsp;driverVersion)</PRE>
<DL>
<DD>Returns the CUDA driver version.
 
 <pre>
 cudaError_t cudaDriverGetVersion (
      int* driverVersion )
 </pre>
 <div>
   <p>Returns the CUDA driver version.  Returns
     in <tt>*driverVersion</tt> the version number of the installed CUDA
     driver. If no driver is installed, then 0 is returned as the driver
     version (via
     <tt>driverVersion</tt>). This function
     automatically returns cudaErrorInvalidValue if the <tt>driverVersion</tt>
     argument is NULL.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>driverVersion</CODE> - Returns the CUDA driver version.
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaRuntimeGetVersion(int[])"><CODE>cudaRuntimeGetVersion(int[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaRuntimeGetVersion(int[])"><!-- --></A><H3>
cudaRuntimeGetVersion</H3>
<PRE>
public static int <B>cudaRuntimeGetVersion</B>(int[]&nbsp;runtimeVersion)</PRE>
<DL>
<DD>Returns the CUDA Runtime version.
 
 <pre>
 cudaError_t cudaRuntimeGetVersion (
      int* runtimeVersion )
 </pre>
 <div>
   <p>Returns the CUDA Runtime version. 
     Returns in <tt>*runtimeVersion</tt> the version number of the installed
     CUDA Runtime. This function automatically returns cudaErrorInvalidValue
     if the <tt>runtimeVersion</tt> argument is NULL.
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>runtimeVersion</CODE> - Returns the CUDA Runtime version.
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDriverGetVersion(int[])"><CODE>cudaDriverGetVersion(int[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaPointerGetAttributes(jcuda.runtime.cudaPointerAttributes, jcuda.Pointer)"><!-- --></A><H3>
cudaPointerGetAttributes</H3>
<PRE>
public static int <B>cudaPointerGetAttributes</B>(<A HREF="../../jcuda/runtime/cudaPointerAttributes.html" title="class in jcuda.runtime">cudaPointerAttributes</A>&nbsp;attributes,
                                           <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr)</PRE>
<DL>
<DD>Returns attributes about a specified pointer.
 
 <pre>
 cudaError_t cudaPointerGetAttributes (
      cudaPointerAttributes* attributes,
      const void* ptr )
 </pre>
 <div>
   <p>Returns attributes about a specified
     pointer.  Returns in <tt>*attributes</tt> the attributes of the
     pointer <tt>ptr</tt>.
   </p>
   <p>The cudaPointerAttributes structure is
     defined as: 
   <pre>    struct cudaPointerAttributes {
         enum cudaMemoryType 
                   memoryType;
         int device;
         void *devicePointer;
         void *hostPointer;
     }</pre>
   In this structure, the individual fields mean</p>
   <ul>
     <li>
       <p>memoryType identifies the
         physical location of the memory associated with pointer <tt>ptr</tt>.
         It can be cudaMemoryTypeHost for host memory or cudaMemoryTypeDevice
         for device memory.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>device is the device against
         which <tt>ptr</tt> was allocated. If <tt>ptr</tt> has memory type
         cudaMemoryTypeDevice then this identifies the device on which the
         memory referred to by <tt>ptr</tt> physically resides. If <tt>ptr</tt>
         has memory type cudaMemoryTypeHost then this identifies the device
         which was current when the allocation was made (and if that device is
         deinitialized then
         this allocation will vanish with
         that device's state).
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>devicePointer is the device
         pointer alias through which the memory referred to by <tt>ptr</tt>
         may be accessed on the current device. If the memory referred to by
         <tt>ptr</tt> cannot be accessed directly by the current device then
         this is NULL.
       </p>
     </li>
   </ul>
   </p>
   <ul>
     <li>
       <p>hostPointer is the host pointer
         alias through which the memory referred to by <tt>ptr</tt> may be
         accessed on the host. If the memory referred to by <tt>ptr</tt> cannot
         be accessed directly by the host then this is NULL.
       </p>
     </li>
   </ul>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>attributes</CODE> - Attributes for the specified pointer<DD><CODE>ptr</CODE> - Pointer to get attributes for
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevice<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceCount(int[])"><CODE>cudaGetDeviceCount(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDevice(int[])"><CODE>cudaGetDevice(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetDevice(int)"><CODE>cudaSetDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)"><CODE>cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDeviceCanAccessPeer(int[], int, int)"><!-- --></A><H3>
cudaDeviceCanAccessPeer</H3>
<PRE>
public static int <B>cudaDeviceCanAccessPeer</B>(int[]&nbsp;canAccessPeer,
                                          int&nbsp;device,
                                          int&nbsp;peerDevice)</PRE>
<DL>
<DD>Queries if a device may directly access a peer device's memory.
 
 <pre>
 cudaError_t cudaDeviceCanAccessPeer (
      int* canAccessPeer,
      int  device,
      int  peerDevice )
 </pre>
 <div>
   <p>Queries if a device may directly access
     a peer device's memory.  Returns in <tt>*canAccessPeer</tt> a value
     of 1 if device <tt>device</tt> is capable of directly accessing memory
     from <tt>peerDevice</tt> and 0 otherwise. If direct access of <tt>peerDevice</tt> from <tt>device</tt> is possible, then access may be
     enabled by calling cudaDeviceEnablePeerAccess().
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>canAccessPeer</CODE> - Returned access capability<DD><CODE>device</CODE> - Device from which allocations on peerDevice are to be directly accessed.<DD><CODE>peerDevice</CODE> - Device on which the allocations to be directly accessed by device reside.
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevice<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceEnablePeerAccess(int, int)"><CODE>cudaDeviceEnablePeerAccess(int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceDisablePeerAccess(int)"><CODE>cudaDeviceDisablePeerAccess(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDeviceEnablePeerAccess(int, int)"><!-- --></A><H3>
cudaDeviceEnablePeerAccess</H3>
<PRE>
public static int <B>cudaDeviceEnablePeerAccess</B>(int&nbsp;peerDevice,
                                             int&nbsp;flags)</PRE>
<DL>
<DD>Enables direct access to memory allocations on a peer device.
 
 <pre>
 cudaError_t cudaDeviceEnablePeerAccess (
      int  peerDevice,
      unsigned int  flags )
 </pre>
 <div>
   <p>Enables direct access to memory
     allocations on a peer device.  On success, all allocations from <tt>peerDevice</tt> will immediately be accessible by the current device.
     They will remain accessible until access is explicitly disabled using
     cudaDeviceDisablePeerAccess() or either
     device is reset using cudaDeviceReset().
   </p>
   <p>Note that access granted by this call
     is unidirectional and that in order to access memory on the current
     device from <tt>peerDevice</tt>, a separate symmetric call to
     cudaDeviceEnablePeerAccess() is required.
   </p>
   <p>Peer access is not supported in 32 bit
     applications.
   </p>
   <p>Returns cudaErrorInvalidDevice if
     cudaDeviceCanAccessPeer() indicates that the current device cannot
     directly access memory from <tt>peerDevice</tt>.
   </p>
   <p>Returns cudaErrorPeerAccessAlreadyEnabled
     if direct access of <tt>peerDevice</tt> from the current device has
     already been enabled.
   </p>
   <p>Returns cudaErrorInvalidValue if <tt>flags</tt> is not 0.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>peerDevice</CODE> - Peer device to enable direct access to from the current device<DD><CODE>flags</CODE> - Reserved for future use and must be set to 0
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevice,
 cudaErrorPeerAccessAlreadyEnabled, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceCanAccessPeer(int[], int, int)"><CODE>cudaDeviceCanAccessPeer(int[], int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceDisablePeerAccess(int)"><CODE>cudaDeviceDisablePeerAccess(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDeviceDisablePeerAccess(int)"><!-- --></A><H3>
cudaDeviceDisablePeerAccess</H3>
<PRE>
public static int <B>cudaDeviceDisablePeerAccess</B>(int&nbsp;peerDevice)</PRE>
<DL>
<DD>Disables direct access to memory allocations on a peer device.
 
 <pre>
 cudaError_t cudaDeviceDisablePeerAccess (
      int  peerDevice )
 </pre>
 <div>
   <p>Disables direct access to memory
     allocations on a peer device.  Returns cudaErrorPeerAccessNotEnabled
     if direct access to memory on <tt>peerDevice</tt> has not yet been
     enabled from the current device.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>peerDevice</CODE> - Peer device to disable direct access to
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorPeerAccessNotEnabled,
 cudaErrorInvalidDevice<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceCanAccessPeer(int[], int, int)"><CODE>cudaDeviceCanAccessPeer(int[], int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceEnablePeerAccess(int, int)"><CODE>cudaDeviceEnablePeerAccess(int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGraphicsUnregisterResource(jcuda.runtime.cudaGraphicsResource)"><!-- --></A><H3>
cudaGraphicsUnregisterResource</H3>
<PRE>
public static int <B>cudaGraphicsUnregisterResource</B>(<A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource)</PRE>
<DL>
<DD>Unregisters a graphics resource for access by CUDA.
 
 <pre>
 cudaError_t cudaGraphicsUnregisterResource (
      cudaGraphicsResource_t resource )
 </pre>
 <div>
   <p>Unregisters a graphics resource for
     access by CUDA.  Unregisters the graphics resource <tt>resource</tt>
     so it is not accessible by CUDA unless registered again.
   </p>
   <p>If <tt>resource</tt> is invalid then
     cudaErrorInvalidResourceHandle is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>resource</CODE> - Resource to unregister
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidResourceHandle, cudaErrorUnknown<DT><B>See Also:</B><DD><CODE>JCuda#cudaGraphicsD3D9RegisterResource</CODE>, 
<CODE>JCuda#cudaGraphicsD3D10RegisterResource</CODE>, 
<CODE>JCuda#cudaGraphicsD3D11RegisterResource</CODE>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsGLRegisterBuffer(jcuda.runtime.cudaGraphicsResource, int, int)"><CODE>cudaGraphicsGLRegisterBuffer(jcuda.runtime.cudaGraphicsResource, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsGLRegisterImage(jcuda.runtime.cudaGraphicsResource, int, int, int)"><CODE>cudaGraphicsGLRegisterImage(jcuda.runtime.cudaGraphicsResource, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGraphicsResourceSetMapFlags(jcuda.runtime.cudaGraphicsResource, int)"><!-- --></A><H3>
cudaGraphicsResourceSetMapFlags</H3>
<PRE>
public static int <B>cudaGraphicsResourceSetMapFlags</B>(<A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource,
                                                  int&nbsp;flags)</PRE>
<DL>
<DD>Set usage flags for mapping a graphics resource.
 
 <pre>
 cudaError_t cudaGraphicsResourceSetMapFlags (
      cudaGraphicsResource_t resource,
      unsigned int  flags )
 </pre>
 <div>
   <p>Set usage flags for mapping a graphics
     resource.  Set <tt>flags</tt> for mapping the graphics resource <tt>resource</tt>.
   </p>
   <p>Changes to <tt>flags</tt> will take
     effect the next time <tt>resource</tt> is mapped. The <tt>flags</tt>
     argument may be any of the following:
   <ul>
     <li>
       <p>cudaGraphicsMapFlagsNone:
         Specifies no hints about how <tt>resource</tt> will be used. It is
         therefore assumed that CUDA may read from or write to <tt>resource</tt>.
       </p>
     </li>
     <li>
       <p>cudaGraphicsMapFlagsReadOnly:
         Specifies that CUDA will not write to <tt>resource</tt>.
       </p>
     </li>
     <li>
       <p>cudaGraphicsMapFlagsWriteDiscard:
         Specifies CUDA will not read from <tt>resource</tt> and will write
         over the entire contents of <tt>resource</tt>, so none of the data
         previously stored in <tt>resource</tt> will be preserved.
       </p>
     </li>
   </ul>
   </p>
   <p>If <tt>resource</tt> is presently
     mapped for access by CUDA then cudaErrorUnknown is returned. If <tt>flags</tt> is not one of the above values then cudaErrorInvalidValue
     is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>resource</CODE> - Registered resource to set flags for<DD><CODE>flags</CODE> - Parameters for resource mapping
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidResourceHandle,
 cudaErrorUnknown,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaGraphicsMapResources</H3>
<PRE>
public static int <B>cudaGraphicsMapResources</B>(int&nbsp;count,
                                           <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>[]&nbsp;resources,
                                           <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Map graphics resources for access by CUDA.
 
 <pre>
 cudaError_t cudaGraphicsMapResources (
      int  count,
      cudaGraphicsResource_t* resources,
      cudaStream_t stream = 0 )
 </pre>
 <div>
   <p>Map graphics resources for access by
     CUDA.  Maps the <tt>count</tt> graphics resources in <tt>resources</tt>
     for access by CUDA.
   </p>
   <p>The resources in <tt>resources</tt>
     may be accessed by CUDA until they are unmapped. The graphics API from
     which <tt>resources</tt> were registered should not access any
     resources while they are mapped by CUDA. If an application does so,
     the results are
     undefined.
   </p>
   <p>This function provides the synchronization
     guarantee that any graphics calls issued before cudaGraphicsMapResources()
     will complete before any subsequent CUDA work issued in <tt>stream</tt>
     begins.
   </p>
   <p>If <tt>resources</tt> contains any
     duplicate entries then cudaErrorInvalidResourceHandle is returned. If
     any of <tt>resources</tt> are presently mapped for access by CUDA then
     cudaErrorUnknown is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - Number of resources to map<DD><CODE>resources</CODE> - Resources to map for CUDA<DD><CODE>stream</CODE> - Stream for synchronization
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidResourceHandle, cudaErrorUnknown<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)"><CODE>cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)"><CODE>cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsUnmapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsUnmapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGraphicsUnmapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaGraphicsUnmapResources</H3>
<PRE>
public static int <B>cudaGraphicsUnmapResources</B>(int&nbsp;count,
                                             <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>[]&nbsp;resources,
                                             <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Unmap graphics resources.
 
 <pre>
 cudaError_t cudaGraphicsUnmapResources (
      int  count,
      cudaGraphicsResource_t* resources,
      cudaStream_t stream = 0 )
 </pre>
 <div>
   <p>Unmap graphics resources.  Unmaps the
     <tt>count</tt> graphics resources in <tt>resources</tt>.
   </p>
   <p>Once unmapped, the resources in <tt>resources</tt> may not be accessed by CUDA until they are mapped
     again.
   </p>
   <p>This function provides the synchronization
     guarantee that any CUDA work issued in <tt>stream</tt> before
     cudaGraphicsUnmapResources() will complete before any subsequently
     issued graphics work begins.
   </p>
   <p>If <tt>resources</tt> contains any
     duplicate entries then cudaErrorInvalidResourceHandle is returned. If
     any of <tt>resources</tt> are not presently mapped for access by CUDA
     then cudaErrorUnknown is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - Number of resources to unmap<DD><CODE>resources</CODE> - Resources to unmap<DD><CODE>stream</CODE> - Stream for synchronization
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidResourceHandle, cudaErrorUnknown<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)"><!-- --></A><H3>
cudaGraphicsResourceGetMappedPointer</H3>
<PRE>
public static int <B>cudaGraphicsResourceGetMappedPointer</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                                       long[]&nbsp;size,
                                                       <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource)</PRE>
<DL>
<DD>Get an device pointer through which to access a mapped graphics resource.
 
 <pre>
 cudaError_t cudaGraphicsResourceGetMappedPointer (
      void** devPtr,
      size_t* size,
      cudaGraphicsResource_t resource )
 </pre>
 <div>
   <p>Get an device pointer through which to
     access a mapped graphics resource.  Returns in <tt>*devPtr</tt> a
     pointer through which the mapped graphics resource <tt>resource</tt>
     may be accessed. Returns in <tt>*size</tt> the size of the memory in
     bytes which may be accessed from that pointer. The value set in <tt>devPtr</tt> may change every time that <tt>resource</tt> is mapped.
   </p>
   <p>If <tt>resource</tt> is not a buffer
     then it cannot be accessed via a pointer and cudaErrorUnknown is
     returned. If <tt>resource</tt> is not mapped then cudaErrorUnknown is
     returned. * 
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>devPtr</CODE> - Returned pointer through which resource may be accessed<DD><CODE>size</CODE> - Returned size of the buffer accessible starting at *devPtr<DD><CODE>resource</CODE> - Mapped resource to access
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidResourceHandle,
 cudaErrorUnknown<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)"><CODE>cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)"><!-- --></A><H3>
cudaGraphicsSubResourceGetMappedArray</H3>
<PRE>
public static int <B>cudaGraphicsSubResourceGetMappedArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;arrayPtr,
                                                        <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource,
                                                        int&nbsp;arrayIndex,
                                                        int&nbsp;mipLevel)</PRE>
<DL>
<DD>Get an array through which to access a subresource of a mapped graphics resource.
 
 <pre>
 cudaError_t cudaGraphicsSubResourceGetMappedArray (
      cudaArray_t* array,
      cudaGraphicsResource_t resource,
      unsigned int  arrayIndex,
      unsigned int  mipLevel )
 </pre>
 <div>
   <p>Get an array through which to access a
     subresource of a mapped graphics resource.  Returns in <tt>*array</tt>
     an array through which the subresource of the mapped graphics resource
     <tt>resource</tt> which corresponds to array index <tt>arrayIndex</tt>
     and mipmap level <tt>mipLevel</tt> may be accessed. The value set in
     <tt>array</tt> may change every time that <tt>resource</tt> is
     mapped.
   </p>
   <p>If <tt>resource</tt> is not a texture
     then it cannot be accessed via an array and cudaErrorUnknown is
     returned. If <tt>arrayIndex</tt> is not a valid array index for <tt>resource</tt> then cudaErrorInvalidValue is returned. If <tt>mipLevel</tt> is not a valid mipmap level for <tt>resource</tt> then
     cudaErrorInvalidValue is returned. If <tt>resource</tt> is not mapped
     then cudaErrorUnknown is returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Returned array through which a subresource of resource may be accessed<DD><CODE>resource</CODE> - Mapped resource to access<DD><CODE>arrayIndex</CODE> - Array index for array textures or cubemap face index as defined by cudaGraphicsCubeFace for cubemap textures for the subresource to access<DD><CODE>mipLevel</CODE> - Mipmap level for the subresource to access
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidResourceHandle,
 cudaErrorUnknown<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)"><CODE>cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGraphicsResourceGetMappedMipmappedArray(jcuda.runtime.cudaMipmappedArray, jcuda.runtime.cudaGraphicsResource)"><!-- --></A><H3>
cudaGraphicsResourceGetMappedMipmappedArray</H3>
<PRE>
public static int <B>cudaGraphicsResourceGetMappedMipmappedArray</B>(<A HREF="../../jcuda/runtime/cudaMipmappedArray.html" title="class in jcuda.runtime">cudaMipmappedArray</A>&nbsp;mipmappedArray,
                                                              <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource)</PRE>
<DL>
<DD>Get a mipmapped array through which to access a mapped graphics resource.
 
 <pre>
 cudaError_t cudaGraphicsResourceGetMappedMipmappedArray (
      cudaMipmappedArray_t* mipmappedArray,
      cudaGraphicsResource_t resource )
 </pre>
 <div>
   <p>Get a mipmapped array through which to
     access a mapped graphics resource.  Returns in <tt>*mipmappedArray</tt>
     a mipmapped array through which the mapped graphics resource <tt>resource</tt> may be accessed. The value set in <tt>mipmappedArray</tt>
     may change every time that <tt>resource</tt> is mapped.
   </p>
   <p>If <tt>resource</tt> is not a texture
     then it cannot be accessed via an array and cudaErrorUnknown is
     returned. If <tt>resource</tt> is not mapped then cudaErrorUnknown is
     returned.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mipmappedArray</CODE> - Returned mipmapped array through which resource may be accessed<DD><CODE>resource</CODE> - Mapped resource to access
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidResourceHandle,
 cudaErrorUnknown<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)"><CODE>cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaProfilerInitialize(java.lang.String, java.lang.String, int)"><!-- --></A><H3>
cudaProfilerInitialize</H3>
<PRE>
public static int <B>cudaProfilerInitialize</B>(java.lang.String&nbsp;configFile,
                                         java.lang.String&nbsp;outputFile,
                                         int&nbsp;outputMode)</PRE>
<DL>
<DD>Initialize the CUDA profiler.
 
 <pre>
 cudaError_t cudaProfilerInitialize (
      const char* configFile,
      const char* outputFile,
      cudaOutputMode_t outputMode )
 </pre>
 <div>
   <p>Initialize the CUDA profiler.  Using this
     API user can initialize the CUDA profiler by specifying the configuration
     file,
     output file and output file format. This
     API is generally used to profile different set of counters by looping
     the kernel
     launch. The <tt>configFile</tt> parameter
     can be used to select profiling options including profiler counters.
     Refer to the "Compute Command Line Profiler
     User Guide" for supported profiler
     options and counters.
   </p>
   <p>Limitation: The CUDA profiler cannot be
     initialized with this API if another profiling tool is already active,
     as indicated
     by the cudaErrorProfilerDisabled return
     code.
   </p>
   <p>Typical usage of the profiling APIs is
     as follows:
   </p>
   <p>for each set of counters/options
     {
     cudaProfilerInitialize(); //Initialize
     profiling,set the counters/options in the config file 
     ...
     cudaProfilerStart(); 
     // code to be profiled 
     cudaProfilerStop();
     ...
     cudaProfilerStart(); 
     // code to be profiled 
     cudaProfilerStop();
     ...
     }
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>configFile</CODE> - Name of the config file that lists the counters/options for profiling.<DD><CODE>outputFile</CODE> - Name of the outputFile where the profiling results will be stored.<DD><CODE>outputMode</CODE> - outputMode, can be cudaKeyValuePair OR cudaCSV.
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorProfilerDisabled<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaProfilerStart()"><CODE>cudaProfilerStart()</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaProfilerStop()"><CODE>cudaProfilerStop()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaProfilerStart()"><!-- --></A><H3>
cudaProfilerStart</H3>
<PRE>
public static int <B>cudaProfilerStart</B>()</PRE>
<DL>
<DD>Enable profiling.
 
 <pre>
 cudaError_t cudaProfilerStart (
      void )
 </pre>
 <div>
   <p>Enable profiling.  Enables profile
     collection by the active profiling tool. If profiling is already
     enabled, then cudaProfilerStart() has no effect.
   </p>
   <p>cudaProfilerStart and cudaProfilerStop
     APIs are used to programmatically control the profiling granularity by
     allowing profiling
     to be done only on selective pieces of
     code.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaProfilerInitialize(java.lang.String, java.lang.String, int)"><CODE>cudaProfilerInitialize(java.lang.String, java.lang.String, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaProfilerStop()"><CODE>cudaProfilerStop()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaProfilerStop()"><!-- --></A><H3>
cudaProfilerStop</H3>
<PRE>
public static int <B>cudaProfilerStop</B>()</PRE>
<DL>
<DD>Disable profiling.
 
 <pre>
 cudaError_t cudaProfilerStop (
      void )
 </pre>
 <div>
   <p>Disable profiling.  Disables profile
     collection by the active profiling tool. If profiling is already
     disabled, then cudaProfilerStop() has no effect.
   </p>
   <p>cudaProfilerStart and cudaProfilerStop
     APIs are used to programmatically control the profiling granularity by
     allowing profiling
     to be done only on selective pieces of
     code.
   </p>
   <div>
     <span>Note:</span>
     <p>Note that this
       function may also return error codes from previous, asynchronous
       launches.
     </p>
   </div>
   </p>
 </div>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaProfilerInitialize(java.lang.String, java.lang.String, int)"><CODE>cudaProfilerInitialize(java.lang.String, java.lang.String, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaProfilerStart()"><CODE>cudaProfilerStart()</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JCuda.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../jcuda/runtime/dim3.html" title="class in jcuda.runtime"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../jcuda/runtime/surfaceReference.html" title="class in jcuda.runtime"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?jcuda/runtime/JCuda.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JCuda.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
