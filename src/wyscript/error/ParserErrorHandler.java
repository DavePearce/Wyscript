package wyscript.error;

import static wyscript.util.SyntaxError.*;

import java.util.List;

import wyscript.Main;
import wyscript.util.SyntaxError;

/**
 * Class that takes syntax errors generated by the WyScript Parser
 * and uses them to generate helpful error messages for the user.
 *
 * @author Daniel Campbell
 *
 */
public class ParserErrorHandler {

	public static void handle(List<ParserErrorData> errors) {

		for (ParserErrorData data : errors) {
			String msg = null;
			String suggestion = null;

			switch (data.type()) {

			//The generic case where a match failed. Simply tell them what was missing and where
			case MISSING_TOKEN:
				msg = String.format("Error: '%s' expected", data.expected());
				suggestion = data.expected().toString();
				break;

			case BAD_INDENT:
				msg = "Error: indentation must not increase within a block";
				suggestion = "";
				break;

			case DUPLICATE_TOKEN:
				msg = "Error: There already exists a record attribute with name " + data.found().text;
				suggestion = data.found().text+"Copy";
				break;

			case INVALID_TYPE:
				msg = "Error: <<type>> expected.\nNeed a base type, a list, a record, a union or a user defined type";
				suggestion = "void";
				break;

			case MISSING_EXPRESSION:
				msg = String.format("Error: found '%s', required <<expression>>", data.found().kind);
				suggestion = "null";
				break;

			case BAD_EXPRESSION_TYPE:
				msg = handleExpr(data);
				suggestion = "int example";
				break;

			case BAD_SWITCH_CASE:
				msg = "Error:  only 'case' or 'default' statements allowed";
				suggestion = "case:\n";
				break;

			case BAD_SWITCH_CONST:
				msg = handleExpr(data);
				suggestion = "null";
				break;

			case DUPLICATE_SWITCH_CONST:
				msg = handleExpr(data);
				suggestion = ((ParserExprErrorData)data).expr().toString() +"1";
				break;

			case SWITCH_MULTIPLE_DEFAULT:
				msg = "Error: only one default case allowed in switch body";
				suggestion = "case";
				break;

			case BAD_INCLUDE:
				msg = handleExpr(data);
				suggestion = null;
				break;

			case NAME_CLASH:
				msg = handleExpr(data);
				String name = ((ParserExprErrorData)data).expr().toString();
				suggestion = data.found().text.replaceAll(name, name + "Copy");
				break;
			}
			outputSourceError(Main.errout, msg, data.filename(), data.start(), data.end());
			if (suggestion != null)
				outputSuggestion(Main.errout, suggestion, data.filename(), data.start(), data.end());
		}

		throw new HandledException();
	}

	/**
	 * Utility method that handles errors over a whole expression instead of a single token
	 */
	private static String handleExpr(ParserErrorData d) {
		ParserExprErrorData data = (ParserExprErrorData) d;

		switch (data.type()) {

		case BAD_EXPRESSION_TYPE:
			return String.format("Error: expression %s cannot be assigned to.\nExpression must be a %s", data.expr(), data.expected());

		case DUPLICATE_SWITCH_CONST:
			return String.format("Error: a case already exists for constant %s", data.expr());

		case BAD_SWITCH_CONST:
			return String.format("Error: expression '%s' is not a constant.\nCase expressions must be a constant value", data.expr());

		case BAD_INCLUDE:
			return "Error: can't find file to include: " + data.expr().toString();

		case NAME_CLASH:
			String type = data.expected().toString();
			if (!type.equals("type") && !type.equals("constant"))
				type = "function";
			return String.format("Error: %s %s has already been declared", type, data.expr());

		default:
			throw new SyntaxError("Unknown parser error occurred on token " + d.found(), d.filename(), d.start(), d.end());
		}
	}
}
