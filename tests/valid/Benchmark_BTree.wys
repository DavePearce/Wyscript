// A Binary Search Tree where elements are stored in sorted order.
// That is, given a node n then we have the following invariant:
//
// n.left.item < n.item < n.right.item, etc.
//

// =================================================
// BTree.Node
// =================================================

type BTree is null | Node
type Node is {
    BTree left,
    BTree right,
    int item
}

Node node(int item):
    return {left: null, right: null, item: item}


Node node(BTree left, BTree right, int item):
    return {left: left, right: right, item: item}

// =================================================
// BTree
// =================================================

// Create an empty tree.
BTree bTree():
    return null

// Add an item into the tree
BTree add(BTree tree, int item):
    if tree == null:
        return node(item)
    else if tree.item == item:
        return tree
    else if tree.item < item:
        // add to right tree
        right = add(tree.right,item)
        return node(tree.left,right,tree.item)
    else:
        // add to left tree
        left = add(tree.left,item)
        return node(left,tree.right,tree.item)

string toString(BTree tree):
    if tree == null:
        return "null"
    else:
        return "(" + tree.item + ", " +
                 toString(tree.left) + ", " +
                 toString(tree.right) + ")"

// =================================================
// Test Harness
// =================================================

constant ITEMS is [54,7,201,52,3,1,0,54,12,90,9,8,8,7,34,32,35,34]

void main():
    bt = bTree()
    print toString(bt)
    for item in ITEMS:
        bt = add(bt,item)
        print toString(bt)
